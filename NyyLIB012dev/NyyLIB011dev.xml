<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>NyyLIB</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Mud Setup</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>minimap display</name>
					<script>if matches[2] == "\t\t\t" then
	-- closing \t\t\t arrived
	return
end

selectCurrentLine()
copy()
appendBuffer("minimapBuffer")
eraseLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>minimap marker</name>
					<script>if isActive("minimap display", "trigger") ~= 0 then
	-- minimap is currently active, the closing \t\t\t\n just arrived
	disableTrigger("minimap display")	
	eraseLine()

	miniMap:update()
else
	-- opening \t\t\t\n just arrived
	enableTrigger("minimap display")
	--clearWindow("minimapBuffer")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\t\t\t</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>replace tab trigger</name>
					<script>while selectString("\t",1) &gt; -1 do
  replace("     ")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\t</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>topgags</name>
					<script>-- You lack the proper component to use this power.

eraseLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>YiPeE! You can't see me</string>
						<string>Unsplit Coins: </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture Prompt</name>
					<script>-- &lt; 416h/416H 110v/110V T: Zusuk TC: excellent E: ultrumm EC: nasty wounds EP: sit P: std &gt; 
-- &lt; 1037h/1037H 134v/134V P: std &gt;
-- &lt; 824h/824H 547p/911P 111v/111V P: std &gt;


NyyLIB = NyyLIB or {}

spell:resetSlot()

-- not in paging mode if a prompt has arrived
pagingmode=nil

if matches[2] ~= "" then
	prompt:set("hp", tonumber(matches[2]))
end

if matches[3] ~= "" then
	prompt:set("maxhp", tonumber(matches[3]))
end

if matches[4] ~= "" then
	prompt:set("psp", tonumber(matches[4]))
else
	prompt:set("psp", nil)
end

if matches[5] ~= "" then
	prompt:set("maxpsp", tonumber(matches[5]))
else
	prompt:set("maxpsp", nil)
end

if matches[6] ~= "" then
	prompt:set("mv", tonumber(matches[6]))
end

if matches[7] ~= "" then
	prompt:set("maxmv", tonumber(matches[7]))
end

-- matches[8] is the powers prompt
if matches[8] ~= "" then
	prompt:decodePowers(matches[8])
end

-- matches[9] - spell slots

if matches[9] ~= "" then
	prompt:decodeSpellSlots(matches[9])
end


prompt:set("tank", matches[10]:trim())
prompt:set("tankcondition", matches[11]:trim())
prompt:set("enemy", matches[12]:trim())

if prompt:get("enemy") ~= "" then
	setEnemy( string.title(prompt:get("enemy")) )
end

prompt:set("enemycondition", matches[13]:trim())
prompt:set("enemyposition", matches[14]:trim())
prompt:set("position", matches[15]:trim())

groupList:setHP(whoami(), prompt:get("hp"), prompt:get("maxhp") )

raiseEvent("promptEvent")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>&lt; (?:(\d+)h)?\/?(?:(\d+)H)? ?(?:(\d+)p)?\/?(?:(\d+)P)? ?(?:(\d+)v)?\/?(?:(\d+)V)? ?[\|]?((?:[a-z]+ [0-9+]+\|)+)? ?[\|]?((?:[0-9 ]\|)+)? ?(?:T: ([A-Za-z ]+))? ?(?:TC: ([A-Za-z ]+))? ?(?:E: ([A-Za-z '-]+))? ?(?:EC: ([A-Za-z ]+))? ?(?:EP: ([A-Za-z ]+))? (?:P: (.*)) ?.*&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Reconnect to Toril</name>
					<script>-- Initialization trigger on reconnect to toril.

-- reset any previously queued spells / commands
mud.varsendqueue={}
spell:clear()

NyyLIB.initgui=false

--mount:set(nil)

-- erase current value of assassinate timer
timer:set("assassinatetimer", nil)

setHide(false)
group:send(false)
sendFollowers(false)

mud:send("display enemypos", false)
mud:send("display position", false)
mud:send("display twoline", false)
mud:send("display slots", false)
mud:send("ATT", false)
mud:send("SC", false)
mud:send("EQUIP", false)
group:send()
sendStatus()
mud:send("EXP", true)
mud:send("CONSENT", false)

local assocchar = charData:get("assocchar", true)

if assocchar ~= "" then
	mud:send("assoc chat " .. assocchar, false )
	mud:send("storage access " .. assocchar, false )
end

tempTimer(1.5, [[look:send()]])

tempTimer(4, [[expandAlias("@resettrain", false)]])

-- set map room to nil

map:setRoom(nil)
centerview(1)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Reconnecting...</string>
						<string>Restoring items from crash save info...</string>
						<string>^Find us on the web[:]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Twoline display turned ON.</name>
					<script>-- mud configuration

mud:send("display twoline")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Twoline display turned ON.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Type the # or name of a character above to login or choose an action below.</name>
					<script>if whoami() ~= nil then
	if charData:get("reconnect") ~= false then
		send(charData:get("reconnect") )
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Type the # or name of a character above to login or choose an action below.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Enemy position display turned OFF.</name>
					<script>-- mud configuration

mud:send("display enemypos")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Enemy position display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>to get started. You can then link all of your characters to your new account</name>
					<script>map:hide()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>  to get started. You can then link all of your characters to your new account$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Anti-Timeout</name>
					<script>--if 	NyyLIB.initgui and map:countMovement() &gt; 0 then
--	look:send()
--end

if NyyLIB.initgui then
	--mud:send("TIME")
end

checkVoteButton()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Autosaving...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Position display turned OFF.</name>
					<script>mud:send("display position")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Position display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Spell slots display turned OFF.</name>
					<script>mud:send("display slots")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Spell slots display turned OFF.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hear tells</name>
					<script>-- You can now hear Tells.
-- You are now deaf to Tells.

canHear = matches[2]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can now (hear) Tells.</string>
						<string>You are now (deaf) to Tells.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>rescue-assist</name>
					<script>--enable: tog rescue-assist
-- You will no longer auto-assist after being rescued.
-- You will no longer auto-assist after being rescued.

mud:send("tog rescue-assist")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?You will no longer auto-assist after being rescued.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>identify mob</name>
				<script>--&lt; 814h/814H 110v/110V T: Vori TC: excellent E: lavis EC: nasty wounds EP: std P: std &gt;

--Vori sends Lavis Ryl sprawling with a powerful bash.
--[Error: Trying to set Vori as enemy!]
-- "&lt; 814h/814H 110v/110V T: Vori TC: excellent E: forell EC: small wounds EP: std P: std &gt; Vori"


-- Dagrathigon barely wounds a githyanki soldier with his massive pierce.
-- error, same


-- The spirit wolf barely wounds an elite barbazu soldier with its mighty drain.

-- A red abishai patrol member barely wounds Ferifle with his weak slash.
-- a minion of Moander 


if matches[2] == "Someone" or matches[3] == "someone" then
	return
end


local enemy
local player


if groupList:ingroup(matches[2]) then
	enemy=matches[3]
	player=matches[2]
else
	enemy=matches[2]
	player=matches[3]
end

if enemy ~= nil then
	enemy=idMob(enemy)
else
	cecho("&lt;red&gt;\n[Error: nil enemy]\n")
	return
end


if groupList:ingroup(enemy) then
	cecho("&lt;red&gt;\n[Error: Trying to set " .. enemy .. " as enemy!]\n")
	--display( matches[2] )
	--display( matches[3] )

	return
end

if groupList:ingroup(player) then
	if getEnemy() == "" then
		setEnemy( enemy )
	end
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>([A-Za-z]+) sends (.*) sprawling with a powerful bash.</string>
					<string>([A-Za-z]+) barely wounds (.*) with .*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>reset variables</name>
				<script>-- clear enteredportal count

enteredPortal = {}

assistSent = nil

-- spell:setCurrent()
-- it's possible to send look+cast, and have look return first

fleeAttempt = 0

sendingStatus = false</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Exits: (.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Demonnic</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Tabbed Chat</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>GSAY</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true

	demonnic.chat:append("GSAY", whoMatch, bodyMatch)

	--if matches[2]:trim() == NyyLIB.leader then
	--	demonnic.chat:append("GCMD", whoMatch, bodyMatch)
	--end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z ]+ )group-says? ('.*')$</string>
							<string>^(?:&lt; .* &gt; )?([A-Za-z ]+ )group-projects? ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>OOC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("OOC", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )OOC: ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>NHC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("NHC", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )NHC:(?: \(H\))? ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ACC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("ACC", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )ASSOC::? ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>GCC</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("GCC", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )GCC: ('.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>TELLS</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("TELLS", whoMatch, bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>39</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(.* )tells you ('.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You tell )(.*)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Skill</name>
						<script>-- ([A-Za-z]+) has died!

local bodyMatch= getColourString( matches[2] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("SKILL", bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(You have learned something new about .*)$</string>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ has died!)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Gruumsh responds to your petition with</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

-- Beshaba responds to your petition with
if not chatCapture then
	chatCapture=true
	demonnic.chat:append("TELLS", whoMatch, bodyMatch)

	sound("365641__furbyguy__8-bit-alarm.wav",nil,true) 
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )responds to your petition with (.*)</string>
							<string>^(?:&lt; .* &gt; )?(You )petition (.*)</string>
							<string>^(?:&lt; .* &gt; )?(.* )responds to your group with (.*)</string>
							<string>^(?:&lt; .* &gt; )?(\[[A-Z][a-z]+\]:? )(.*)</string>
							<string>^(?:&lt; .* &gt; )?(\[SYSTEM\] )(.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>SAYS</name>
						<script>-- ^(?:&lt; .* &gt; )?([A-Za-z]+ )says ('.*')$
-- ^(?:&lt; .* &gt; )?([A-Za-z]+ )projects ('.*')$
-- ^(?:&lt; .* &gt; )?(You )say ('.*')$
-- ^(?:&lt; .* &gt; )?(You )project ('.*')$

-- Oghma says with a melodious voice 'I can see it either way'
-- Dugmaren mutters in a surly voice 'ok'

-- says is not compacted

local whoMatch= getColourString( matches[2] )
-- local bodyMatch= getColourString( matches[3] )

if not chatCapture then
	chatCapture=true
	demonnic.chat:append("SAYS", whoMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ says '.*')$</string>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ projects '.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You say '.*')$</string>
							<string>^(?:&lt; .* &gt; )?(You project '.*')$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>AUCTION</name>
						<script>local whoMatch= getColourString( matches[2] )
local bodyMatch= getColourString( matches[3] )

-- Auction: a silvery war axe term ended with NO SALE
if not chatCapture then
	chatCapture=true
	
	-- Only capture body
	demonnic.chat:append("AUC", bodyMatch)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?(Auction: )(.*)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>end chat capture</name>
						<script>chatCapture=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(.*)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>SpellTracker</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have finished praying for</name>
					<script>local spellname = to_snake(matches[2])

charData:init("memcount", 1)

if charData:get("memcount") == 0 then
	charData:set("memcount", 1)
end

incSpellCount(spellname)

-- update spell button/ spells to memorize

if charData:get("memcount") &gt; 0 then
	charData:set("memcount", charData:get("memcount")-1 )
	MemButton("MemButton", buttons.UPDATE)
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have finished praying for ([A-Za-z ]+)[.]</string>
						<string>You have finished memorizing ([A-Za-z ]+)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Memorized Spells</name>
					<script>--               12 - Magic Missile

setSpellCount(to_snake(matches[3]), tonumber(matches[2]))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\( [0-9][snrt][dth] circle\) +([0-9]+) - ([A-Za-z ]+)$</string>
						<string>^\(10th circle\)  ([0-9]) - ([A-Za-z ]+)$</string>
						<string>^               ?([0-9]+) - ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>And you are currently praying for the following spells:</name>
					<script>-- enable counter

charData:set("memcount", 0)

spell:setMem(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>And you are currently praying for the following spells:</string>
						<string>You are currently memorizing the following spells:</string>
						<string>And you are currently memorizing the following spells:</string>
						<string>You are currently praying for the following spells:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>spells to memorize</name>
					<script>-- 146 seconds:  ( 3rd) Jar The Soul
--  89 seconds:  (10th) Ancestral Fury

if charData:get("memcount") == nil then
	charData:set("memcount", 0)
end

charData:set("memcount", charData:get("memcount")+1)
MemButton("MemButton", buttons.UPDATE)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^    [0-9] seconds:  \([1 ][0-9][snrt][tdh]\) ([A-Za-z ]+)$</string>
						<string>^   [0-9][0-9] seconds:  \([1 ][0-9][snrt][tdh]\) ([A-Za-z ]+)$</string>
						<string>^  [0-9][0-9 ][0-9] seconds:  \([1 ][0-9][snrt][tdh]\) ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your prayers are complete.</name>
					<script>-- finish mem

spell:setMem(false)

charData:set("memcount", 0)
MemButton("MemButton", buttons.UPDATE)

-- reset groupsend
--group:set(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your prayers are complete.$</string>
						<string>^Your studies are complete.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You can pray for no more spells.</name>
					<script>if prompt:get("position") == "sit" and charData:get("memcount") == 0 then
	mud:send("ST")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can pray for no more spells.</string>
						<string>You can memorize no more spells.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have memorized the following spells:</name>
					<script>charData:set("spells", {})</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have memorized the following spells:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A feeling of immense power flows through you.</name>
					<script>-- righteous might on</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A feeling of immense power flows through you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are praying for Dispel Magic, which will take about 4 seconds.</name>
					<script>if charData:get("memcount") == 0 then
	charData:set("memcount", 1)
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are praying for</string>
						<string>You are memorizing</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You start chanting...</name>
					<script>-- casting spell
local castspell=spell:getCurrent()

if castspell == nil then
	if command ~= "group" and command ~= "look" then
		spell:setCurrent(command)
		echoDebug("&lt;red&gt;[Setting spell.casting to " .. command .. "]")
		castspell=command
	else
		spell:setCurrent("unknown")
		echoDebug("&lt;red&gt;[Setting spell.casting to unknown command: " .. command .. "]")
		castspell="unknown"
	end
end

castspell=castspell:lower()

local displayname = to_english(powerAliases:toSpell(castspell))

cecho("&lt;red&gt; [Casting: &lt;yellow&gt;" .. castspell:upper() .. " &lt;green&gt;(" .. displayname .. ")&lt;red&gt;]")

-- Update local spellcount

local spellname= powerAliases:toSpell(castspell)

if spellname ~= nil then
	if matches[2] == "chanting" then
   		-- Spell is being successfully cast
			decSpellCount(spellname)
	elseif matches[2] == "memorized" or matches[2] == "available" then
   		-- Spell was not successfuly cast because because not memorized
			
			echoDebug("\n&lt;red&gt;[ Setting spell count for: " .. spellname .. " to 0 after 'Dont have that spell memorized message'.]" )
   		setSpellCount(spellname, 0)

		-- if that spell is currently queued clear it
		-- clear would need to be power alone (not target)

		--spell:clear(spellname)
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .*)?You start (chanting)...</string>
						<string>^You don't have that spell (memorized).*</string>
						<string>^You don't have any more spells (available) at that circle!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>spell completed - updated hp</name>
					<script>-- and hp to local database if heal spells cast

local spellname= spell:getCurrent()

charData:set("memcount", charData:get("memcount")+1)

if spellname ~= nil then
	spellname = spellname:lower()

	local displayname = to_english(powerAliases:toSpell(spellname))

	cecho("&lt;red&gt; [&lt;cyan&gt; " .. spellname:upper() .. " (" .. displayname .. ") &lt;red&gt;]")

	-- [Completed spell: dopple Bombum (Doppleganger) ]

	-- if spellname dopple add buff

	local dopplechar = string.match(spellname, "^dpl (.*)")

	if groupList:ingroup(dopplechar) then
		buff:set(dopplechar, "doppleganger", 1000)
	end

	-- if spellname ff or faerie fire mark as cast

	if string.find(spellname, "^ff") or string.find(spellname, "faerie fire") then
		spell:setCast("ff")
	end

	-- if spell cast was groupheal clear all blind
	if spellname == "gh" then
		for k,char in pairs(groupList:pc()) do
			buff:del(char, "blind")
			buff:del(char, "blindness")
		end

		-- is this sending abort?
		spell:clear("gh", true)
	end

	local realmchar = string.match(spellname, "^realm (.*)")

	if realmchar ~= nil then
		realmchar = string.title(realmchar)
	end

	if groupList:ingroup(realmchar) then
		buff:set(realmchar, "greater_realm_of_protecti", 45*60)
	end

	local cbchar = string.match(spellname, "^cb$")

	if cbchar then
		-- remove blind
		buff:del(whoami(), "blind")
		buff:del(whoami(), "blindness")
	end

	local cbchar = string.match(spellname, "^cb (.*)")

	if groupList:ingroup(cbchar) then
		-- remove blind
		buff:del(cbchar, "blind")
		buff:del(cbchar, "blindness")
	end

	local dpuchar = string.match(spellname, "^dpu (.*)")

	if dpuchar ~= nil then
		dpuchar = string.title(dpuchar)
	end

	if groupList:ingroup(dpuchar) then
		-- remove blind, para, poison flag on divine purify
		buff:del(dpuchar, "blind")
		buff:del(dpuchar, "blindness")
		buff:del(dpuchar, "minor_paralysis")
		buff:del(dpuchar, "major_paralysis")
	end

	local fhchar = string.match(spellname, "^fh (.*)")

	if fhchar ~= nil then
		fhchar = string.title(fhchar)
	end

	if groupList:ingroup(fhchar) then
		-- remove blind flag on fullheal
		buff:del(fhchar, "blind")
		buff:del(fhchar, "blindness")

		local hp=tonumber(groupList:getHP(fhchar))
		local maxhp= tonumber(groupList:getMaxHP(fhchar))

		if hp == nil or maxhp == nil then
			return
		end

		if hp &lt; maxhp then
			hp=hp+300

			if hp &gt; maxhp then
				hp=maxhp
			end

			groupList:setHP(fhchar, hp, maxhp)
		end
	end
else
	cecho(" &lt;red&gt;[&lt;green&gt;Completed spell: &lt;red&gt;unknown]" )
end

spell:setCurrent(nil)

-- reset groupsend
if group:get() == "GROUPSENT" then
	group:set(false)
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You complete your spell.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>failed spellcast</name>
					<script>-- You abort your prayer before it's done! if moving gsay
-- You are already affected by Greenfire!

if matches[2] == "are already affected by" then
	if spell:getCurrent() == nil then
		echoDebug("&lt;red&gt;[Failed spellcast, but current is nil]")
	else
		local castString = spell:getCurrent()

		failedSpell = castString

		echoDebug("\n&lt;red&gt;[ " .. castString .. " : Already affected by this spell ]" )

		-- send status on spell target: only works if grouped
		for k,v in pairs( string.split(castString, " ") ) do
			if k == 2 and (groupList:ingroup(v) or pet:getInRoom(v)) then
				sendStatus(v)
			end
		end
	end
end

spell:setMem(false)

if spell:getMoving() == false then
	spell:stop()
	spell:cast()
else
	spell:setCurrent(nil)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>They (are already affected by)</string>
						<string>You (are already affected by)</string>
						<string>You don't have that spell memorized.</string>
						<string>You don't see them here!</string>
						<string>You have to be standing up to do that!</string>
						<string>You abort your prayer before it's done!</string>
						<string>That power hasn't recharged yet!</string>
						<string>That spell cannot be cast for another</string>
						<string>You are stunned and unable to concentrate enough for that!</string>
						<string>You need their consent to do that.</string>
						<string>You abort your spell before it's done!</string>
						<string>Impossible! You can't concentrate enough!</string>
						<string>seems to be just a BIT out of reach.</string>
						<string>You don't see that item here.</string>
						<string>Standing would be a good first step.</string>
						<string>Nobody here by that name.</string>
						<string>You don't have any more spells available at that circle!</string>
						<string>Who should the spell be cast upon?</string>
						<string>You can't use this power on NPCs.</string>
						<string>You would pass right through them!</string>
						<string>That power would have no effect on them!</string>
						<string>You need to be able to speak to do that!</string>
						<string>You can't do that without solid ground underneath you!</string>
						<string>You are already maintaining that power!</string>
						<string>The magic gathers, then fades away.</string>
						<string>Nobody playing by that name.</string>
						<string>You can't see a thing, you're blinded!</string>
						<string>They have too much health to be affected by that.</string>
						<string>You can't teleport there.</string>
						<string>You must be in the same room as the group leader to do that.</string>
						<string>You can't do that underwater!</string>
						<string>You don't see that corpse here.</string>
						<string>No target for your power could be found!</string>
						<string>Pardon?</string>
						<string>You may not cast offensive spells on other players.</string>
						<string>You need to wield a bow to do that.</string>
						<string>You don't have any more spells available at that circle!</string>
						<string>You need to wield a melee weapon to do that.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You're busy spellcasting!</name>
					<script>if spell:getCurrent() ~= nil then
	echoDebug("&lt;red&gt;[Busy casting: " .. spell:getCurrent() .. "]")
else
	echoDebug("&lt;red&gt;[Unknown spell being cast]")
end

cecho("&lt;red&gt; [command: " .. command .. "]\n")

-- reset groupsend
group:set(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You're busy spellcasting! </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You complete your spell...</name>
					<script>-- sets to nil

--charData:set("memcount", 0)

if matches[2] == "You clamber to your feet." or matches[2] == "Your prayers are complete." then
	if checkMask("casterPsi") then
		MemButton("MemButton", buttons.INIT)
	end
end

if checkMask("singer") == false and not checkMask("powerCaster") then
	MemButton("MemButton", buttons.UPDATE)
end

if matches[2] == "That spell cannot be cast for another" then
	mud:send("RECHARGE")
end

look:set(nil)

spell:stop() -- set spell.casting=nil

-- only have priests send group command after casting
if checkMask("pray") then
	group:send()
end

look:send()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(You complete your spell...).*</string>
						<string>(You clamber to your feet.)</string>
						<string>(Your prayers are complete.)</string>
						<string>(You finish scribing spell)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>[A-Za-z]+ group-says 'moving.*</name>
					<script>-- reset variable
NyyLIB.escapedir = nil

spell:setMoving(true)

if checkMask("psi") then
	if getHide() then
		cecho("\n&lt;red&gt;[Not standing, currently hidden.]\n")
	else
		mud:send("ST")
	end
end

if checkMask("caster") or checkMask("nonPriestCaster") or checkMask("pray") then
	spell:clear()

	if getHide() then
		echo("\n[Not standing, currently hidden.]\n")
	else
		mud:send("ST")
	end
end

if mount:getMounted() then
	mud:send("dismount")
end

automem = 0

--expandAlias("@debug")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[A-Za-z]+ group-says? '(mov|mv|omv|dmov|mvo).*</string>
						<string>([A-Za-z]+) group-says? '(Adud|adud|tanks|tank) ([nsewud]).*'</string>
						<string>.* group-says? '\[Moving to: .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gsay memorize trigger</name>
					<script>if matches[2] == NyyLIB.leader or matches[2] == whoami() then
	sendFollowers()

	if checkMask("blk") then
		return
	end


	if checkMask("casterPsi") or checkMask("nonPriestCaster") then
	--if checkMask("casterPsi") then
		if not getHide() then
			if memsent == true then
				echo("\n")
			end

			mud:send("mem")
		end
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) group-says? 'mem.*</string>
						<string>([A-Za-z]+) group-says 'quick mem'</string>
						<string>([A-Za-z]+) group-says 'dmem.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You continue your study.</name>
					<script>setLabelImage("MemButton", "stand.png")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You continue your study.</string>
						<string>You continue your praying.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You abandon your studies.</name>
					<script>-- reset variable
NyyLIB.escapedir = nil

mud:send("st")

spell:setMem(false)

automem=0

MemButton("MemButton", buttons.INIT)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You abandon your studies.</string>
						<string>You abandon your prayers.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The world starts spinning, and your ears are ringing!</name>
					<script>-- stunned

sound("274736__sforsman__distort-ring-2.wav")

buff:set(whoami(), "stun", 2)
spell:clear()
sendStatus()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?The world starts spinning, and your ears are ringing!</string>
						<string>^(?:&lt; .* &gt; )?You are stunned and unable to concentrate enough for that!</string>
						<string>^(?:&lt; .* &gt; )?You are too stunned to do that!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You purge 'Healing Aura' spell from your thoughts.</name>
					<script>local spellname= to_snake(matches[2])

decSpellCount(spellname)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You purge '(.*)' spell from your thoughts.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You can't concentrate with all the racket!</name>
					<script>-- set as currently moving

-- You clamber to your feet. &lt;- Can't use, won't cast

spell:setMoving(true)
look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You can't concentrate with all the racket!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are already affected by that spell!</name>
					<script>sendStatus()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are already affected by</string>
						<string>Your form begins to</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are in a dead magic area and cannot cast spells!</name>
					<script>-- this room is !cast (either magically or beholder proc)

-- The magic gathers, then fades away.

nomagic = true

spell:clear()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are in a dead magic area and cannot cast spells!</string>
						<string>You need to be able to speak to do that!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You seem to have misplaced your spell book during memorization.</name>
					<script>-- disable autocast
buttons:change("autocast", false, "SpellsButton")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You seem to have misplaced your spell book during memorization.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You've created a devastating sandstorm!</name>
					<script>-- sandstorm - add 12 minute cooldown
timer:set("sandstorm", 12*60)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You've created a devastating sandstorm!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>recharge - sandstorm</name>
					<script>--  - Sandstorm in 5 minutes 45 seconds 1 pulse 
--  - Sandstorm in 2 minutes 2 seconds 2 pulses 

local timeleft

if matches[2] == "recharging" then
	timeleft=0
else
	if matches[3] == nil then
		timeleft = tonumber(matches[2])
	else
		timeleft = tonumber(matches[2])*60 + tonumber(matches[3])
	end
end

timer:set("sandstorm", timeleft)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Sandstorm in ([0-9]+) seconds .*</string>
						<string> - Sandstorm in ([0-9]) minutes ([0-9]+) seconds</string>
						<string>You do not have any powers (recharging).</string>
						<string> - Sandstorm in ([0-9]) minute ([0-9]+) seconds</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>ClassTriggers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bard</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are not composed enough to sing.</name>
						<script>tempTimer(3, playsong)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are not composed enough to sing.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You decide not to expend the mana required to keep your song.</name>
						<script>charData:set("_instrument", charData:get("instrument") )

charData:set("_song", charData:get("song") )

echoDebug("\n&lt;red&gt;[Previous song set: " .. charData:get("_song") .. "]" )

tempTimer(3, tr_renew)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You decide not to expend the mana required to keep your song.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Resume singing</name>
						<script>if checkMask("singer") then
	playsong()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world stops spinning.</string>
							<string>You are no longer attractive to pigeons.</string>
							<string>You feel able to speak again.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Heal vs Dragons</name>
						<script>-- if you get attacked by a dragon and aren't singing heal, switch to heal
if checkMask("singer") then
	if charData:get("song") ~= "song of healing" then
 		mud:send("ST")
 		mud:send("REM ravenous")
 		music( charData:get("lute"), "song of healing", "")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You reel backwards in pain as the massive tail smashes into you!</string>
							<string>breathes Fire!</string>
							<string>breathes a cone of frost!</string>
							<string>staggers in pain as the massive tail smashes into</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Songs</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of healing.</name>
							<script>if NyyLIB.active ~= "HealSong" then
	resetSongs()

	setLabelImage("HealSong", "barHeal-on.png")

	NyyLIB.active = "HealSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of healing.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of protection.</name>
							<script>if NyyLIB.active ~= "ProtectSong" then
	resetSongs()

	setLabelImage("ProtectSong", "protect-on.png")

	NyyLIB.active = "ProtectSong"
end

NyyLIB.songtimer=12
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of protection.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of renewal.</name>
							<script>if NyyLIB.active ~= "RenewSong" then
	resetSongs()

	setLabelImage("RenewSong", "renew-on.png")

	NyyLIB.active = "RenewSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of renewal.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of sorcery.</name>
							<script>NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of sorcery.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish a verse of the song of travel.</name>
							<script>if NyyLIB.active ~= "TravelSong" then
	resetSongs()

	setLabelImage("TravelSong", "travel-on.png")

	NyyLIB.active = "TravelSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish a verse of the song of travel.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You finish belting out a verse of the song of harming.</name>
							<script>if NyyLIB.active ~= "HarmSong" then
	resetSongs()

	setLabelImage("HarmSong", "barHarm-on.png")

	NyyLIB.active = "HarmSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You finish belting out a verse of the song of harming.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your bellowing blast deadens the reflexes of your foes.</name>
							<script>if NyyLIB.active ~= "SlowSong" then
	resetSongs()

	setLabelImage("SlowSong", "slow-on.png")

	NyyLIB.active = "SlowSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your bellowing blast deadens the reflexes of your foes.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your harmonious notes flood the room, inspiring your companions.</name>
							<script>NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your harmonious notes flood the room, inspiring your companions.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your quickening chant fills your cohort with awesome determination.</name>
							<script>if NyyLIB.active ~= "HasteSong" then
	resetSongs()

	setLabelImage("HasteSong", "barHaste-on.png")

	NyyLIB.active = "HasteSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your quickening chant fills your cohort with awesome determination.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your voice lifts the spirits of your companions.</name>
							<script>if NyyLIB.active ~= "RecoverySong" then
	resetSongs()

	--	setLabelImage("RecoverySong", "recover-on.png")

	-- label=findlabel("RecoverySong")
	-- label:setStyleSheet([[border-image: url(]] .. iconpath("recover-on.png") .. [[)]])

	NyyLIB.active = "RecoverySong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your voice lifts the spirits of your companions.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You complete another verse, of the song of regeneration.</name>
							<script>if NyyLIB.active ~= "RegenSong" then
	resetSongs()

	setLabelImage("RegenSong", "barRegen-on.png")

	NyyLIB.active = "RegenSong"
end

NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You complete another verse, of the song of regeneration.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Your solemn chant steadies your cohort with stalwart determination.</name>
							<script>NyyLIB.songtimer=12</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Your solemn chant steadies your cohort with stalwart determination.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body becomes more in tune with your mind!</name>
						<script>setLabelImage("barBless", "barBless-on.png")
buff:set(whoami(), "harmonious_blessing", 780) -- 30 seconds extra</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body becomes more in tune with your mind!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel less in tune with your body!</name>
						<script>setLabelImage("barBless", "barBless-off.png")
buff:del(whoami(), "harmonious_blessing")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel less in tune with your body!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your song has no affect here!</name>
						<script>mud:send("stopmusic")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your song has no affect here!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You begin singing.</name>
						<script>setLabelImage("StopMusic", "barStopMusic-timer.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You begin singing.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You stop your song.</name>
						<script>setLabelImage("StopMusic", "stopmusic.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You stop your song.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your spells have replenished.</name>
						<script>setSpellCount("harmonious_blessing", 3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your spells have replenished.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Determine char class level</name>
					<script>charData:set("level", tonumber(matches[2]))

followersSent=nil

sqlinwho(whoami())


for k, v in pairs(NyyLIB.fullclasslist) do
	if v[1] == matches[4]:trim()	 then
		if inwho(whoami()) == false then
			whoadd(whoami(), v[2], matches[3]:trim())
		else
			-- make sure katumi database is correct class
			if NyyLIB.WhoClass.wholist[whoami()] ~= nil then
				NyyLIB.WhoClass.wholist[whoami()][1] = v[2]
			end
		end

		if NyyLIB.initgui == false then
			initFullData()
		end

		checkVoteButton()

		return
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Level: ([0-9]+)[ ]+Race: ([A-Z a-z-]+)[ ]+Class: ([A-Za-z- ]*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Psi</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="yes">
						<name>wormhole: ASSOC</name>
						<script>-- ^([A-Za-z]+) ASSOC::? '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
	return
end

local sender = multimatches[2][2]
local target = multimatches[2][4]

if sender == "You" then 
	sender = whoami()
end

if checkMask("psi") then
	if not getHide() then
		if charData:get("wormhole") then
			eraseLine()
			noSound = true

			if target == "me" or target == "please" then
				mud:send("worm " .. sender)
			else
				mud:send("worm " .. target)
			end

			NyyLIB.psilag="wormhole"

			tempTimer(1.5, [[mud:send("mem")]])
	
			look:send()
		end
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#aa00ff</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#800080</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG12BG2</string>
							<string>^([A-Za-z]+) ASSOC::? '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="no">
						<name>wormhole: TELL</name>
						<script>-- ^([A-Za-z]+) tells you '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'

-- ^([A-Za-z]+) ASSOC::? '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
	return
end


local sender = multimatches[2][2]
local target = multimatches[2][4]

if sender == "You" then 
	sender = whoami()
end

if charData:get("disableworm") then
	if checkMask("psi") then
		-- mud:send("t " .. sender .. " " .. string.title(sender) .. ", lack of voting on TMC (http://www.mudconnect.com/cgi-bin/vote_rank.cgi?mud=TorilMud,+the+Sojourner%27s+Home) has disabled this trigger. 30+ people are online free daily, but not willing to vote.")
		mud:send("t " .. sender .. " " .. string.title(sender) .. ", enabling this trigger requires contributing new or re-written helpfiles.")
		return
	end
end

if checkMask("psi") then
	if not getHide() then
		if charData:get("wormhole") then
			eraseLine()
			noSound = true

			if target == "me" or target == "please" then
				mud:send("worm " .. sender)
			else
				mud:send("worm " .. target)
			end

			NyyLIB.psilag="wormhole"

			tempTimer(1.5, [[mud:send("mem")]])
	
			look:send()
		end
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#ffffff</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG15BG0</string>
							<string>^([A-Za-z]+) tells you '(worm|well|hole|wormhole|hol) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="no">
						<name>rift: ASSOC</name>
						<script>-- ^([A-Za-z]+) tells you '(rift|gate) ([A-Za-z]+)( .*)?'

-- ^([A-Za-z]+) ASSOC::? '(rift|gate) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
	return
end


local sender = multimatches[2][2]
local target = multimatches[2][4]

if not getHide() then
	if charData:get("wormhole") then
		eraseLine()
		noSound = true

		mud:send("rift " .. target)
		NyyLIB.psilag="rift"

		tempTimer(1.5, [[mud:send("mem")]])

		look:send()
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#800080</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG12BG0</string>
							<string>^([A-Za-z]+) ASSOC::? '(rift|gate) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="no">
						<name>rift: TELL</name>
						<script>-- ^([A-Za-z]+) tells you '(rift|gate) ([A-Za-z]+)( .*)?'

-- fugue
if map:getRoom() == 93848 then
	return
end


local sender = multimatches[2][2]
local target = multimatches[2][4]

if charData:get("disableworm") then
	if checkMask("psi") then
		--mud:send("t " .. sender .. " " .. string.title(sender) .. ", lack of voting on TMC (http://www.mudconnect.com/cgi-bin/vote_rank.cgi?mud=TorilMud,+the+Sojourner%27s+Home) has disabled this trigger. 30+ people are online free daily, but not willing to vote.")
		mud:send("t " .. sender .. " " .. string.title(sender) .. ", enabling this trigger requires contributing new or re-written helpfiles.")
		return
	end
end

if not getHide() then
	if charData:get("wormhole") then
		eraseLine()
		noSound = true

		mud:send("rift " .. target)
		NyyLIB.psilag="rift"

		tempTimer(1.5, [[mud:send("mem")]])

		look:send()
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#ffffff</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>FG15BG0</string>
							<string>^([A-Za-z]+) tells you '(rift|gate) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your ultrablast hits [A-Za-z0-9]+ target[s.]+</name>
						<script>charData:set("ultraquested", true)
NyyLIB.psilag="ultra"
look:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your ultrablast hits [A-Za-z0-9]+ target[s.]+</string>
							<string>You feel a field of lethal energy start expanding outward.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exits: .*</name>
						<script>if NyyLIB.psilag == "ultra" then
	if setLabelImage("ultrablast", "ultrablast-off.png") == nil then
		addbutton("ultrablast", 0, 2, 47)
	end
end

if NyyLIB.psilag == "death" then
	if setLabelImage("deathfield", "deathfield-off.png")	== nil then
		addbutton("deathfield", 0, 2, 20)
	end
end 

NyyLIB.psilag = "none"</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Exits: .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You envelop your mind in a protective tower.</name>
						<script>if charData:get("autotower") then
	setBackgroundColor("tower", 0,0,150,255)
end

NyyLIB.tower = 1
look:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You envelop your mind in a protective tower.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel more vulnerable to psionic attack.</name>
						<script>NyyLIB.tower=0

if charData:get("autotower") then
	mud:send("tower me", false)
	setBackgroundColor("tower",32,32,32,255)
	NyyLIB.psilag="tower"
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel more vulnerable to psionic attack.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>becomes more alert, evaluating possible targets.</name>
						<script>local xchar = matches[2]
local nx

if groupList:ingroup(xchar) then
	buff:set(xchar, "combatmind", 600)
	look:send()
end

for k,char in pairs(groupList:pc("hitterSinger")) do
	if not buff:get("combatmind", char) then
		return
	end
end

setBackgroundColor("combatmind", 0,0,150,255)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Z][a-z]+) becomes more alert, evaluating possible targets.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Drawing darkness itself around you,</name>
						<script>setHide(true)
look:send()
sendStatus()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Drawing darkness itself around you,</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>projection improves your fighting ability.</name>
						<script>-- batletrance on
setBackgroundColor("battletrance", 0,0,150,255)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>projection improves your fighting ability.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel a little confused as your augmented knowledge of battle tactics fades.</name>
						<script>-- battletrance off
setBackgroundColor("battletrance",32,32,32,255)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel a little confused as your augmented knowledge of battle tactics fades.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>[A-Za-z]+ group-says 'tower'</name>
						<script>if not getHide() then
	mud:send("tower me")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>[A-Za-z]+ group-says 'tower'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>group-says 'hole|worm ([A-Za-z])''</name>
						<script>--Pidibeple group-says 'hole wd so i can get back to group plz'--
--[  LUA  ] - object:&lt; group-says 'hole|worm ([A-Za-z])''&gt; function:&lt;Trigger95&gt;
--            &lt;[string "Trigger:  group-says 'hole|worm ([A-Za-z])'..."]:6: attempt to concatenate field '?' (a nil value)&gt;

local target=matches[4]

if checkMask("psi") then
	if getHide() then
		echo("[Not worming, currently hidden.]\n")
	else
		if target == "me" or target == "please" then
			target = matches[2]
		end
		
		mud:send("worm " .. target)
	
		NyyLIB.psilag="wormhole"

		tempTimer(1.5, [[mud:send("mem")]])
	
		look:send()
	end
end

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '(hole|worm) ([A-Za-z]+)( .*)?'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The air in the immediate area darkens abruptly as a result of your projection!</name>
						<script>NyyLIB.psilag="death"
look:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The air in the immediate area darkens abruptly as a result of your projection!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You start meditating...</name>
						<script>spell:setMem(true)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You start meditating...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You stop meditating.</name>
						<script>spell:setMem(false)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You stop meditating.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body grows taller as you complete your projection.</name>
						<script>if whosize() == "L" then
	charData:set("bodysize", "H")
elseif whosize() == "M" then
	charData:set("bodysize", "L")
elseif whosize() == "S" then
	charData:set("bodysize", "M")
end

setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body grows taller as you complete your projection.</string>
							<string>Your body grows to gigantic heights!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You flee (.*)ward!</name>
						<script>if NyyLIB.escapedir ~= nil then
	-- send reverse

	if NyyLIB.escapedir ~= matches[2] then
		expandAlias(NyyLIB.reversedirs[matches[2]], false)
		expandAlias(NyyLIB.escapedir, false)
	end

	NyyLIB.escapedir = nil

end

if charData:get("autohide") then
	if checkMask("psi") then
		mud:send("darkness")
	end

	if checkMask("rog") or checkMask("ran") then
		mud:send("hide")
		mud:send("save")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You flee ([nsewud]).*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You focus your mind and force your body to return to its natural size.</name>
						<script>charData:set("bodysize", whosize())

setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")

if table.contains( {"psi", "Enc" }, whoclass() ) then
	-- size change, no echo needed
else
	mud:send("gsay [[ SPELLOUT - NOW SIZE=" .. charData:get("bodysize") .. "]]")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You focus your mind and force your body to return to its natural size.</string>
							<string>Your body size returns to normal.</string>
							<string>Your body returns to its normal size.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body shrinks substantially as you complete your projection.</name>
						<script>if whosize() == "L" then
	charData:set("bodysize", "M")
elseif whosize() == "M" then
	charData:set("bodysize", "S")
elseif whosize() == "S" then
	charData:set("bodysize", "T")
end

setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body shrinks substantially as you complete your projection.</string>
							<string>Your body shrinks substantially.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>War</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>EC: ([A-Za-z ]+) EP: (std|sit|rcl) P: (std)</name>
						<script>-- Being the ferocious sort, you charge at the enemy!

-- trip (rogue)

-- EC: ([A-Za-z ]+) EP: (std|sit|rcl) P: (std|sit|rcl)

if checkMask("rog") then
	if charData:get("autotrip") then
		if matches[3] == "std" then
			sendTrip()			
		end
	end
end

-- bash (fighter)

if checkMask("fighter") == false then
	return
end

if NyyLIB.escapedir ~= nil then
	return
end

if matches[3] == "std" then
	if canBash() then
		sendBash()
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>EC: ([A-Za-z ]+) EP: (std|sit|rcl) P: (std|sit|rcl)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Bash</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Elaith Waterstill clambers to his feet.</name>
							<script>if not inCombat() then
	return
end

if checkMask("rog") then
	if groupList:ingroup(matches[2]) == false and whoclass(matches[2]) == nil then
		if charData:get("autotrip") then
			sendTrip()			
		end
	end
end

if checkMask("fighter") == false then
	return
end

-- castOK intercepts if casting (example, paladin), escape attempt set, etc

if not spell:castOK() then
	return
end

if groupList:ingroup(matches[2]) == false and whoclass(matches[2]) == nil then
	if canBash() then
		sendBash()
	end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(.*) clambers to .*</string>
								<string>^(.*) rises to (his|her|its) feet.$</string>
								<string>(.*) staggers about, but manages to get to (his|her) feet.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>failed rescues or bashes</name>
							<script>meleePowerUsed=false

setBashing(false)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>Sorry, you can't do that while lying around.</string>
								<string>you topple over and fall to the ground.</string>
								<string>You haven't reoriented yourself yet enough for another bash!</string>
								<string>Maybe you should get on your feet first?</string>
								<string>nimbly avoids your powerful shield bash!</string>
								<string>You are too stunned to do that!</string>
								<string>Your mount misses</string>
								<string>You have to be mounted to do that!</string>
								<string>Your mount refuses to trample!</string>
								<string>nimbly avoids your powerful shield bash!</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>You assist a dapper noble heroically.</name>
							<script>-- assisting someone
setBashing(false)
setTripping(false)

spell:setMem(false)

meleePowerUsed=false

-- rogue: circle
if charData:get("autocircle") then
	expandAlias("cr", false)
end
</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>You assist (.*) heroically.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>KegorRescue</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>visible fighting</name>
							<script>-- Bafog dodges an ice troll's attack.

-- A burly bouncer deflects Aliha's blow, and strikes back at Aliha!
-- A burly bouncer severely wounds Aliha with his massive bludgeon.

-- TODO if prior line = deflect, return

--A disgusting slithering vine badly wounds the ghost of a shambling mound with its powerful bite.
--A disgusting slithering vine shivers from the cold, as it hits the ghost of a shambling mound.
--A disgusting slithering vine badly wounds the ghost of a shambling mound with its powerful bite.
--A disgusting slithering vine shivers from the cold, as it hits the ghost of a shambling mound.


-- Text that should be skipped: 

-- A massive fireball erupts from an enormous golden chest and hits Lilabipple!
-- A skeletal archer's carefully aimed shot from the north hits Lalira.
-- Rekpezul touches Jibbi. Interesting.
-- An alert kobold archer's carefully aimed shot  hits Turilenil.

-- lua display( string.find( "Rekpezul touches Jibbi. Interesting.", "Interesting") )

if string.find(matches[1], "Interesting") then
	display("X")
	return
end

if string.find(matches[1], "A massive fireball erupts from") then
	return
end

if string.find(matches[1], "carefully aimed shot") then
	return
end


local torescue=matches[3]

if NyyLIB == nil then
	return
end

-- If last command entered was "l " or scan, return

if string.find(command, "L ") == 1 or command == "SCAN" then
	return
end


if charData:get(whoami(), true) == nil then
	return
end

-- this is warrior rescue triggers only
if checkMask("fighter") == false then
	return
end

if NyyLIB.escapedir ~= nil then
	return
end

if torescue == whoami() then
	return
end

-- Don't rescue if less then 25% max hp
if prompt:get("hp") &lt; (.25 * prompt:get("maxhp")) then
	return
end

if string.find(previousLine(), "deflects") then
	echoDebug("deflect detected\n")
	return
end


-- rescue wuss

if torescue == charData:get("wuss") then
	sendRescue(torescue)
	return
end


-- autorescue code


if charData:get("rescuetype") ~= "off" then
	if groupList:ingroup(torescue) then
		if checkMask("warrior", torescue) and charData:get("rescuetype") == "basic" then
			return
		end

		-- if ranger don't rescue rangers
		
		if checkMask("ran") and checkMask("ran", torescue) then
			return
		end
		
		-- 25% chance of rescuing rangers
		
		if checkMask("ran", torescue) and ((math.random() * 100) &gt; 25) then
		--if checkMask("ran", torescue) then	
			return
		end
		
		sendRescue(torescue)
	end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>.*(,\sfighting|wounds|knocks|misses|a\smirror\simage\sof|tried\sto\sbackstab|tries\sto\srescue|attacks|beat|beats|choke|chokes|touch|touches|hit|hits|slash|slashes|crush|crushes|whip|whips|pierce|pierces|smash|smashes|sting|stings|drain|drains|strike|strikes|pummel|pummels|pound|pounds|claw|claws|nip|nips|burn|burns|bite|bites) ([A-Za-z]+)</string>
								<string>in (the back) of ([A-Za-z]+), resulting in some strange noises</string>
								<string>(.*) sends ([A-Za-z]+) sprawling with a powerful bash.</string>
								<string>(&lt; ).* T: ([A-Za-z]+) TC: .* E: .* EC: .* EP: .* P: .* &gt; </string>
								<string>^([A-Za-z]+) futilely tries to rescue (.*)[.]</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>rescue messages</name>
							<script>-- if this line arrives same line as prompt, it double fires a rescue

rescueSent=false
look:send()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>But nobody is fighting him?</string>
								<string>You fail the rescue.</string>
								<string>Banzai! To the rescue...</string>
								<string>You don't see them here!</string>
								<string>But nobody is fighting her?</string>
								<string>Who do you want to rescue?</string>
								<string>Sorry, you can't do that while lying around.</string>
								<string>But nobody is fighting it?</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Rescue tank</name>
						<script>local tank=prompt:get("tank")
local tankcondition= prompt:get("tankcondition")
local hp=prompt:get("hp")
local maxhp=prompt:get("maxhp")

if tank == whoami() then
	return
end

if hp == nil then
	return
end

if hp &lt; (.40 * maxhp ) then
	return
end

if checkMask("fighter") == false then
	return
end

if NyyLIB.escapedir ~= nil then
	return
end

if charData:get("rescuetype") == "all" then
	-- display(tank)
	sendRescue(tank)
	return
end

if (charData:get("rescuetype") == "basic" or charData:get("rescuetype") == "all") then
	if tank == "ghost" then
		sendRescue(tank)
		return
	end

	if table.contains( {"awful", "pretty hurt"}, tankcondition ) then
		sendRescue(tank)	
		return
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>&lt; .* T: ([A-Za-z]+) TC: ([A-Za-z ]+) .*&gt; </string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You make a great effort, and send a training dummy's weapon crashing to the floor.</name>
						<script>mud:send("get all")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You make a great effort, and send .* weapon crashing to the floor.</string>
							<string>You have managed to get FAR TOO CLOSE to .*</string>
							<string>.* steps directly in front of your path.  No way to get it now.</string>
							<string>.* hurtles itself into close vicinity of the .*  Impossible to get to now!</string>
							<string>You fail miserably in your attempt to disarm .*</string>
							<string>Impossible to get to now!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Autotank</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Lilithelle group-says 'tanks ([nsewud])'</name>
							<script>-- tnaks

-- this trigger can only be used by group leader
if matches[2] ~= NyyLIB.leader then
	return
end

if checkMask("necros") and matches[3] == "spectre" then
	mud:send("ORDER spectre " .. matches[4])
end

if checkMask("fighter") == false then
	return
end

if ( matches[3] == "Adud" or matches[3] == "adud" ) and whoami() ~= "Adud" then
	return
end

if charData:get("autotank") then
	-- If less then 75% hp and less then 900hp, grep and don't move
	if prompt:get("hp") &lt; .75 * prompt:get("maxhp") and prompt:get("hp") &lt; 900 then
		mud:send("tackle " .. matches[2])
		mud:send("grep")
		return
	end

	if matches[4] == "en" then
		mud:send("enter " .. matches[5])
	else
		mud:send(matches[4])
	end
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Za-z]+) group-says '(Adud|adud|tank|tanks|tnkas|dtnaks|tnaks) ([nsewud])( .*)?'</string>
								<string>^([A-Za-z]+) group-says '(Adud|adud|tank|tanks) (north|south|east|west|up|down)'</string>
								<string>^([A-Za-z]+) group-says '(Adud|adud|tank|tanks) (en) (.*)'</string>
								<string>^([A-Za-z]+) group-says '(spectre) ([nsewud])( .*)?'</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wall of rotting flesh and carrion plows through the corridor.</name>
						<script>if whoami() == "Adud" then
	sendBash("wall")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wall of rotting flesh and carrion plows through the corridor.</string>
							<string>A living wall stands here</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You get a rune graven adamantine longsword.</name>
						<script>mud:send("wield graven")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You get a rune graven adamantine longsword.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>powers</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>warriors ultimatum</name>
							<script>-- You face Corland Deepforge and beckon him towards you with a terrifying roar.

timer:set("warriors_ultimatum", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You face .* and beckon .* towards you with a terrifying roar.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>shield bash</name>
							<script>-- You slam your shield into a lithe commoner with tremendous force, knocking her to the ground!
-- You savagely bash a graceful commoner over the head with your shield, and his lifeless form crumples.
-- You strike Seipora Rein a glancing blow with your shield, and she maintains her balance.

meleePowerUsed=false

setBashing(false)

timer:set("shield_bash", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You slam your shield into .*</string>
								<string>^(?:&lt; .* &gt; )?You savagely bash .* over the head with your shield, and .* lifeless form crumples.$</string>
								<string>^(?:&lt; .* &gt; )?You strike .* a glancing blow with your shield, and .* maintains .* balance[.]$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>defensive strike</name>
							<script>-- You drop into a defensive posture and raise your shield as you land a strike on a lithe commoner.
-- You pivot into a defensive posture after mercilessly finishing off Elaith Waterstill.

meleePowerUsed=false

-- timer is one more then duration because there is an expiry message
timer:set("defensive_strike", 13)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You drop into a defensive posture and raise your shield as you land a strike on .*</string>
								<string>^(?:&lt; .* &gt; )?Your defensive posture is thrown off balance as your blow merely glances off of .*</string>
								<string>^(?:&lt; .* &gt; )?You pivot into a defensive posture after mercilessly finishing off .*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>brutal strike</name>
							<script>-- You lunge forward and crack a graceful commoner a brutal blow upside the head with your weapon.
-- Aratha Sul sidesteps your lunge, and your blow glances off of her.
-- You lunge and deliver a devastating final blow to a robin's head with a sickening crack.

meleePowerUsed=false

timer:set("brutal_strike", 36)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You lunge forward and crack .* a brutal blow upside the head with your weapon.</string>
								<string>sidesteps your lunge, and your blow glances off of</string>
								<string>^(?:&lt; .* &gt; )?You lunge and deliver a devastating final blow to .* head with a sickening crack.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>0</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>comeback strike</name>
							<script>-- You feel invigorated as you land a powerful strike upon a lithe commoner.
-- You are flooded with a wave of strength as you cut Ersenas down ruthlessly.

meleePowerUsed=false

timer:set("comeback_strike", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You feel invigorated as you land a powerful strike upon .*</string>
								<string>^(?:&lt; .* &gt; )?Your powerful strike merely glances off of .*</string>
								<string>^(?:&lt; .* &gt; )?You are flooded with a wave of strength as you cut .*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>relentless assault</name>
							<script>-- You set your shield with grim determination and strike out at nearby foes.

meleePowerUsed=false

timer:set("relentless_assault", 36)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You set your shield with grim determination and strike out at nearby foes.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>spinning sweep</name>
							<script>-- You spin beneath a graceful commoner's guard and strike out with a precise attack.

meleePowerUsed=false

setBashing(false)

timer:set("spinning_sweep", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You spin beneath .* guard and strike out with a precise attack.</string>
								<string>^(?:&lt; .* &gt; )?You spin beneath .* guard and deliver a punishing, mortal blow.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>cleave</name>
							<script>-- You bring your weapon to bear and strike out in a deadly arc.

meleePowerUsed=false

timer:set("cleave", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You bring your weapon to bear and strike out in a deadly arc.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>unyielding avalanche</name>
							<script>-- You crash forward into your foes and strike out with a barrage of attacks.

meleePowerUsed=false

timer:set("unyielding_avalanche", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You crash forward into your foes and strike out with a barrage of attacks.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>skullcrush</name>
							<script>-- A dapper noble's skull is pulverized as you deliver a tremendous overhead blow to his head.
-- You raise your weapon high and bring it crashing down on Willa O'Greensleeves's head with a sickening crack.
-- You deliver a powerful overhead blow that merely glances off of Lavis Ryl.
-- You raise your weapon high and bring it crashing down on a spectral hound's head with a sickening crack.

meleePowerUsed=false

timer:set("skullcrush", 24)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>.* skull is pulverized as you deliver a tremendous overhead blow to.* head.$</string>
								<string>^(?:&lt; .* &gt; )?You raise your weapon high and bring it crashing down on .* head with a sickening crack.</string>
								<string>You deliver a powerful overhead blow that merely glances off of</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
								<integer>1</integer>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>rain of steel</name>
							<script>-- You weave through your foes, your weapon flashing as you strike through their ranks.

meleePowerUsed=false

timer:set("rain_of_steel", 12)
setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You weave through your foes, your weapon flashing as you strike through their ranks.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>iron warrior</name>
							<script>-- You feel a wave of vigor flooding through you as you stand fast against your foes.

buff:set(whoami(), "iron_warrior", 60)
timer:set("iron_warrior", 7*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You feel a wave of vigor flooding through you as you stand fast against your foes.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>diamond shield defense</name>
							<script>-- You channel your indomitable will into an impenetrable active defense.

buff:set(whoami(), "diamond_shield_defense", 60)
timer:set("diamond_shield_defense", 60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You channel your indomitable will into an impenetrable active defense.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>unbreakable</name>
							<script>-- You adjust your defensive stance and steel yourself for incoming attacks.

buff:set(whoami(), "unbreakable", 60)
timer:set("unbreakable", 3*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You adjust your defensive stance and steel yourself for incoming attacks.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>no opening</name>
							<script>-- You take a step back and move to block an opening in your defenses.

</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You take a step back and move to block an opening in your defenses.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>storm of destruction</name>
							<script>-- You become a whirling cyclone of terror as you spin your weapon about and charge your enemies.

meleePowerUsed=false

timer:set("storm_of_destruction", 7*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You become a whirling cyclone of terror as you spin your weapon about and charge your enemies.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>unstoppable</name>
							<script>-- You grit your teeth and ignore some of your wounds as your adrenaline surges.

timer:set("unstoppable", 5*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You grit your teeth and ignore some of your wounds as your adrenaline surges.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>combat challenge</name>
							<script>-- You hoist your weapon in the air and flash it menacingly at Willa O'Greensleeves.
-- You hoist your weapon in the air and flash it menacingly at a flaming chasme.

meleePowerUsed=false

buff:set(whoami(), "combat_challenge", 20)
timer:set("combat_challenge", 60)

setMeleeCooldown()</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You hoist your weapon in the air and flash it menacingly at .*[.]</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>heroic defiance</name>
							<script>-- You shake off your adverse conditions in a burst of willpower.

timer:set("heroic_defiance", 5*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You shake off your adverse conditions in a burst of willpower.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>defensive strike (drop)</name>
							<script>-- With aching muscles, you relax your defensive posture.

timer:set("defensive_strike", 0)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?With aching muscles, you relax your defensive posture.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>vigilant protector</name>
							<script>-- You move close to Padi and stand ready to defend her.

buff:set(whoami(), "vigilant_protector", 60*60)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You move close to .* and stand ready to defend.*[.]$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>vigilant protector (off)</name>
							<script>-- You relax your vigilant defense.

buff:set(whoami(), "vigilant_protector", 0)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^(?:&lt; .* &gt; )?You relax your vigilant defense.$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>0</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Enc</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lic</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stephan recoils in fear from the sudden assault of baleful sound.</name>
						<script>-- banshee wail took effect</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>recoils in fear from the sudden assault of baleful sound.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A black aura surrounds A burly bouncer briefly, then dissipates.</name>
						<script>-- blackmantle</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A black aura surrounds .* briefly, then dissipates.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your contagion wave washes over A naked woman, causing her to sag feebly.</name>
						<script>-- contagion</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your contagion wave washes over</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>banshee wail</name>
						<script>-- banshee wail has been cast in room
spell:setCast("bw")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The area reverberates with the shrieks and wails of lost souls!</string>
							<string>Shrieking and wailing erupts all around you!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel powers of darkness strengthen you!</name>
						<script>group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel powers of darkness strengthen you!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Cle</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>HA countdown timer</name>
						<script>-- cast healing aura if cleric and @mtank set (countdown timer)

-- mark as ha when heal proc happens

spell:setMoving(false)

NyyLIB.mtank=matches[2]

if checkMask("Cle") then
	--if charData:get("autoheal") then
		if spell:getMem() then
			mud:send("ST")
		end

		--spell:cast("ha " .. NyyLIB.mtank)
	--end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '&lt;4&gt;'</string>
							<string>([A-Za-z]+) group-says ''-=4=-'</string>
							<string>([A-Za-z]+) group-says 'Killing dragon in:'</string>
							<string>([A-Za-z]+) group-says '-5'</string>
							<string>([A-Za-z]+) group-says '5!'</string>
							<string>([A-Za-z]+) group-says '5'</string>
							<string>([A-Za-z]+) group-says 'Going in: 5'</string>
							<string>([A-Za-z]+) group-says 'going in 5'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Autoquake triggers</name>
						<script>-- Flag earthquake to be cast

-- The ghost of Talrinim stands in mid-air here, fighting Brammithizzar."set quake"
-- true

-- A Cult of the Dragon sorcerer is lying here, fighting Afu.


if not checkMask("priest") or not charData:get("autoquake") then
	return
end

-- last command entered was look direction or scan - return
if string.find(command, "l ") == 1 or string.find(command, "look ") == 1 or command == "SCAN" then
	return
end

setQuake(true)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^A frost giant jarl stands.*, fighting</string>
							<string>^A member of the Smoking Beard battalion stands.*, fighting</string>
							<string>^A fire giant captain stands.*, fighting</string>
							<string>^A sandman stands.*, fighting</string>
							<string>^A frost giant spirit-seeker stands.*, fighting</string>
							<string>^A vine of thorns stands.*, fighting</string>
							<string>^A hideous choker stands.*, fighting</string>
							<string>^Talrinim stands.*, fighting</string>
							<string>^A living wall stands.*, fighting</string>
							<string>^A minion of Moander stands.*, fighting</string>
							<string>^Goortok stands.*, fighting</string>
							<string>^A carnivorous vine stands.*, fighting</string>
							<string>^Thrym stands.*, fighting</string>
							<string>A tower apprentice stands.*, fighting</string>
							<string>A busy clerk stands.*, fighting</string>
							<string>Yamel Rerraser stands.*, fighting</string>
							<string>^Granak .* here, fighting .*</string>
							<string>The Tarrasque stands here, fighting</string>
							<string>Blintim Trilamir stands here, fighting</string>
							<string>A Spellguard apprentice stands in mid-air here, fighting</string>
							<string>An ancient guardian stands in mid-air here, fighting</string>
							<string>A toad demon stands in mid-air here, fighting</string>
							<string>^A .*(witch|mage|warlock|druid|shaman|cleric|priest|priestess|invoker|oracle|seer|hierophant|wizard|sorcerer|necromancer) .*, fighting .*</string>
							<string>A member of the Smoking Beard battalion flies in from</string>
							<string>A galeb duhr stands, inches above the surface here, fighting</string>
							<string>The djinn vizier stands in mid-air here, fighting</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Healing aura on lich</name>
						<script>-- healing aura after lich proc

-- mark char as liched for when heal proc happens

if getSpellCount("healing_aura") &gt; 0 then
	if not buff:get("healing_aura", matches[2]) then
		spell:setNext("ha " .. matches[2])
	end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* literally sucks the life force from ([A-Za-z]+), who crumples into a ball of lifeless </string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Remove poison on venom</name>
						<script>-- venom

-- mark char as venomed for heal proc

local charname = matches[2]

if not checkMask("priest") then
	return
end

if getSpellCount("remove_poison") &gt; 0 then
	sendStatus(charname)
	spell:setNext("rp " .. charname)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) writhes in agony.</string>
							<string>([A-Za-z]+) shudders in pain, and looks very pale.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>^([A-Za-z]+) tells you 'para'</name>
						<script>sendStatus(matches[2])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^([A-Za-z]+) tells you 'para'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Sha</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Rog</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You use the last of the poison.</name>
						<script>mud:send( "GET blind " .. charData:get("poisonbag"))</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You use the last of the poison.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You can't seem to find that!</name>
						<script>mud:send("get slow hole")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can't seem to find that!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your assassination attempt goes wide of the mark.</name>
						<script>-- You may only attempt to assassinate someone once a day!

timer:set("assassinatetimer", 24*60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your assassination attempt goes wide of the mark.</string>
							<string>With practiced ease and lightning reflexes,</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You attempt to hide yourself.</name>
						<script>sendStatus()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You attempt to hide yourself.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You clamber to your feet.</name>
						<script>setTripping(false)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You clamber to your feet.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>assassinate in cooldown</name>
						<script>-- You may only attempt to assassinate someone once a day!

-- unknown cooldown, setting to 5 minutes

timer:set("assassinatetimer", 5*60)

-- train portion: backstab if unable to assassinate

if NyyLIB.traintarget then
		mud:send("bs " .. getEnemy() )
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You may only attempt to assassinate someone once a day!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>wraithform mobs</name>
						<script>timer:set("wraithform", 30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You would pass right through them!</string>
							<string>You try to trip .*, only to sprawl completely THROUGH it.</string>
							<string>You can't backstab something which is immaterial!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>set notrip</name>
						<script>-- Such a maneuver appears to be useless against the fire drake!
-- Such a maneuver appears to be useless against Quturac, the skeletal death dragon!

timer:set("notrip", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Such a maneuver appears to be useless against</string>
							<string>You have no footing here!</string>
							<string>is too huge for you to trip! You go crashing to the ground.</string>
							<string>Tripping creatures of this minute size is hopeless at best.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ill</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The illusion covering your group is shattered!</name>
						<script>-- The illusion over Lilabipple's group is shattered!
-- The illusion covering your group is shattered!

mud:send("gsay Massmorph DOWN!")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?The illusion over .* group is shattered!</string>
							<string>^(?:&lt; .* &gt; )?The illusion covering your group is shattered!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>An Ashstone noble's outline is illuminated by brilliant scarlet flames!</name>
						<script>-- sct scarlet outline</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>An Ashstone noble's outline is illuminated by brilliant scarlet flames!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You create a swirling rainbow pattern in front of an Ashstone noble, who seems distracted...</name>
						<script>-- rainbow pattern</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You create a swirling rainbow pattern in front of an Ashstone noble, who seems distracted...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ele</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ran</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>eviscerate</name>
						<script>-- Eviscerate
-- You swing your weapons in lethal arcs, dousing the area with a lithe commoner's blood.

meleePowerUsed=false

timer:set("eviscerate", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You swing your weapons in lethal arcs, dousing the area .*</string>
							<string>^(?:&lt; .* &gt; )?You swing your weapons in a killing arc, eviscerating .*</string>
							<string>^(?:&lt; .* &gt; )?Your arcing weapons glance off of .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>twin strike</name>
						<script>-- Twin Strike
-- You attack a lithe commoner with both weapons and land twin precision strikes.
-- You strike at Seipora Rein with both weapons, landing glancing blows.
-- You attack a giant fire elemental with both weapons, landing twin precision strikes.
-- You strike a robin down with a barrage of blows from both weapons.

meleePowerUsed=false

timer:set("twin_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You attack .* with both weapons, landing glancing blows.</string>
							<string>^(?:&lt; .* &gt; )?You attack .* with both weapons, landing twin precision strikes.</string>
							<string>^(?:&lt; .* &gt; )?You strike at .* with both weapons, landing glancing blows.</string>
							<string>^(?:&lt; .* &gt; )?You attack .*l with both weapons, landing twin precision strikes.</string>
							<string>^(?:&lt; .* &gt; )?You strike .* down with a barrage of blows from both weapons.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor splinter</name>
						<script>-- Armor Splinter
-- You strike the weak spots in A naked woman's armor, leaving her vulnerable.
-- You strike the weak spots in a freshly animated wight's armor, leaving it vulnerable.

meleePowerUsed=false

timer:set("armor_splinter", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You strike the weak spots in .*</string>
							<string>collapses in agony as you penetrate the weakest spot</string>
							<string>armor resists the impact of your carefully aimed strikes.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>bladestorm</name>
						<script>-- Bladestorm
-- You spin and leap through the fray, unleashing a torrent of steel on your enemies!

meleePowerUsed=false


timer:set("bladestorm", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You spin and leap through the fray, unleashing a torrent of steel on your enemies!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>failed power</name>
						<script>meleePowerUsed=false

if checkMask("ran") then
	procPromptRan()
end

if checkMask("pal") then
	procPromptPal()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?They have to be standing up for you to do that!</string>
							<string>^(?:&lt; .* &gt; )?No target for your power could be found!</string>
							<string>^(?:&lt; .* &gt; )?That can only be done in combat!</string>
							<string>^(?:&lt; .* &gt; )?They don't have have any legs for that!</string>
							<string>^(?:&lt; .* &gt; )?You have to be dual wielding to do that.</string>
							<string>^(?:&lt; .* &gt; )?You have to be standing up to do that!</string>
							<string>^(?:&lt; .* &gt; )?They are too large for you to do that!$</string>
							<string>^(?:&lt; .* &gt; )?You would pass right through them!</string>
							<string>^(?:&lt; .* &gt; )?Your mighty blow causes .* to slow down dramatically!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You're not ready to perform another action!</name>
						<script>--display(command)

meleePowerUsed=nil
setBashing(false)

--timer:set("cooldown", 2)

timer:set("cooldown", .5)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You're not ready to perform another action!</string>
							<string>You're not ready to use a weapon power!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>sweeping strike</name>
						<script>-- Sweeping Strike

-- You sweep attack a devout priest with unbound fury, knocking him off balance!
-- You sweep attack Ersenas with a fury of blows, but he retains his balance.
-- You sweep a half-elven boy to the ground and finish him with a pair of killing blows.

-- sweeping strike
meleePowerUsed=false

timer:set("sweeping_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You sweep attack</string>
							<string>You sweep .* to the ground and finish .* with a pair of killing blows.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>knockdown shot</name>
						<script>-- Knockdown Shot
-- You loose a precision shot at a lithe commoner that knocks her off her feet!
-- Your precisely aimed arrow streaks into a human noble, who staggers but retains his balance.
-- Your arrow tears through a chipmunk's leg, knocking its lifeless body to the ground.

meleePowerUsed=false

timer:set("knockdown_shot", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You loose a precision shot at</string>
							<string>Your precisely aimed arrow streaks into</string>
							<string>Your arrow tears through .* leg, knocking its lifeless body to the ground.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hail of arrows</name>
						<script>--Hail of Arrows

--You launch a barrage of arrows into the air to rain down upon your enemies!
-- A lithe commoner is pincushioned by the swarm of falling arrows!

meleePowerUsed=false

timer:set("hail_of_arrows", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You launch a barrage of arrows into the air to rain down upon your enemies!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>splintering shot</name>
						<script>--Splintering Shot
--Your arrow burrows deep into a lithe commoner's flesh and shatters, leaving her howling in pain.
--Your arrow shatters in a spray of splinters as it grazes Aratha Sul.
-- A ruby-throated humming bird's flesh erupts in a shower of blood as your arrow shatters beneath its skin!

meleePowerUsed=false

timer:set("splintering_shot", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your arrow burrows deep into</string>
							<string>Your arrow shatters in a spray of splinters as it grazes</string>
							<string>.* flesh erupts in a shower of blood as your arrow shatters beneath .* skin!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>concussive shot</name>
						<script>-- Concussive Shot
-- You pull an arrow back as far as it will go and unleash its concussive force on a graceful commoner!
-- Your powerfully drawn shot just grazes Aratha Sul!
-- Your mighty shot decapitates a black-capped chickadee with its concussive impact!

meleePowerUsed=false

timer:set("concussive_shot", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You pull an arrow back as far as it will go and unleash its concussive force on</string>
							<string>Your powerfully drawn shot just grazes .*</string>
							<string>Your mighty shot decapitates .* with its concussive impact!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>triple shot</name>
						<script>--Triple Shot
--You launch of volley of three arrows at a human noble, who staggers under the impact.
--A human noble is slain instantly as your deadly volley of arrows find their target.

meleePowerUsed=false

timer:set("triple_shot", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You launch of volley of three arrows at</string>
							<string>is slain instantly as your deadly volley of arrows find their target.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of the winds</name>
						<script>-- Cloak of the winds
-- You feel your movements speed up as a swirling cloak of winds envelops you.

buff:set(whoami(), "cloak_of_the_winds", 40)
timer:set("cloak_of_the_winds", 40)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel your movements speed up as a swirling cloak of winds envelops you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of the winds (drop)</name>
						<script>-- Your cloak of winds vanishes.

buff:set(whoami(), "cloak_of_the_winds", nil)
timer:set("cloak_of_the_winds", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your cloak of winds vanishes.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of protection</name>
						<script>-- Cloak of Protection
-- Softly glowing mists wrap around you in an cloak of protection.

buff:set(whoami(), "cloak_of_protection", 50)
timer:set("cloak_of_protection", 50)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Softly glowing mists wrap around you in an cloak of protection.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of protection (drop)</name>
						<script>-- Your misty cloak of protection dissipates.

buff:set(whoami(), "cloak_of_protection", nil)
timer:set("cloak_of_protection", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your misty cloak of protection dissipates.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of resilience</name>
						<script>-- Cloak of Resilience
-- Wispy bands of shadow clasp about you in a cloak of resilience.

buff:set(whoami(), "cloak_of_resilience", 60)
timer:set("cloak_of_resilience", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Wispy bands of shadow clasp about you in a cloak of resilience.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cloak of resilience (drop)</name>
						<script>-- Your shadowy cloak of resilience dissolves.

buff:set(whoami(), "cloak_of_resilience", nil)
timer:set("cloak_of_resilience", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shadowy cloak of resilience dissolves.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>misty path</name>
						<script>-- Misty Path
-- Swirling, vaporous mists creep up from the ground and encircle your legs.

buff:set(whoami(), "misty_path", 360)
timer:set("misty_path", 360)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Swirling, vaporous mists creep up from the ground and encircle your legs.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>blades of fire</name>
						<script>-- Blades of Fire
-- Your weapons burst into searing white-hot flames.

buff:set(whoami(), "blades_of_fire", 20)
timer:set("blades_of_fire", 20)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapons burst into searing white-hot flames.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>greenfire</name>
						<script>-- Greenfire
-- Your weapons erupt in tendrils of virulent green flames!

buff:set(whoami(), "greenfire", 30)
timer:set("greenfire", 30)

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapons erupt in tendrils of virulent green flames!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>greenfire (drop)</name>
						<script>-- The virulent green flames coating your weapons are extinguished.

buff:set(whoami(), "greenfire", nil)
timer:set("greenfire", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The virulent green flames coating your weapons are extinguished.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>arctic barrage</name>
						<script>-- Arctic Barrage
-- Your bow is encased in a thin layer of sparkling ice.

buff:set(whoami(), "arctic_barrage", 30)
timer:set("arctic_barrage", 30)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your bow is encased in a thin layer of sparkling ice.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>arctic barrage (drop)</name>
						<script>-- The sparkling ice around your bow melts away.

buff:set(whoami(), "arctic_barrage", nil)
timer:set("arctic_barrage", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The sparkling ice around your bow melts away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>lightning arrow</name>
						<script>-- Lightning Arrow
-- Your bow crackles with electricity as a charge collects around it.

buff:set(whoami(), "lightning_arrow", 60)
timer:set("lightning_arrow", 60)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your bow crackles with electricity as a charge collects around it.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>lightning arrow (drop)</name>
						<script>-- Your arrow detonates in a burst of crackling lightning!

buff:set(whoami(), "lightning_arrow", nil)
timer:set("lightning_arrow", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your arrow detonates in a burst of crackling lightning!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hail of thorns</name>
						<script>-- Hail of Thorns
-- A cluster of tiny thorns sprouts all along your bow.

buff:set(whoami(), "hail_of_thorns", 60)
timer:set("hail_of_thorns", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A cluster of tiny thorns sprouts all along your bow.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>hail of thorns (drop)</name>
						<script>-- Your arrow explodes in a shower of vicious thorns!

buff:set(whoami(), "hail_of_thorns", nil)
timer:set("hail_of_thorns", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your arrow explodes in a shower of vicious thorns!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>electric discharge</name>
						<script>-- Electric Discharge
-- Static fills the air as your weapons are wreathed in crackling electricity.

buff:set(whoami(), "electric_discharge", 60)
timer:set("electric_discharge", 60)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Static fills the air as your weapons are wreathed in crackling electricity.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>electric discharge (drop)</name>
						<script>-- Your weapon disharges a massive blast of crackling electricity!

buff:set(whoami(), "electric_discharge", nil)
timer:set("electric_discharge", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon disharges a massive blast of crackling electricity!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>beast sense</name>
						<script>-- Beast Sense

-- You can't see who is fighting Kaizu.

if checkMask("ran") then
	if spell:getSlot(2) &gt; 0 then
		spell:cast("BSE")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can't see who is fighting</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Pal</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shielding smite</name>
						<script>-- A translucent golden shield forms in front of you as strike out at a lithe commoner.
-- As you strike out at a gold finch a golden shield appears and slams into it, leaving only a battered wreck.

-- Shielding smite

meleePowerUsed=false

timer:set("shielding_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A translucent golden shield forms in front of you as</string>
							<string>, and your golden shield fails to appear.</string>
							<string>As you strike out at .* a golden shield appears and slams into .*, leaving only a battered wreck.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>bolstering strike</name>
						<script>-- Bolstering Strike

meleePowerUsed=false

timer:set("bolstering_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>and your accuracy is rewarded with a divine gift of health.</string>
							<string>You strike out at .*, landing a glancing blow!</string>
							<string>You strike .* without reprieve, and .* falls before your overwhelming assault.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>radiant charge</name>
						<script>-- Brilliant rays of light stream from your shield as you charge into Aratha Sul and knock her to the ground!
-- You knock a half-elven girl to the ground with your radiant charge and stand triumphantly over her shattered form.

-- Radiant Charge

meleePowerUsed=false

setBashing(false)

timer:set("radiant_charge", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Brilliant rays of light stream from your shield as you charge into</string>
							<string>sidesteps your charge!</string>
							<string>You knock .* to the ground with your radiant charge and stand triumphantly over .* shattered form.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>enervating strike</name>
						<script>-- Enervating Strike

-- You land a mighty blow upon Willa O'Greensleeves and follow it up with a lethal shield bash!

meleePowerUsed=false

timer:set("enervating_strike", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You land a mighty blow upon .* that leaves .* staggering in pain.</string>
							<string>Using your shield as cover, you land a glancing blow upon</string>
							<string>You land a mighty blow upon .* and follow it up with a lethal shield bash!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>wrathful smite</name>
						<script>-- Wrathful Smite

meleePowerUsed=false

timer:set("wrathful_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A halo of divine light emanates from you, filling you with holy wrath.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>lay on hands</name>
						<script>-- lay on hands

meleePowerUsed=false

timer:set("lay_on_hands", 6*60)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You lay your blessed hands upon</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>divine smite</name>
						<script>-- Divine Smite

-- Your weapon flares with a burst of divine radiance as you strike Willa O'Greensleeves!
-- You land a glancing blow upon NN with your radiant weapon.
-- Your righteous blow shatters an opulent merchant in a blast of divine power!

meleePowerUsed=false

timer:set("divine_smite", 5*60)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon flares with a burst of divine radiance as you strike</string>
							<string>You land a glancing blow upon .* with your radiant weapon.</string>
							<string>Your righteous blow shatters</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>thunderous smite</name>
						<script>-- Thunderous smite

-- Your weapon explodes in a peal of roaring thunder as you strike Lavis Ryl!
-- Lavis Ryl is thrown to the ground by the shockwave!

-- Aratha Sul staggers but maintains her balance as your weapon explodes in a peal of roaring thunder!

meleePowerUsed=false

setBashing(false)

timer:set("thunderous_smite", 12)
setMeleeCooldown()

if matches[2] ~= nil then
	-- Success
	addStat(whoami(), "palTSsuccess")
else
	-- Fail
	addStat(whoami(), "palTSfail")
end

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon explodes in a peal of roaring thunder as you (strike) .*</string>
							<string>balance as your weapon explodes in a peal of roaring thunder!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>valiant strike</name>
						<script>-- valiant strike

--Your weapon ignites with a blazing holy light!
--Your powerful strike glances off of Willa O'Greensleeves's armor!

-- Your powerful strike engulfs an Ashstone noble in searing ribbons of divine radiance.


meleePowerUsed=false

timer:set("valiant_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your powerful strike engulfs .* in searing ribbons of divine radiance.</string>
							<string>Your weapon ignites with a blazing holy light!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>brilliant smite</name>
						<script>-- Brilliant smite

-- Your weapon detonates in a flash of pure light as you strike Willa O'Greensleeves!
-- You cut down a small lizard in a flash of brilliant light.

meleePowerUsed=false

timer:set("brilliant_smite", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your weapon detonates in a flash of pure light as you strike</string>
							<string>Your weapon's brilliant flash is dampened as it glances off of</string>
							<string>You cut down .* in a flash of brilliant light.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>terrifying smite</name>
						<script>-- Terrifying Smite

meleePowerUsed=false

timer:set("terrifying_smite", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your eyes glow with a terrifying radiance as waves of divine dread wash over your enemies.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>whirlwind smite</name>
						<script>-- Whirlwind Smite

meleePowerUsed=false

timer:set("whirlwind_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Brilliant holy light explodes around you as you swing your weapon in a full circle!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>divine challenge</name>
						<script>-- A searing, divine light radiates from you as you confront an elite fortress guard.

buff:set(whoami(), "divine_challenge", 20)
timer:set("divine_challenge", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A searing, divine light radiates from you as you confront</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>true nemesis</name>
						<script>-- You extend your holy symbol towards an elemental lord, singling it out for your divine retribution.

timer:set("true_nemesis", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string> ?You extend your holy symbol towards .*, singling it out for your divine retribution.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>cleansing spirit</name>
						<script>-- cleansing spirit

-- A translucent outline briefly appears above you as your afflictions are cleansed.
-- A translucent outline briefly appears above Kelwyn.

buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")
buff:del(whoami(), "poison")
buff:del(whoami(), "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A translucent outline briefly appears above you as your afflictions are cleansed.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of warding</name>
						<script>-- shield of warding

-- An opaque globe of light blossoms around you, shielding you from harm.

buff:set(whoami(), "shield_of_warding", 12)

timer:set("shield_of_warding", 12)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>An opaque globe of light blossoms around you, shielding you from harm.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of warding (drop)</name>
						<script>-- shield of warding

buff:set(whoami(), "shield_of_warding", nil)

timer:set("shield_of_warding", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shield of warding evaporates, leaving you vulnerable to attack.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>brand of judgement</name>
						<script>-- You summon a divine light to sear the symbol of your deity into Corland Deepforge's flesh!

timer:set("brand_of_judgement", 50)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You summon a divine light to sear the symbol of your deity into</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of faith</name>
						<script>-- shield of faith

buff:set(whoami(), "shield_of_faith", 30)

timer:set("shield_of_faith", 30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A shimmering field of light surrounds you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shield of faith (drop)</name>
						<script>-- shield of faith

buff:set(whoami(), "shield_of_faith", nil)

timer:set("shield_of_faith", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shimmering shield of faith fades away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of life</name>
						<script>-- Aura of Life
-- You begin to pulsate with a soft light as you are infused with divine health.

buff:set(whoami(), "aura_of_life", 90)

timer:set("aura_of_life", 90)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You begin to pulsate with a soft light as you are infused with divine health.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of life (drop)</name>
						<script>-- aura of life

-- The soft light surrounding you dims as your aura of life fades away.

buff:set(whoami(), "aura_of_life", nil)

timer:set("aura_of_life", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The soft light surrounding you dims as your aura of life fades away.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>holy sword</name>
						<script>-- holy sword
-- Divine light coalesces in a soft radiance around your weapon.

buff:set(whoami(), "holy_sword", 20)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Divine light coalesces in a soft radiance around your weapon.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Blk</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>plundering smite</name>
						<script>-- Your strike leaves a vile blight on a lithe commoner, and some of her life flows into you.
-- You attack Dragor Keenblade with a vile strike, landing a glancing blow.


meleePowerUsed=false

timer:set("plundering_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your strike leaves a vile blight on .*</string>
							<string>^(?:&lt; .* &gt; )?You land a hideous blow on .* is overwhelmed with necrotic blight.</string>
							<string>^(?:&lt; .* &gt; )?You attack .* with a vile strike, landing a glancing blow.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dominating smite</name>
						<script>-- You advance upon a graceful commoner with a series of devastating blows that send him crashing to the ground.
-- Willa O'Greensleeves retains her balance in the face of your punishing advance!

-- You crushed Sir Frithyl's skull, I'm afraid he's dead.


meleePowerUsed=false

setBashing(false)

timer:set("dominating_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You advance upon .* with a series of devastating blows that send .* crashing to the ground.</string>
							<string>.* balance in the face of your punishing advance!$</string>
							<string>^(?:&lt; .* &gt; )?You advance mercilessly upon .*, raining down blow after blow until .*</string>
							<string>^(?:&lt; .* &gt; )?You crushed .* skull, I'm afraid .* dead.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dark majesty</name>
						<script>-- Dark tendrils crawl forth from your shield and wrap around you as you strike out at a lithe commoner.
-- Dark tendrils crawl forth from your shield and wrap around you as you strike out at Willa O'Greensleeves.
-- As you slam your shield into a squire a cloud of shadowy tendrils bursts forth and smothers the life from him.

meleePowerUsed=false

timer:set("dark_majesty", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Dark tendrils crawl forth from your shield and wrap around you as you strike out at .*</string>
							<string>^(?:&lt; .* &gt; )?Your shield emits an acrid puff of black smoke as you strike a glancing blow upon .*</string>
							<string>^(?:&lt; .* &gt; )?As you slam your shield into .* a cloud of shadowy tendrils bursts forth and smothers the life from .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ruinous smite</name>
						<script>-- With a murderous howl, you land a gruesome blow on Aratha Sul that leaves her faltering.
-- With a murderous howl, you land a gruesome blow on Willa O'Greensleeves that leaves her faltering.
-- A black-capped chickadee wails in mortal terror as you strike it down with a horrifying blow!

-- ruinous smite

meleePowerUsed=false

timer:set("ruinous_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?With a murderous howl, you land a gruesome blow on .*</string>
							<string>^(?:&lt; .* &gt; )?You shriek in anger as your gruesome blow glances off .*</string>
							<string>.* wails in mortal terror as you strike .* down with a horrifying blow!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>frenzying smite</name>
						<script>-- Your eyes glow with a crimson light as you are overcome with bloodlust.


meleePowerUsed=false

timer:set("frenzying_smite", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your eyes glow with a crimson light as you are overcome with bloodlust.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>sigil of pain</name>
						<script>-- You summon a blood-red ray to sear a sigil of pain into Ersenas's flesh!
-- A ruby-throated humming bird collapses in agony as you sear the flesh from its bones with a blood-red ray!

timer:set("sigil_of_pain", 50)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You summon a blood-red ray to sear a sigil of pain into .*</string>
							<string>collapses in agony as you sear the flesh from .* bones with a blood-red ray!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dread smite</name>
						<script>-- Dread smite
-- Shadows coalesce around your weapon as you strike Seipora Rein in a burst of dark power.
-- You land a glancing blow upon Shalyssa Lurialar with your dread weapon.
-- Your dread strike pulverizes a squire in a blast of frigid shadows!
-- Shadows coalesce around your weapon as you strike a narzugon dragon-knight in a burst of dark power.

meleePowerUsed=false

timer:set("dread_smite", 5*60)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Shadows coalesce around your weapon as you strike .*</string>
							<string>^(?:&lt; .* &gt; )?You land a glancing blow upon .* with your dread weapon.</string>
							<string>^(?:&lt; .* &gt; )?Your dread strike pulverizes .* in a blast of frigid shadows!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shattering smite</name>
						<script>-- shattering smite

-- Your weapon unleashes a torrent of dark power as you strike A burly bouncer, knocking him to the ground.
-- Your weapon explodes in a blast of dark power, sending Forell Luckaun's shattered form sprawling.


meleePowerUsed=false

setBashing(false)

timer:set("shattering_smite", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapon unleashes a torrent of dark power as you strike .* to the ground.</string>
							<string>^(?:&lt; .* &gt; )?Your dark power washes over.* as you strike a glancing blow.</string>
							<string>^(?:&lt; .* &gt; )?Your weapon explodes in a blast of dark power, sending .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>vengeance strike</name>
						<script>-- vengeance strike

-- Your weapon begins to pulse with a sinister glow as your soul fills with vengeance.

meleePowerUsed=false

timer:set("vengeance_strike", 12)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your weapon begins to pulse with a sinister glow as your soul fills with vengeance.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>spirit harrow</name>
						<script>-- spirit harrow

-- Your raise your weapon menacingly as it fades out, becoming smoky and grey.

meleePowerUsed=false

timer:set("spirit_harrow", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your raise your weapon menacingly as it fades out, becoming smoky and grey.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>mortal dread</name>
						<script>-- mortal dread
-- Strands of darkness shroud your form as you land a wicked strike upon A burly bouncer.
-- You lash out at a devout priest with a wicked strike, landing a glancing blow.
-- You loose a dread roar as you pulverize a ruby-throated humming bird with a wicked strike!

meleePowerUsed=false

timer:set("mortal_dread", 24)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Strands of darkness shroud your form as you land a wicked strike upon .*</string>
							<string>^(?:&lt; .* &gt; )?You lash out at .* with a wicked strike, landing a glancing blow.</string>
							<string>^(?:&lt; .* &gt; )?You loose a dread roar as you pulverize .* with a wicked strike!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>uncontrolled fury</name>
						<script>-- uncontrolled fury
-- Your skin turns stark white and your eyes blacken as you let loose a terrifying death shriek.

meleePowerUsed=false

timer:set("uncontrolled_fury", 36)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Your skin turns stark white and your eyes blacken as you let loose a terrifying death shriek.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>baleful challenge</name>
						<script>-- baleful challenge
-- You radiate a powerful sense of crushing dread as you confront Willa O'Greensleeves.

buff:set(whoami(), "baleful_challenge", 20)
timer:set("baleful_challenge", 60)

meleePowerUsed=false

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You radiate a powerful sense of crushing dread as you confront .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>corrupt weapon</name>
						<script>-- Corrupt Weapon
-- Crimson tendrils seep from your hands and coil menacingly around your weapon.

buff:set(whoami(), "corrupt_weapon", 20)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Crimson tendrils seep from your hands and coil menacingly around your weapon.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aspect of domination</name>
						<script>-- Aspect of domination
-- Shadowy black wings sprout from your back as you start emanating a wave of seething hatred.

buff:set("aspect_of_domination", 40)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?Shadowy black wings sprout from your back as you start emanating a wave of seething hatred.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>soul touch</name>
						<script>-- Soul Touch
-- You reach out and grasp Corland Deepforge savagely, drawing his life force into you.
-- You reach out and grasp A naked woman savagely, drawing her life force into you.
-- You are overcome with a dark euphoria as the last of an opulent merchant's life force flows into you.

meleePowerUsed=false

timer:set("soul_touch", 6*60)

setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You reach out and grasp .* savagely, drawing .* life force into you.</string>
							<string>^(?:&lt; .* &gt; )?You are overcome with a dark euphoria as the last of .* life force flows into you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shroud of shadow</name>
						<script>-- shroud of shadow

-- A misty cloud of gloom swirls about you, shielding you from harm.

buff:set(whoami(), "shroud_of_shadow", 12)
timer:set("shroud_of_shadow", 12)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?A misty cloud of gloom swirls about you, shielding you from harm.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>shroud of shadow (drop)</name>
						<script>-- Your shroud of shadow dissipates, leaving you vulnerable.

buff:set(whoami(), "shroud_of_shadow", nil)
timer:set("shroud_of_shadow", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your shroud of shadow dissipates, leaving you vulnerable.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of death</name>
						<script>-- aura of death
-- A dark mist surrounds you, wrapping you in the chill embrace of death.

buff:set(whoami(), "aura_of_death", 90)
timer:set("aura_of_death", 90)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?A dark mist surrounds you, wrapping you in the chill embrace of death.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>aura of death (drop)</name>
						<script>-- The dark mists swirling around you melt back into the shadows.

buff:set(whoami(), "aura_of_death", nil)
timer:set("aura_of_death", 0)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The dark mists swirling around you melt back into the shadows.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>consumption</name>
						<script>-- Your form flares with a brief crimson glow as you purge yourself of afflictions.

buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")
buff:del(whoami(), "poison")
buff:del(whoami(), "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your form flares with a brief crimson glow as you purge yourself of afflictions.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>scourge of agony</name>
						<script>-- A ruby-throated humming bird shrieks in agony as your flaming whip strips the flesh from its bones!

-- Scourge of Agony

-- no unique button</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>. * shrieks in agony as your flaming whip strips the flesh from .* bones!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ravenous shadows</name>
						<script>-- You channel the twisted spirits of your past victims into a swirling, life-draining mass!
-- The swirling spirits screech an ear-rending shriek as they devour a ruby-throated humming bird's flesh!</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?You channel the twisted spirits of your past victims into a swirling, life-draining mass!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>RaceTriggers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Yuan-Ti</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You concentrate and harden your body into thick scales.</name>
						<script>-- scaleskin enabled (yuanti)
-- innate scaleskin - You concentrate and harden your body into thick scales.

charData:set("scaleskin", true)
scale_skin("scale_skin", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You concentrate and harden your body into thick scales.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your scales become soft once more.</name>
						<script>-- Your scales become soft once more.

charData:set("scaleskin", false)
scale_skin("scale_skin", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your scales become soft once more.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Half-Orc</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>furious assault</name>
						<script>-- You attack Stephan with monstrous fury!

meleePowerUsed=false

timer:set("furious_assault", 90)
setMeleeCooldown()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You attack .* with monstrous fury!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>WhoClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture from wholist</name>
					<script>--[50 Cle] Isila  (Moon Elf) [@Inames]
--[50 Ill] Imay  (Drow Elf) [@Tanji]
--[50 Rog] Gaidiel - Pirate King of the Valkurian Blades (Moon Elf) [@Diel]
--[50 Cle] Osheara Arluune -*- Azurite -*- Shadows of Imphras (Moon Elf)
--[50 A-P] Razem  (Half-Orc) [@Enth]

sqlinwho(matches[3])
whoadd(matches[3], matches[2], matches[4])

-- echo profile name after character

local profile=getProfile(matches[3])

if profile then
	cecho( "&lt;slate_grey&gt; [@" .. profile .. "]" )

	if profile == "unknown" or profile == 1 then
		-- TODO needs to be corrected to not send when in paging mode
		mud:send("who " .. matches[3])
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[[0-9 ]+([a-zA-Z-]+)\] ([a-zA-Z]+) .*\(([a-zA-Z- ]+)\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Save wholist</name>
					<script>savewholist()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Record number of players on this boot</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture charname</name>
					<script>setwhoami(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Character attributes for ([a-zA-Z]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Katumi tells you</name>
					<script>if inwho(matches[3]) == false then
	whoadd(matches[3], matches[2], matches[4], matches[5])

	echoDebug("\n[Adding " .. matches[3] .. " to wholist]")

	setProfile(matches[3], matches[5])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Katumi tells you '\[[0-9]+ (.*)\] ([A-Za-z]+) \((.*)\) \(@([A-Za-z]+)\) seen .*'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture from individual who</name>
					<script>if inwho(matches[3]) == false then
	for k, v in pairs(NyyLIB.fullclasslist) do
		if v[1] == matches[2]:trim()	 then
			whoadd(matches[3], v[2], matches[4], matches[5])
			return
		end
	end
end

if inwho(matches[3]) == "unknown" then
	setProfile(matches[3], matches[5])
	echoDebug(" [Setting " .. matches[3] .. " profile name to " .. matches[5] .. "]\n")
end

-- getProfile(matches[3]) this command errors if not in database

if getProfile(matches[3]) ~= matches[5] then
	echoDebug(" [Profile Error: " .. getProfile(matches[3]) .. " : " .. matches[5] .. "]\n")
	setProfile(matches[3], matches[5])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[ ?[0-9]+ (.*) *\] ([A-Za-z]+) +.*\((.*)\) \(@([A-Za-z]+)\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Total players online: 20.</name>
					<script>-- end of who list</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Total players online: [0-9]+[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GroupClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Add from group display</name>
					<script>local temp = whoclass(matches[8]) or "UNK"

if gagGroup == nil then
	groupList:display(matches[8], matches[6], matches[7], matches[4], matches[5], matches[2], matches[3] )
else
	eraseLine()
end

groupList:add( idMob(matches[8]),temp,matches[6],matches[7])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([0-9]+)/([0-9]+) +man +([0-9]+)/([0-9]+) +move +([0-9]+)/([0-9]+) +hit - ([A-Za-z ]+)</string>
						<string>([0-9]+)/([0-9]+) +psp +([0-9]+)/([0-9]+) +move +([0-9]+)/([0-9]+) +hit - ([A-Za-z ]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Reset grouplist</name>
					<script>groupRedraw = false

groupList:reset()

NyyLIB.groupname = matches[2]

if gagGroup == nil then
	if charData:get("group", true) then
		cecho("                                 &lt;yellow&gt;[Stats: " .. charData:get("statname") .. "]\n")
	end
else
	eraseLine()
end

group:set("GROUPSTART")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Group information for (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>But you are a member of no group?!</name>
					<script>groupRedraw = nil

groupList:reset()

if gagGroup then
	group:send(false)
	eraseLine()
	echoDebug(" &lt;red&gt;[empty group received]")
end

groupList:add(whoami(), whoclass(), prompt:get("hp"), prompt:get("maxhp") )

rescuelist:generate()

RedrawGroupStatus()

resizeGroupWindow(true)

group:set("GROUPSTART")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>But you are a member of no group?!</string>
						<string>You are no longer a member of the group.</string>
						<string>You are now a member of</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Joined group</name>
					<script>group:send()
tempTimer(2, [[resizeGroupWindow(true)]])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>now a member of</string>
						<string>([A-Za-z]+) has left the group.</string>
						<string>has disbanded the group.</string>
						<string>You disband the group.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Add when not in same room</name>
					<script>local temp = whoclass(matches[2]) or "UNK"

if 	gagGroup == nil then
	groupList:display(matches[2])
else
	eraseLine()
end

groupList:add( idMob(matches[2]),temp, 0, 0)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>                                                        [-] ([A-Za-z ]+)</string>
						<string>[(]Head[)]   [ ]+[-] ([A-Za-z]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>add from group no mana</name>
					<script>local temp = whoclass(matches[6]) or "UNK"

if 	gagGroup == nil then
	groupList:display(matches[6], matches[4], matches[5], matches[2], matches[3] )
else
	eraseLine()
end

groupList:add( idMob(matches[6]),temp,matches[4],matches[5])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>        +([0-9]+)/([0-9]+) +move +([0-9]+)/([0-9]+) +hit - ([A-Za-z ]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Autogroup</name>
					<script>-- Dlabble has just given you his consent.
local consentchar= matches[2]


consent:set( consentchar, true )

if matches[2] ~= "slaad" then
	if inwho(matches[2]) == false then
		mud:send("who " .. consentchar)
	end
end

-- Send group command if char isn't currently grouped
if groupList:ingroup(consentchar) then
	--
else
	mud:send("GROUP " .. consentchar)
	group:send()
end

look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) has just given you (his|her|its) consent[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>remove dead people</name>
					<script>-- open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving
-- hand reaching down to touch ([A-Za-z]+) and .*
-- When it at last clears ([A-Za-z]+) stands before you, looking extremely tired!
-- ([A-Za-z]+) takes a first shuddering breath and rises from the dead. 

local matchchar=matches[2]

-- Misi has returned to the land of the living.

-- if grouplist doesn't have hp send group
if groupList:ingroup(matchchar) then
	if groupList:getHP(matchchar) == 0 then
		group:send()
	end
end

if table.contains(NyyLIB.deadpeople, matches[2]) then
	echoDebug("\n" .. matchchar .. " is alive!\n")

	table.remove(NyyLIB.deadpeople, table.index_of(NyyLIB.deadpeople, matchchar))

	group:send()
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) .* stands here.</string>
						<string>([A-Za-z]+) .* sits resting.</string>
						<string>([A-Za-z]+) .* stands in mid-air here.</string>
						<string>([A-Za-z]+) .* stands, inches above the surface here.</string>
						<string>([A-Za-z]+) steps out of a wormhole.</string>
						<string>([A-Za-z]+) flies in from the (north|south|east|west).</string>
						<string>([A-Za-z]+) .* hulks here.</string>
						<string>open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving</string>
						<string>hand reaching down to touch ([A-Za-z]+) and .*</string>
						<string>When it at last clears ([A-Za-z]+) stands before you, looking extremely tired!</string>
						<string>([A-Za-z]+) has returned to the land of the living.</string>
						<string>([A-Za-z]+) .* is stretched out, sound asleep.</string>
						<string>([A-Za-z]+) takes a first shuddering breath and rises from the dead. </string>
						<string>([A-Za-z]+) flies in from above.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Dogmasa has died!</name>
					<script>if groupList:ingroup(matches[2]) then
	if table.contains(NyyLIB.deadpeople, matches[2]) == false then
		table.insert(NyyLIB.deadpeople, 1, matches[2])
	end

	buff:del(matches[2])

	if inwho(matches[2]) == "Lilithelle" then
		sound("209740__yummie__minion-yahoo-2.wav")
	else
		sound("195954_minian89_death-blood-splatter.wav")
	end

	group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?([A-Za-z]+) has died!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>([A-Za-z]+) group-says '.*</name>
					<script>inwho(matches[2])

if not groupList:ingroup( idMob(matches[2]) ) then
	if whoclass(matches[2]) ~= nil then
		groupList:add( idMob(matches[2]), whoclass(matches[2]), 0, 0)
		resizeGroupWindow(true)
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) group-says '.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>add group leader</name>
					<script>-- setting group leader

if matches[2] ~= "Someone" then
	NyyLIB.leader = matches[2]
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\(Head\) .* - ([A-Za-z]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Size:</name>
					<script>currentsize = currentsize or 0

-- if groupsize has changed or blind, gui will need forced resize
if currentsize ~= matches[2] or buff:get("blind") or buff:get("blindness") then 
	currentsize = matches[2]

	--display("enable forceresize")

	tempTimer(1, [[resizeGroupWindow(true)]])
end

enableTrigger("endprompt")

if 	gagGroup == nil then
	if charData:get("group", true) then
		eraseLine()

		cecho(string.format("\n&lt;yellow&gt;  HP/Max           [Group Size:%2d]              MV/Max  PSP/Max    " .. 
	    "Hit (Total) Rescue (Total)",
			matches[2]))
	end
else
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Size: +([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endprompt</name>
					<script>-- group has been recieved. can check for vit (send status) now
gagGroup=nil

groupList:checkMaxHP()

disableTrigger("endprompt")
rescuelist:generate()
echoDebug("&lt;red&gt; [Group received]\n")
group:send(false)
groupRedraw = nil
raiseEvent("promptEvent")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>is already a member of another group!</name>
					<script>if NyyLIB.leader == whoami() then
	mud:send("t " .. matches[2] .. " " .. matches[2] .. " is already a member of another group!")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) is already a member of another group!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Update grouped players fighting</name>
					<script>-- Add any grouped players tanking a mob to the list

--The ghoul of an opulent merchant stands here, fighting an opulent merchant.
--An opulent merchant stands here, fighting the ghoul of an opulent merchant.

-- If last command entered was "l " or scan, return

if string.find(command, "L ") == 1 or command == "SCAN" then
	return
end

if matches[2] == "YOU" then
	groupList:incTanking(whoami())
end

if groupList:ingroup( idMob(matches[2]) ) then
	groupList:incTanking( idMob(matches[2]) )
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*[,] fighting ([A-Za-z ]+)[.]</string>
						<string>.*[,] fighting (YOU)!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Reset tanking list</name>
					<script>-- Since a room is being looked at, the table of players tanking mobs is reset

-- If last command entered was "l " or scan, return

if string.find(command, "L ") == 1 or command == "SCAN" then
	return
end

groupList:resetTanking()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>disable looting and autoassist when grouped</name>
					<script>-- You form a new group.

-- don't disable if leading smtrain
if isActive("SMTrain", "trigger") == 0 then
	if previousLine() ~= "You form a new group." then
		echo("\n")
		buttons:change("autoloot", "off", "autoloot")
		buttons:change("autoassist", false, "autoassist")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are now a member of</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>MiscTriggers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PANIC!  You couldn't escape!</name>
					<script>-- Send flee again on failed attempt to flee

fleeAttempt = fleeAttempt or 0

if charData:get("flee") ~= "off" and charData:get("flee") ~= "dragon"  or NyyLIB.escapedir ~= nil then

	if matches[2] ~= "busy" then
		display("X")
		fleeAttempt = fleeAttempt + 1
	end

	if fleeAttempt &lt; 15 then
		-- abort spell if casting

		spell:clear()

		mud:send("flee")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?PANIC!  You couldn't escape!</string>
						<string>^(?:&lt; .* &gt; )?You scramble madly to your feet!</string>
						<string>^(?:&lt; .* &gt; )?You're too (busy) trying to gain the initiative to flee!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Stand Triggers</name>
					<script>-- Various reasons to send a stand command

-- sends you sprawling

sound("123753__vicces1212__collapse.wav")

spell:setMem(false)

if spell:getCurrent() then
	spell:setCurrent(nil)
end

-- TODO: Because the prompt is going to show recline/stand hasn't been sent, a stand command should be generated/ this one removed
mud:send("ST")

-- set prompt to reclined

prompt:set("position", "rcl")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>fall to your knees</string>
						<string>The shockwave sends you crashing to the ground!$</string>
						<string>tripping you.</string>
						<string>You are knocked</string>
						<string>You are slammed</string>
						<string>You are swept off your feed by the size of the wave!$</string>
						<string>You fall and injure yourself!$</string>
						<string>You get hit by a giant boulder and fall to the ground!$</string>
						<string>You lose your balance</string>
						<string>You stagger about, then fall sprawling!$</string>
						<string>Your hasty hamstring causes you to slip and fall to the ground!$</string>
						<string>Your head slams into the ground, stunning you!$</string>
						<string>You flail about wildly and crash to the ground!$</string>
						<string>Boldly taking the impact, you are still knocked aside!$</string>
						<string>You simply bounce off</string>
						<string>You have to be standing up to do that!$</string>
						<string>you topple over and fall to the ground.</string>
						<string>only to sprawl completely THROUGH</string>
						<string>You are swept off your feet by the size of the wave!$</string>
						<string>Who can concentrate with all that clanging and screaming[?]$</string>
						<string>You can't concentrate with all the racket!$</string>
						<string>You crash to the ground beneath the powerful strike!$</string>
						<string>around your limbs. It yanks your feet out from under you, sending you crashing</string>
						<string>You manage to, with complete incompetence, throw yourself head first directly into the ground!$</string>
						<string>Get off your knees!$</string>
						<string>In your haste to slam people around, you slip and fall!$</string>
						<string>only to fall onto your face THROUGH</string>
						<string>The violent winds pick you up and toss you aside!$</string>
						<string>Intense pain runs through your body as your ribs fracture from the impact.$</string>
						<string>You collapse in a heap on the ground.$</string>
						<string>is too huge for you to trip! You go crashing to the ground.</string>
						<string>And just for the attempt, you fall down.$</string>
						<string>and you go down as well.</string>
						<string>Standing would be a good first step.$</string>
						<string>You fall to the ground.  You stop riding.$</string>
						<string>Damn!  Lost your train of thought!$</string>
						<string>With a powerful heave on the whip, an elite cornugon sends you crashing to the ground in a spray of blood!$</string>
						<string>You can't do this sitting!$</string>
						<string>You stagger, and fall to your knees!$</string>
						<string>^.* sends you sprawling.$</string>
						<string>^You are unable to dodge the blow, and its force sends you crashing to the ground!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Flee Lich'd</name>
					<script>-- Flee if hit by lich proc

if charData:get("flee") == "lich" then
	mud:send("flee")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you fall, you see a stream of your own life force flowing away from you..</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Return after fleeing</name>
					<script>-- If a room is fleed (for example, by dragon roar) return to the previous room
-- If autohide is turned on, you won't return - You'll attempt to hide
-- If your current hp is less then your wimpy, you also won't return.

local temp = matches[2]:lower()

if checkMask("psi") then
	if charData:get("autohide") then
		return
	end
end

if charData:get("wimpy") ~= nil then
	if prompt:get("hp") &lt;= charData:get("wimpy") then
		return
	end
end

if NyyLIB.escapedir ~= nil then
	return
end


if charData:get("flee") == "dragon" then
	if temp == "north" then
		mud:send("s")
	elseif temp == "south" then
		mud:send("n")
	elseif temp == "east" then
		mud:send("w")
	elseif temp == "west" then
		mud:send("e")
	elseif temp == "up" then
		mud:send("d")
	elseif temp == "down" then
		mud:send("u")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You flee (.*)ward!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Looting</name>
					<script>-- Loot if autoloot enabled, update xp display and dismount if mounted
-- Reset various variables, and send a look command to the mud

prompt:set("tank", nil)

if not getHide() then
	if charData:get("autoloot") == "coins" then
		mud:send("get coins corpse")
	elseif charData:get("autoloot") == "all" then
		mud:send("get all corpse")
	end
end

if charData:get("level") &lt; 50 then
	mud:send("exp", false)
	NyyLIB.delxpline = true
end

--if mount:get() ~= nil then
--	mud:send("dismount")
--end

setBashing(false)
setTripping(false)
rescueSent=false

assistSent=nil

look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You receive .* XP .* experience.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Any prompt</name>
					<script>-- raise status event
if NyyLIB.statuschar ~= "" then
	raiseEvent("statusEvent", NyyLIB.statuschar)
end

NyyLIB.statuschar=""

-- room capture: display if present

disableTrigger("RoomCapture")

roomWindow:update()

disableTrigger("lootlist")

enableTrigger("StartRoomCapture")

if look:get() ~= "LOOKSENT" then
	gaglook=nil
end

if Geyser.Label:getWindow("gIconBarWindow") == nil then
	return
end

roomWindow:resize()

-- don't enable gagging look until a prompt has been receieved subsequent to sending the command
if toGagLook == true then
	gaglook=true
	toGagLook=nil
end	

-- first prompt after a look recieved
if look:get() == "LOOKSTART" then
	look:set(nil)

	-- re-raise prompt event
	raiseEvent("promptEvent")
end

-- first prompt after a group recieved
if group:get() == "GROUPSTART" then
	group:set(false)
	
	-- rogue: circle
	if charData:get("autocircle") then
		if prompt:get("tank") ~= whoami() and inCombat() then
			--if prompt:get("enemycondition") ~= "awful" then
				expandAlias("cr", false)
			--end
		end
	end
end

RedrawGroupStatus()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; (.*) &gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are getting hungry.</name>
					<script>-- If not hidden, eat food

if inCombat() then
	return
end

if not getHide() then
	if checkMask("psi") then
		if charData:get("autosustain") then
			mud:send("sustain")
		end
	else
		mud:send("eat " .. charData:get("food") .. " " .. charData:get("container") )
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are getting hungry[.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are getting thirsty.</name>
					<script>-- If not hidden, drink water

if not getHide() then
	if checkMask("psi") then
		--
	else
		if not inCombat() then
			mud:send("drink " .. charData:get("canteen") )
		end
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You are getting thirsty[.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The ([A-Za-z]+) seems to be closed.</name>
					<script>-- If an attempt is made to walk through a closed door, and autoopen is enabled - Open it

if charData:get("autoopen") then
	mud:send("open " .. matches[2])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The ([A-Za-z]+) seems to be closed.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You stop trying to hide.</name>
					<script>setHide(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You stop trying to hide.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>misc look:send() triggers</name>
					<script>look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A dark shape springs out of the darkness at you!</string>
						<string>causes an EARTHQUAKE!</string>
						<string>utters a single word and disappears.</string>
						<string>.* turns .* attention to .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your bash at a young alligator sends him sprawling.</name>
					<script>meleePowerUsed=false

setBashing(false)
setTripping(false)

sound("241280__sonictechtonic__gooeybashes.wav")

timer:set("cooldown", 1.5)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your bash at .* sends (him|her|it) sprawling.</string>
						<string>They have to be standing up for you to do that!</string>
						<string>You can't do that without solid ground underneath you!</string>
						<string>Your icy bash at .* sends (him|her|it) sprawling.</string>
						<string>But they're already on the ground!</string>
						<string>You manage to, with complete incompetence, throw yourself head first directly into the ground!</string>
						<string>You do a fancy maneuver, tripping</string>
						<string> is too huge for you to trip! You go crashing to the ground.</string>
						<string>You're not ready to perform another action!</string>
						<string>You sweep attack</string>
						<string>That power hasn't recharged yet!</string>
						<string>You would pass right through them!</string>
						<string>No target for your power could be found!</string>
						<string>You advance .* with a series of devastating blows that send .* crashing to the ground.</string>
						<string>You need to be able to see your target to do that!</string>
						<string>They are too large for you to do that!</string>
						<string>They are too small for you to do that!</string>
						<string>You are slammed down on the ground!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You raise a level!</name>
					<script>charData:set( "level", charData:get("level")+1 )

mud:send("score")
mud:send("gsay &lt;&lt;&lt; Level " .. charData:get("level") .. "! &gt;&gt;&gt;")

initClass()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You raise a level!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are 6,256,116 XP (83.75%) away from your next level.</name>
					<script>-- Your guildmaster says 'You have just begun the trek to your next level!' - l1/0%

if NyyLIB.xpwindow == nil then
	return
end

local xppercent = 100 - tonumber(matches[3])

NyyLIB.xpwindow:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;L:]] .. charData:get("level") .. " " .. xppercent .. [[%&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])	

if NyyLIB.delxpline then
	eraseLine()
	NyyLIB.delxpline = false
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are ([0-9,]+) XP \(([0-9.]+)%\) away from your next level.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>anti-spellguard</name>
					<script>-- Spellguard (aggro evil race) entering room in Silverymoon

if whoami() == "Nyyrazzilyss" then
	mud:send("slaad")
	mud:send("ORDER slaad bash spellguard")
	mud:send("project schism")
	mud:send("protect")
end

if whoclass() == "Psi" then
	mud:send("ultra spellguard")
	mud:send("ultra")
	mud:send("ultra")
end

if whoami() == "Adud" then
	mud:send("say aid of mage")
	mud:send("say strength of stone")
	mud:send("vitme")
	sendBash("spellguard")
end

if whoami() == "Rrissun" then
	mud:send("slaad")
	mud:send("ORDER slaad bash spellguard")
	spell:cast("ha slaad")
	spell:cast("ha me")
	spell:cast("cr spellguard")
	spell:cast("sp spellguard")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A mage in the Spellguard flies in from</string>
						<string>A mage in the Spellguard snaps into visibility.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>.* switches targets[.][.]$</name>
					<script>look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* switches targets[.][.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You give your consent to Lilithelle.</name>
					<script>if groupList:size() &gt; 1 then
	mud:send("t " .. matches[2] .. " " .. matches[2] .. " now has consent.")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You give your consent to ([A-Za-z]+).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You now flee at 200 hit points or less!</name>
					<script>if matches[2] == nil then
	charData:set("wimpy", 0)
else
	charData:set("wimpy", tonumber(matches[2]) )
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You now flee at ([0-9]+) hit points or less!</string>
						<string>You now feel like a true hero, no auto-fleeing here! :-)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Resurrection triggers</name>
					<script>if matches[2] == nil then
	cecho("&lt;red&gt;[Error: nil consent match]\n")
end

if groupList:ingroup(matches[2]) then
	mud:send("consent " .. matches[2])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Thamos) tells you 'I will now RESURRECT you, make sure I have your CONSENT'</string>
						<string>^(Osheara) tells you 'Get ready for the BLUEST resurrection ever!'</string>
						<string>^([A-Za-z]+) tells you 'consent.*$</string>
						<string>^([A-Za-z]+) tells you 'ressing, consent .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You think Coburaxximus has spotted you!</name>
					<script>setHide(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You think .* has spotted you!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You escape ([nsewud]).*</name>
					<script>NyyLIB.escapedir = nil

if NyyLIB.roguereturn ~= nil then
	mud:send(NyyLIB.reversedirs[matches[2]], false)

	local attacktarget

	if NyyLIB.target == nil then
		attacktarget = getEnemy()
	else
		attacktarget = NyyLIB.target
	end

	if attacktarget ~= "" then
		if NyyLIB.roguereturn == "c" then
			NyyLIB.tosend = "circle " .. attacktarget
		elseif NyyLIB.roguereturn == "b" then
			NyyLIB.tosend = "backstab " .. attacktarget
		elseif NyyLIB.roguereturn == "p" then
			NyyLIB.tosend = "bs " .. attacktarget
		end
	else
		cecho("&lt;red&gt;[No target is currently set. Use @target name to set targets.]\n")
	end

	NyyLIB.roguereturn = nil
else
	if charData:get("autohide") then
		if checkMask("rog") then
			mud:send("hide")
			mud:send("save")
		end
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You escape ([nsewud]).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You get the dust of a shadow from corpse of a shadow.</name>
					<script>mud:send("put dust " .. charData:get("container") )</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You get the dust of a shadow from corpse of a shadow.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>poke - haste</name>
					<script>-- haste on poke

if charData:get("pokehaste") then
	if groupList:ingroup(matches[2]) then
		local level = charData:get("level")

		if whoclass() == "Enc" and level &gt;= 16 then
			spell:cast("HS " .. matches[2])
		elseif whoclass() == "Ele" and level &gt;= 31 then
			spell:cast("HS " .. matches[2])
		elseif whoclass() == "Nec" and level &gt;= 31 then
			spell:cast("HS " .. matches[2])
		elseif whoclass() == "Lic" and level &gt;= 31 then
			spell:cast("HS " .. matches[2])
		end

	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) pokes you in the ribs. What!?</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>That power hasn't recharged yet!</name>
					<script>if matches[2] ~= "stunned" then
	mud:send("RECHARGE")
end

local val=timer:get("cooldown")


if val ~= nil then
	if timer:get("cooldown") &lt; 1 then
		timer:set("cooldown", .5)
	end
else
	timer:set("cooldown", .5)
end

meleePowerUsed=false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>That power hasn't recharged yet!</string>
						<string>You are too (stunned) to do that!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Why?  You are not fighting anyone.</name>
					<script>if NyyLIB.escapedir ~= nil then
	mud:send(NyyLIB.escapedir, false)

	NyyLIB.escapedir = nil
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Why?  You are not fighting anyone.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your account contains</name>
					<script>disableTrigger("DepositTrigger")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*Your account contains:$</string>
						<string>I don't see a banker around here.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>DepositTrigger</name>
					<script>-- display("trigger matches")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>There were[:] .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([0-9]+) platinum coin</name>
						<script>mud:send("deposit " .. matches[2] .. " p")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([0-9]+) platinum coin</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([0-9]+) gold coin</name>
						<script>mud:send("deposit " .. matches[2] .. " g")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([0-9]+) gold coin</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([0-9]+) silver coin</name>
						<script>mud:send("deposit " .. matches[2] .. " s")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([0-9]+) silver coin</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([0-9]+) copper coin</name>
						<script>mud:send("deposit " .. matches[2] .. " c")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([0-9]+) copper coin</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>player enter room</name>
					<script>local matchchar = matches[2]

enteredPortal = enteredPortal or {}

-- clear mtank if not in group

if NyyLIB.mtank ~= nil then
	if not groupList:ingroup(NyyLIB.mtank) then
		NyyLIB.mtank=nil
	end
end

-- visible in room so has not entered portal

if groupList:ingroup(matchchar) then
	enteredPortal[matchchar] = nil

	if groupList:getHP(matchchar) == 0 then
		group:send()
		return
	end
end

-- use @mtank to check hp (send group) when a particular char enters the room

if NyyLIB.mtank ~= nil then
	if NyyLIB.mtank == matchchar then
		group:send()
		return
	end
end

-- don't proceed if npc (= following)

if not inwho(matchchar) then
	return
end

-- update group info if autoheal enabled

if charData:get("autoheal") then
	if groupList:ingroup(matchchar) then
		-- don't send group if moving
		
		if not spell:getMoving() then
			group:send()
		end
		return
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) lumbers in .*</string>
						<string>([A-Za-z]+) enters from .*</string>
						<string>([A-Za-z]+) flies in .*</string>
						<string>([A-Za-z]+) prowls in from .*</string>
						<string>([A-Za-z]+) skulks in from .*</string>
						<string>([A-Za-z]+) sneaks in from .*</string>
						<string>([A-Za-z]+) slowly fades into existence.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Katumi NHC: (H) 'Welcome,</name>
					<script>-- Katumi NHC: (H) 'Welcome, Aminmag. If
local charname = matches[2]

--if getProfile ( whoami() ) == "Nyyrazzilyss" then
--	mud:send("advert")
--end

mud:send("who " .. charname)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Katumi NHC: .* 'Welcome, ([A-Za-z]+).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^([A-Za-z]+) tells you 'version'</name>
					<script>-- send version
mud:send("TELL " .. matches[2] .. " Script version: 011rc2 4/22/2018")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you '@version'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>is dead! R.I.P.</name>
					<script>setEnemy("")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>is dead! R.I.P.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>auction claim</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> +[0-9]+\) +([0-9]+) +.*[A-Za-z]+ +SELLER (.*)</string>
						<string> +[0-9]+\) +([0-9]+) +.*You.*(ENDED|BUYER).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>follow trigger</name>
					<script>-- Whiffle Whark (leaves|swims) ([A-Za-z]+).
-- Thelmor Thoren (leaves|swims) ([A-Za-z]+).

-- reaches vipertongue (7019) at 23 minutes
-- reaches stream (6840) at 40 minutes 
-- reaches south side docks (3782) at 70-80 minutes

-- Keep Whark invis the entire time on north side of docks+

-- north side dock (3773) 81 minutes
-- leaves north side dock at 90 minutes
-- arrives calimshan spice emporium (3561) at 98 minutes
-- leaves spice at 121 minutes

-- invis all the guards at the Black Dragon Gate (3305)
-- invis the werewolf at the Circle of Contest (71711)

-- arrives kopha 137 minutes

-- if werewolf fights druid, invis werewolf again

-- departs kopha at 154 minutes

if matches[2] == toFollow then
	mud:send(matches[4])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) (flies|crawls|leaves|swims) ([A-Za-z]+)[.]$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>EquipProcs</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaSleeves</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your utterance brings about an instantanious mending of</name>
						<script>-- sleeves went off (not charged)
setLabelImage("TiaSleeves", "TiaSleeves-off.png")

timer:set("TiaSleeves", 24*60)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your utterance brings about an instantaneous mending of</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Baatorian</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Smoke begins to pour out of your bracer, swirling around you in a dizzying</name>
						<script>rescuelist:generate()
mud:send("ORDER slaad consent " .. whoami(), false)
sendFollowers()
timer:set("baatorian", 24*60)
baatorian("baatorian", buttons.INIT)
pet_rescue("pet_rescue", buttons.INIT)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Smoke begins to pour out of your bracer, swirling around you in a dizzying</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A gray slaad stops following you.</name>
						<script>if matches[2] == "A gray slaad" then
	if not getHide() then
		mud:send("get all gray")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(.*) stops following you.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are using:</name>
					<script>local nx
local label


for nx=1, #equipment, 1 do
	-- disable folder in equipprocs representing specific item triggers
	disableTrigger(equipment[nx][1])
end

-- hide all equipment icons associated with the item

for nx=0, 20, 1 do
	label=findlabel("1button" .. nx)

	if label ~= nil then
		label:show()
		label:hide()
	end
end

enableTrigger("CaptureWorn")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are using:$</string>
						<string>You aren't wearing anything!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CaptureWorn</name>
					<script>-- {"TiaScale", "a silvered scale of deepest blue hue", 5, "say deeply defend"},
local capture=matches[2]

for nx=1, #equipment, 1 do
	if string.findPattern(matches[2], equipment[nx][2]) then
   		local shortname=equipment[nx][1]
		local buttonnumber = equipment[nx][3]

		enableTrigger(shortname)
		
		-- addbutton(xname, xbar, xid, xlevel, xwidth, xheight)
		addbutton( shortname, 1, buttonnumber, 0)
	end
end

if string.ends(capture, "&gt; ") then
	disableTrigger("CaptureWorn")
	return
end

-- TODO weapon should be set here

-- Remove all (word) patterns: (magic), (illuminating), (glowing), (damaged), (invis)
capture = string.gsub(capture, " %(.+%)", "")

local teststring = string.match(capture, "&lt;primary weapon&gt;     (.*)")

if teststring then
	equip:setWeapon(teststring)
end

local teststring = string.match(capture, "&lt;wielding twohanded&gt; (.*)")

if teststring then
	local checkBow = sqlIsBow(teststring)
		if #checkBow &gt; 0 then
			equip:setWeapon("Bow")
		else
			equip:setWeapon("TwoHand")
		end
end

local teststring = string.match(capture, "&lt;secondary weapon&gt;   (.*)")
if teststring then
	equip:setWeapon("Dual")
end

local teststring = string.match(capture, "&lt;held as shield&gt;     (.*)")

if teststring then
	equip:setWeapon("Shield")
end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(&lt;.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaStaff</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>nimbus flares about your body.  The magic buffers against the glowing sphere,</name>
						<script>-- spell captured
setLabelImage("TiaStaff", "TiaStaff-loaded.png")

charData:set("TiaStaff", "charged")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>nimbus flares about your body.  The magic buffers against the glowing sphere,</string>
							<string>You have no target for your released spell, very dangerous...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You lift an ancient staff of the arch-magi high above your head, calling</name>
						<script>-- spell release
setLabelImage("TiaStaff", "TiaStaff-off.png")

charData:set("TiaStaff", "")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You lift an ancient staff of the arch-magi high above your head, calling</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You whisper quietly to an ancient staff of the arch-magi, hefting it in</name>
						<script>-- spell capture enabled
setLabelImage("TiaStaff", "TiaStaff-waiting.png")

charData:set("TiaStaff", "")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You whisper quietly to an ancient staff of the arch-magi, hefting it in</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaMask</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A set of gem studded tentacle rings glows with a soft light as its charge is fully replenished.</name>
						<script>-- tiamask charged
setLabelImage("TiaMask", "TiaMask-charged.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A set of gem studded tentacle rings glows with a soft light as its charge is fully replenished.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The three ioun stones of a set of gem studded tentacle rings glow</name>
						<script>-- mask  invoked
setLabelImage("TiaMask", "TiaMask-on.png")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The three ioun stones of a set of gem studded tentacle rings glow</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaBane</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A ([A-Za-z]+) notch appears along the handle of your blade.</name>
						<script>if matches[2] == "single" then
	charData:set("banecharges", 1)
elseif matches[2] == "second" then
	charData:set("banecharges", 2)
elseif matches[2] == "third" then
	charData:set("banecharges", 3)
elseif matches[2] == "fourth" then
	charData:set("banecharges", 4)
end

TiaBane("TiaBane", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A ([A-Za-z]+) notch appears along the handle of your blade.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>As you shout to the infernal stiletto of Bane, the weapon begins to glow</name>
						<script>-- bane - dragonstrike

local label=findlabel("TiaBane")

charData:set("banecharges", 0)

if label ~= nil then
	TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>As you shout to the infernal stiletto of Bane, the weapon begins to glow</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The handle of your blade glows brightly.</name>
						<script>local label=findlabel("TiaBane")
charData:set("banecharges", 5)

if label ~= nil then
	TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The handle of your blade glows brightly.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>see the hand of Bane himself emerge from the blade of your stiletto and point at</name>
						<script>-- bane - blind

local label=findlabel("TiaBane")
charData:set("banecharges", charData:get("banecharges")-3)

if label ~= nil then
	TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>see the hand of Bane himself emerge from the blade of your stiletto and point at</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>around the blade before the stiletto flies back to your hand.</name>
						<script>-- bane - slow

local label=findlabel("TiaBane")
charData:set("banecharges", charData:get("banecharges")-2)

if label ~= nil then
	TiaBane("TiaBane", buttons.UPDATE)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>around the blade before the stiletto flies back to your hand.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>As you whisper under your breath your blade makes a faint noise, and shudders</name>
						<script>-- failed

local label=findlabel("TiaBane")
charData:set("banecharges", 0)

if label ~= nil then
	TiaBane("TiaBane", buttons.UPDATE)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>As you whisper under your breath your blade makes a faint noise, and shudders</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>the infernal stiletto of bane glows for a brief second before poison begins to drip down one of it's edges.</name>
						<script>local label=findlabel("TiaBane")
charData:set("banecharges", charData:get("banecharges")-1)

if label ~= nil then
	TiaBane("TiaBane", buttons.UPDATE)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>the infernal stiletto of bane glows for a brief second before poison begins to drip down one of it's edges.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The frenzy begins to stir in your heart anew!</name>
					<script>-- grin recharged
setLabelImage("FrenziedGrin", "FrenziedGrin-on.png")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The frenzy begins to stir in your heart anew!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you whisper a prayer to the heavens, you are quickly</name>
					<script>setLabelImage("TiaSandals", "TiaSandals-off.png")
timer:set("TiaSandals", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you whisper a prayer to the heavens, you are quickly</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The corner of your mouth spasms with bloodthirsty frenzy!</name>
					<script>setLabelImage("FrenziedGrin", "FrenziedGrin-off.png")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The corner of your mouth spasms with bloodthirsty frenzy!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you whisper to yourself the words of power, you are caught up</name>
					<script>setLabelImage("TiaLoop", "TiaLoop-off.png")
timer:set("TiaLoop", 24*60)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you whisper to yourself the words of power, you are caught up</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You raise your hands above your head, whispering words of power to your sleeves.</name>
					<script>-- haste proc vermillion sleeves

--setLabelImage("VermSleeves", "equipVerm-active.png")

timer:set("VermSleeves", 24*60)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You raise your hands above your head, whispering words of power to your sleeves.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You call upon the magics contained within your volant band</name>
					<script>-- volance on

setLabelImage("TiaVolance", "TiaVolance-on.png")
timer:set("TiaVolance", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You call upon the magics contained within your volant band</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your entire body begins to slow down.  All your movements become sluggish as total physical</name>
					<script>-- vermillion sleeves - drop</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your entire body begins to slow down.  All your movements become sluggish as total physical</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>All of your mirror images have been destroyed!</name>
					<script>-- mirrors dropped
if findlabel("TiaMask") ~= nil then
	setLabelImage("TiaMask", "TiaMask-off.png")
end

-- volance

if findlabel("TiaVolance") ~= nil then
	setLabelImage("TiaVolance", "TiaVolance-off.png")
end

buff:del(whoami(), "mirror_image" )

sound("86324__timbre__smashing-1b.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?All of your mirror images have been destroyed!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TiaWarmaul</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your %w bludgeon</name>
						<script>-- Your powerful bludgeon barely wounds Corland Deepforge.
-- the warmaul of celestial glory seems to hum with energy as it connects with
-- You critically wound Shalyssa Lurialar with a mighty bludgeon!


-- #TRIGGER {{You crushed|Your mighty bludgeon|Your strong bludgeon|Your average bludgeon|Your powerful bludgeon|Your massive bludgeon}} {#add wmhits 1;#STATUS Hit Count: @wmhits}


NyyLIB.warmaul = NyyLIB.warmaul or 0
NyyLIB.warmaul = NyyLIB.warmaul + 1

TiaWarmaul("TiaWarmaul", buttons.UPDATE)

echoDebug("&lt;red&gt; (" .. NyyLIB.warmaul .. ")")

if NyyLIB.warmaul &gt; 12 then
	local tmpvar=charData:get("warmaul")

	if tmpvar == "aid" then
		mud:send("aid")
	elseif tmpvar == "restore" then
		mud:send("restore")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your .* bludgeon .*</string>
							<string>You critically wound .* with a mighty bludgeon!</string>
							<string>.* staggers from your .* bludgeon!</string>
							<string>You crushed</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You swing the warmaul of celestial glory in a mighty arc, crushing into</name>
						<script>-- You swing the warmaul of celestial glory in a mighty arc, colliding solidly (dead)
-- You swing the warmaul of celestial glory in a mighty arc, crushing into (damaged)
cecho("&lt;red&gt; [Warmaul proc: " .. NyyLIB.warmaul .. "]\n")

NyyLIB.warmaul=-1

TiaWarmaul("TiaWarmaul", buttons.UPDATE)
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You swing the warmaul of celestial glory in a mighty arc, colliding solidly</string>
							<string>^under the impact.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You mutter under your breath to your the warmaul of celestial glory and watch</name>
						<script>echoDebug("[Warmaul called proc at " .. NyyLIB.warmaul .. "]\n")

NyyLIB.warmaul=0

TiaWarmaul("TiaWarmaul", buttons.UPDATE)

group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You mutter under your breath to your the warmaul of celestial glory and watch</string>
							<string>You call upon your deity to restore your health!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>the warmaul of celestial glory from the glowing corpse.</name>
						<script>NyyLIB.warmaul=0

TiaWarmaul("TiaWarmaul", buttons.UPDATE)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>the warmaul of celestial glory from the glowing corpse.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your manacle shoots out visible strands of magic which interlace</name>
					<script>--
setLabelImage("TiaManacle", "TiaManacle-off.png")

timer:set("TiaManacle", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your manacle shoots out visible strands of magic which interlace</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You scream in pain as your wrists are sliced open within your own gauntlets!</name>
					<script>-- You scream in pain as your wrists are sliced open within your own gauntlets!
-- As the nasty spikes on your gauntlets tear into the flesh of your opponent     &lt;hitall&gt;

mud:send("att", false)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You scream in pain as your wrists are sliced open within your own gauntlets!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You feel yourself growing, in strength and size as magic fills you.  Your body gains a</name>
					<script>-- supple girdle
timer:set("SuppleGirdle", 24*60*3)
sound("105308__kovrov__rumble.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You feel yourself growing, in strength and size as magic fills you.  Your body gains a</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You swirl your cloak around and blend into the background.</name>
					<script>-- warder cloak
timer:set("TiaWarder", 24*60)
setHide(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You swirl your cloak around and blend into the background.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you say 'blend' to a dark gray cloak with a rune embroidered hem,</name>
					<script>-- warder cloak still isn't charged
if not timer:get("TiaWarder") then
	timer:set("TiaWarder", 2*60)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you say 'blend' to a dark gray cloak with a rune embroidered hem,</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>hitting shield</name>
					<script>-- You shiver from unnatural cold.
-- You are burned as you hit a half-dragon kobold!

-- proc globe if not globed or warded and &lt; 80% hp

if not buff:get("globe_of_invulnerability") and not buff:get("elemental_ward") then
	if prompt:get("hp") &lt; (.80 * prompt:get("maxhp") ) then
		-- fighters loop (warrior)
		if isIconActive("TiaLoop") and timer:get("TiaLoop") == nil then
			TiaLoop("TiaLoop", buttons.CLICK)
		end
	end
	
	if checkMask("rog") then
		-- silvered scale (rogue)
		if isIconActive("TiaScale") and timer:get("TiaScale") == nil then
			TiaScale("TiaScale", buttons.CLICK)
		end
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You shiver from unnatural cold.</string>
						<string>You are burned as you hit</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As Ozay takes a viscious wound, the mighty scepter of valhalla begins to hum</name>
					<script>-- As Ofug takes a viscious wound, the mighty scepter of valhalla begins to hum

-- valhalla blur
if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "blur", 570)
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As ([A-Za-z]+) takes a viscious wound, the mighty scepter of valhalla begins to hum</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Upon being struck, a mirror image of Adud shatters into a million particles of light!</name>
					<script>if matches[2] == whoami() then
	sound("86324__timbre__smashing-1a.wav")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?Upon being struck, a mirror image of ([A-za-z]+) shatters into a million particles of light!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As the magic of your bracers saturates your body, they begin</name>
					<script>-- As the magic of your bracers saturates your body, they begin

mud:send("GSAY [TIMESTOP UP]")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As the magic of your bracers saturates your body, they begin</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>As you invoke your deep blue silvered scale, a transluscent field</name>
					<script>-- silvered scale

setLabelImage("TiaScale", "TiaScale-off.png")
timer:set("TiaScale", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>As you invoke your deep blue silvered scale, a transluscent field</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your cincture glows brightly for a moment while the magics tied to</name>
					<script>-- cincture

setLabelImage("TiaCincture", "TiaCincture-off.png")
timer:set("TiaCincture", 24*60)

buff:set(whoami(), "displacement", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your cincture glows brightly for a moment while the magics tied to</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You begin to speak in a devilish tongue, grinding out</name>
					<script>-- gelugon claws
setLabelImage("TiaClaws", "TiaClaws-off.png")

timer:set("TiaClaws", 12*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You begin to speak in a devilish tongue, grinding out</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You kneel to the ground, wrapping your cloak about your body, chanting softly.</name>
					<script>-- dcult robes

setLabelImage("DragonCult", "DragonCult-off.png")

timer:set("DragonCult", 3*24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You kneel to the ground, wrapping your cloak about your body, chanting softly.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You wear</name>
					<script>-- You wear a dark gray cloak with a rune embroidered hem about your body.
-- You clasp a luminous cincture of nightfallen stars about your waist.
-- You wear a silvered scale of deepest blue hue over your eyes.
-- You place a smoking bracer forged from Baatorian steel around your left wrist.
-- You cover your arms with the quickly pulsing bracers of time.
-- You place the mystical boots of stability on your feet.
-- You duck your head and place a thick titanium band of volance around your neck.
-- You place a fighter's loop of sorcerous ability on your left ring finger.
-- You cover your face with a set of gem studded tentacle rings.
-- You wear the wickedly sharp claws of a gelugon devil on your hands.

local equipinfo = equipment:getByLongName( matches[2])

-- create button if equipment worn is proc'ing

if equipinfo ~= nil then
		enableTrigger(equipinfo[1])
		addbutton( equipinfo[1], 1, equipinfo[3], 0)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You wear (.*) about your body[.]</string>
						<string>You clasp (.*) about your waist[.]</string>
						<string>You wear (.*) over your eyes[.]</string>
						<string>You place (.*) around your .*</string>
						<string>You cover your arms with (.*)[.]</string>
						<string>You place (.*) on your feet[.]</string>
						<string>You duck your head and place (.*) around your neck[.]</string>
						<string>You place (.*) on your .*</string>
						<string>You cover your face with (.*)[.]</string>
						<string>You wear (.*) on your hands[.]</string>
						<string>You wield (.*)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You stop using</name>
					<script>-- You stop using a supple leather girdle with golden studs.

-- TODO - regex conflict with magi staff

local equipinfo = equipment:getByLongName( matches[2])
local checkBow = sqlIsBow(matches[2])
local check2H = sqlIs2H(matches[2])

-- remove button if present

if equipinfo ~= nil then
	disableTrigger(equipinfo[1])

	local label=findlabel("1button" .. equipinfo[3])

	if label ~= nil then
		label:show()
		label:hide()
	end
end

-- was the item removed a longbow?

if checkMask("ran") then
	
	if #checkBow &gt; 0 then
		-- bow was just removed. switch to melee buttons
		equip:setWeapon(matches[2])
	end
end

-- TODO paladin: was the item removed a 2h sword

if checkMask("pal") then
	if #check2H &gt; 0 then
		equip:setWeapon(matches[2])
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You stop using (.*)[.]$</string>
						<string>You are zapped by (.*) and instantly release it.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You hold your ancient staff high in the air, and with a deathly</name>
					<script>-- ashen staff

setLabelImage("AshenStaff", "AshenStaff-off.png")
timer:set("AshenStaff", 24*60)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You hold your ancient staff high in the air, and with a deathly </string>
						<string>As you say 'rot' to an ancient staff of the ashen soul,</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You wield (.*)[.]</name>
					<script>-- Set wielded weapon, change skill buttons if needed

equip:setWeapon(matches[2])


-- Wielding, but weapon does not exist in katumi

if equip:getWeapon() == "None" then
	if checkMask("ran") then
		equip:setWeapon("Dual")
	end
	
	if checkMask("pal") or checkMask("blk") or checkMask("war") then
		equip:setWeapon("Shield")
	end
end

-- Switch buttons if ranger, paladin, blackguard, warrior

if checkMask("war") then
	initWar()
end


if checkMask("ran") then
	initRan()
end

if checkMask("pal") then
	initPal()
end

if checkMask("blk") then
	initBlk()
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You wield (.*)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BuffClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>BuffTriggers</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>(.*)'s skin seems to turn to stone.</name>
						<script>if matches[2] == "You" then
	buff:set(whoami(), "stoneskin")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "stoneskin")
	end
end	
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*)'s skin seems to turn to stone.</string>
							<string>(You) feel your skin harden to stone.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>^Your flesh loses its stony texture.$</name>
						<script>mud:send("gsay " .. charData:get("stoneout", true) )

buff:del(whoami(), "stoneskin")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your flesh loses its stony texture.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your form begins to blur!</name>
						<script>if matches[2] == "Your" then
	buff:set(whoami(), "blur")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "blur")
	end
end	
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(Your) form begins to blur!$</string>
							<string>([A-Za-z]+)'s form becomes blurred and difficult to make out!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel your heart start to race REALLY FAST!</name>
						<script>-- The spectre of a human noble starts to move with uncanny speed!

if matches[2] == "You" then
	buff:set(whoami(), "haste")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "haste")
	else
		-- pet
		local name=pet:member(matches[2])

		if name then
			buff:set(name, "haste")
		end
	end
end	</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) feel your heart start to race REALLY FAST!$</string>
							<string>(.*) starts to move with uncanny speed!$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You begin to shimmer.</name>
						<script>-- The spectre of a human noble begins to shimmer.

if matches[2] == "You" then
	buff:set(whoami(), "globe_of_invulnerability")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "globe_of_invulnerability")
	else
		-- pet
		local name=pet:member(matches[2])

		if name then
			buff:set(name, "globe_of_invulnerability")
		end
	end
end	</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) begin to shimmer.$</string>
							<string>(.*) begins to shimmer.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel your skin transform into dragon scales.</name>
						<script>if matches[2] == "You" then
	buff:set(whoami(), "dragonscales")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "dragonscales")
	end
end	</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) feel your skin transform into dragon scales.</string>
							<string>([A-za-z]+)'s skin transforms into hard-plated dragon scales.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The world slows down around you!</name>
						<script>-- timestop

if checkMask("priest") then
	setLabelImage("TiaBracers", "TiaBracers-on.png")
else
	setLabelImage("time_stop", "time_stop-active.png")
end

buff:set(whoami(), "time_stop")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world slows down around you!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Time speeds up suddenly!</name>
						<script>buff:del(whoami(), "time_stop")

if checkMask("priest") then
	setLabelImage("TiaBracers", "TiaBracers-off.png")
else
	if charData:get("autots") then
		setLabelImage("time_stop", "time_stop-on.png")
	else
		setLabelImage("time_stop", "time_stop-off.png")
	end

	PopulateTimestop()
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Time speeds up suddenly!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your form stops blurring.</name>
						<script>if matches[2] == "Your" then
	mud:send("gsay " .. charData:get("blurout", true) )
	buff:del(whoami(), "blur")
else
	if groupList:ingroup(matches[2]) then
		buff:del(matches[2], "blur")	
	end
end	</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(Your) form stops blurring.</string>
							<string>([A-Za-z]+) group-says '.*(blur|Blur|BLUR) .+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your dragon scales melt back into your regular flesh.</name>
						<script>mud:send("gsay " .. charData:get("scaleout", true) )

buff:del(whoami(), "dragonscales")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your dragon scales melt back into your regular flesh.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*globe.*'</name>
						<script>if groupList:ingroup(matches[2]) then
	buff:del(matches[2], "globe_of_invulnerability", "x")	
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(globe|Globe|GLOBE).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*haste.*'</name>
						<script>if groupList:ingroup(matches[2]) then
	buff:del(matches[2], "haste", "x")	
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(haste|HASTE|Haste).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*scale.*'</name>
						<script>if groupList:ingroup(matches[2]) then
	buff:del(matches[2], "dragonscales", "x")	
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(scale|Scale|SCALE).*'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*stone.*'</name>
						<script>local var=buff:get("stoneskin", matches[2])

if not var then
	return
end

if var &gt; 220 then
	return
end

if groupList:ingroup(matches[2]) then
	buff:del(matches[2], "stoneskin", "x")	
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(stone|Stone|STONE).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*vitality.*'</name>
						<script>if groupList:ingroup(matches[2]) then
	-- display("removing vitality from " .. matches[2])


	buff:del(matches[2], "vitality", "x")	
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(vit|Vit|VIT).+'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The world speeds up around you.</name>
						<script>mud:send("gsay " .. charData:get("hasteout", true) )

buff:del(whoami(), "haste")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world speeds up around you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your globe shimmers, and fades into the air.</name>
						<script>mud:send("gsay " .. charData:get("globeout", true) )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your globe shimmers, and fades into the air.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your vitality drains away.</name>
						<script>buff:del(whoami(), "vitality")	
mud:send("gsay " .. charData:get("vitout", true) )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your vitality drains away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are suddenly filled with knowledge of battle tactics!</name>
						<script>buff:set(whoami(), "combatmind", 600)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are suddenly filled with knowledge of battle tactics!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel less wooden.</name>
						<script>mud:send("gsay " .. charData:get("barkout", true) )

buff:del(whoami(), "barkskin")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel less wooden.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your magic armor fades away.</name>
						<script>if charData:get("level") &lt; 30 then
	mud:send("gsay [[ ARMOR OUT ]]" )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your magic armor fades away.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The elemental ward protecting you shudders and disappears.</name>
						<script>-- elemental ward      

mud:send("gsay [[ WARD OUT ]]" )
buff:del(whoami(), "elemental_ward")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The elemental ward protecting you shudders and disappears.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>image of a Valkyrie appears to partially conceal and protect you.</name>
						<script>-- valhalla blur
buff:set(whoami(), "blur", 600 )
--mud:send("gsay [[ VALHALLA UP ]]" )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>image of a Valkyrie appears to partially conceal and protect you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Invisible things vanish again.</name>
						<script>mud:send("gsay &lt;&lt; DET INVIS OUT &gt;&gt;")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Invisible things vanish again.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A crackling purple nimbus of light pops into being around your arms and weapons.</name>
						<script>-- ward

-- Peri begins to glow with an eerie purple light.


if matches[2] == "your" then
	buff:set(whoami(), "elemental_ward")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "elemental_ward", 240)
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A crackling purple nimbus of light pops into being around (your) arms and weapons.</string>
							<string>([A-Za-z]+) begins to glow with an eerie purple light.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body shimmers and sheds its elemental form, returning to normal.</name>
						<script>mud:send("gsay [[ ELEMENTAL EMBODIMENT OUT ]]" )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body shimmers and sheds its elemental form, returning to normal.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body becomes infused with the divine power of your god!</name>
						<script>-- divine power on</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body becomes infused with the divine power of your god!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wave of exhaustion washes over you as your divine power fades.</name>
						<script>-- divine power off</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wave of exhaustion washes over you as your divine power fades.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The feeling of power fades as your deity departs.</name>
						<script>-- righteous might off</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The feeling of power fades as your deity departs.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Tatris is infused with vitality.</name>
						<script>if matches[2] == "You" then
	buff:set(whoami(), "vitality")
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "vitality")
	end
end

group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) is infused with vitality.</string>
							<string>(You) feel vitalized.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Onut's form is displaced.</name>
						<script>if matches[2] == "Your" then
	buff:set(whoami(), "displacement", 1440)
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "displacement", 1440)
	end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+)'s form is displaced.</string>
							<string>(Your) form is displaced!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>([A-Za-z]+) group-says '.*(displacement|DISPLACEMENT).+'</name>
						<script>if matches[2] == "Your" then
	mud:send("gsay " .. charData:get("displaceout", true) )
	buff:del(whoami(), "displacement", "x")
else
	if groupList:ingroup(matches[2]) then
		buff:del(matches[2], "displacement", "x")	
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says '.*(Displacement|displacement|DISPLACEMENT|DISPLACE).+'</string>
							<string>(Your) displaced form snaps back to your physical location!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Several mirror images of you pop into existence at your side!</name>
						<script>buff:set(whoami(), "mirror_image", 31*60 )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Several mirror images of you pop into existence at your side!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>earth embo</name>
						<script>-- Hetat's form begins to harden and solidify as he is transformed into an earth elemental.
-- Hirple's form begins to harden and solidify as he is transformed into an earth elemental.
-- "elemental_earth_embodiment"

if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "elemental_earth_embodiment", 600)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+)'s form begins to harden and solidify as .* is transformed into an earth elemental.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The ancestral spirits depart, dissipating your shield.</name>
						<script>-- remove ancestral shield
buff:del(whoami(), "ancestral_shield", "x")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The ancestral spirits depart, dissipating your shield.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A shimmering spiritual shield hovers over you.</name>
						<script>-- add ancestral shield
buff:set(whoami(), "ancestral_shield", 30)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A shimmering spiritual shield hovers over you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel somewhat safer from things that go bump in the night.</name>
						<script>-- pfu
buff:set(whoami(), "protection_from_undead", 360)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel somewhat safer from things that go bump in the night.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Undead love you once more.</name>
						<script>-- pfu
buff:del(whoami(), "protection_from_undead", "x")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Undead love you once more.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A doppelganger of Bombum snaps into being at his side!</name>
						<script>-- add buff
if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "doppleganger", 1000)
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A doppelganger of (.*) snaps into being at .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Caceshen is now protected from undead!</name>
						<script>--
-- Protection From Undead 6min
-- buff:set(whoami(), "protection_from_undead", 360)

if matches[2] == "You" then
	--
else
	if groupList:ingroup(matches[2]) then
		buff:set(matches[2], "protection_from_undead", 360)
	end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is now protected from undead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your blood burns with the fiery power of death!</name>
						<script>-- death pact
buff:set(whoami(), "death_pact", 3*60+52)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your blood burns with the fiery power of death!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The wraith of a human noble's hand starts to glow RED as blood.</name>
						<script>-- vampiric touch
if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "vampiric_touch", 13*60)
else
	-- pet
	local name=pet:member(matches[2])

	if name then
		buff:set(name, "vampiric_touch", 13*60)
	end
end
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*)'s hand starts to glow RED as blood.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The wight of a human noble appears to gain power from a sudden deadly chill around it.</name>
						<script>-- heal undead
sendFollowers()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) appears to gain power from a sudden deadly chill around it.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The wraith of a human noble is surrounded by an aura of deadly cold!</name>
						<script>-- coldshield
if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "coldshield", 2*60)
else
	-- pet
	local name=pet:member(matches[2])

	if name then
		buff:set(name, "coldshield", 2*60)
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is surrounded by an aura of deadly cold!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The spectre of a human noble is now protected from undead!</name>
						<script>-- protection from undead
if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "protection_from_undead", 6*60+2)
else
	-- pet
	local name=pet:member(matches[2])

	if name then
		buff:set(name, "protection_from_undead", 6*60+2)
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is now protected from undead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel natures blessing wrap around you like a safe, warm blanket.</name>
						<script>-- natures blessing

buff:set(whoami(), "natures_blessing", 13*60) -- 30 seconds extra</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel natures blessing wrap around you like a safe, warm blanket.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PenaltyTriggers</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>penalty status</name>
						<script>-- should set status, not just send status

-- Azora is blinded by the burning sands!
-- Vomicopol tries to cleanse your body of impurities...
-- A carnivorous vine's pollen makes your eyes burn and water!  You can't see!

-- Vitality                  (  7:18)   sleep                     ( 54:00)   

if matches[2] == "your" or matches[2] == "Your" then
	sendStatus()
else
	if groupList:ingroup(matches[2]) then
		sendStatus(matches[2])
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) body turns to stone as a petralisk gazer stares .*</string>
							<string>([A-Za-z]+) ceases to move.. still and lifeless.</string>
							<string>([A-Za-z]+) suddenly looks speechless!</string>
							<string>([A-Za-z]+) seems to be blinded!</string>
							<string>.* cleanse ([A-Za-z]+)'s body of impurities...</string>
							<string>.* tries to dispel ([A-Za-z]+)'s magic!</string>
							<string>Some of (your) magic has been dispelled!</string>
							<string>([A-Za-z]+) body turns to stone as the dracolisk stares at .*</string>
							<string>([A-Za-z]+) staggers about blindly!</string>
							<string>([A-Za-z]+) goes to sleep.</string>
							<string>([A-Za-z]+) is blinded by .*</string>
							<string>([A-Za-z]+)  group-says '&lt;&lt; BLIND! &gt;&gt;'</string>
							<string>(Your) body turns to stone as a petralisk gazer stares at you!</string>
							<string>An elite gelugon's spear erupts in a spray of frost as he plunges it through ([A-Za-z]+)!</string>
							<string>([A-Za-z]+) is blinded by the deep black shadows!</string>
							<string>.* tries to cleanse (your) body of impurities...</string>
							<string>.* pollen makes (your) eyes burn and water!  You can't see!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are suddenly silenced!</name>
						<script>sendStatus()
spell:clear()

-- only dispel magic if caster or bard
if checkMask("caster") or checkMask("singer") then
	mud:send("quaff disp hole")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are suddenly silenced!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel your blood freezing in your veins!</name>
						<script>mud:send("gsay " .. whoami() .. "  &lt;&lt; FREEZING &gt;&gt; " .. prompt:get("hp") .. "/" .. prompt:get("maxhp") )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel your blood freezing in your veins!</string>
							<string>The poison burns in your veins, and you feel weaker.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You have been blinded!</name>
						<script>mud:send("gsay &lt;&lt; BLIND! &gt;&gt;" )

buff:set(whoami(), "blind", 600)

sendStatus()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^.*You have been blinded!$</string>
							<string>^You are blinded!$</string>
							<string>You are blinded.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Lobbole's vision is restored!</name>
						<script>buff:del(matches[2], "blind")
buff:del(matches[2], "blindness")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+)'s vision is restored!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your vision returns!</name>
						<script>-- chkstat


-- clear blind
buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")

group:send()

mud:send("@chkstat")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your vision returns!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You can see normally again!</name>
						<script>buff:del(whoami(), "blind")
buff:del(whoami(), "blindness")

group:send()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can see normally again!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You feel able to speak again!</name>
						<script>buff:del(whoami(), "silence")
buff:del(whoami(), "silence_person")
nomagic=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You feel able to speak again!</string>
							<string>You feel able to speak again.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The world stops spinning.</name>
						<script>-- no longer stunned
buff:del(whoami(), "stun")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The world stops spinning.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Lilpekal looks MUCH healthier.</name>
						<script>-- Lilpekal looks MUCH healthier.
-- Misi looks MUCH healthier.

-- cure poison/venom
buff:del(matches[2], "poison")
buff:del(matches[2], "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) looks MUCH healthier.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A warm flush runs throughout your body as the toxins are neutralized.</name>
						<script>buff:del(whoami(), "poison")
buff:del(whoami(), "venom")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A warm flush runs throughout your body as the toxins are neutralized.</string>
							<string>You feel much healthier as the toxins within are neutralized.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your body becomes like stone as the paralyzation takes effect.</name>
						<script>-- You can't!  You're paralyzed to the bone.

buff:set(whoami(), "major_paralysis", 600)
spell:clear()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your body becomes like stone as the paralyzation takes effect.</string>
							<string>A carnivorous vine reaches up and wraps itself about you, making it difficult to move, or even breathe!</string>
							<string>You wait mindlessly for direction from your master.</string>
							<string>Your body becomes rigid as the paralyzation takes effect.</string>
							<string>You remain paralyzed and can't do a thing to defend yourself...</string>
							<string>tail radiates freezing cold, causing your bones to lock up.</string>
							<string>leaving you near to death, numb, and barely concious.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are no longer attractive to pigeons.</name>
						<script>-- remove para
buff:set(whoami(), "major_paralysis", nil)
buff:set(whoami(), "minor_paralysis", nil)

sendStatus()

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are no longer attractive to pigeons.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>add venom</name>
						<script>-- Lilabipple writhes in agony.
--pupilless eyes glow bright red as its tail spur sinks into Kerishai's
--Kerishai shudders in pain, and looks very pale.


if groupList:ingroup(matches[2]) then
	buff:set(matches[2], "venom", 600)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) writhes in agony.</string>
							<string>(.*) shudders in pain, and looks very pale.</string>
							<string>pupilless eyes glow bright red as its tail spur sinks into (.*)i's</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You can't see a thing, you're blinded!</name>
						<script>buff:set(whoami(), "blind", 600)
look:set(nil)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You can't see a thing, you're blinded!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your soul is transported to The Fugue Plane as your crumbling body succumbs</name>
					<script>--Your soul is transported to The Fugue Plane as your crumbling body succumbs

sound("165331__ani-music__tubular-bell-of-death.wav")

NyyLIB.active=nil

-- echo last known room information here

local lastRoom = map:getRoom()

display( lastRoom )


-- set room to fugue
map:setRoom(93848)
centerview( map:getRoom() )

-- Remove all buffs on death
buff:del(whoami())

NyyLIB.escapedir = nil
NyyLIB.roguereturn = nil

-- Reset size
charData:set("bodysize", whosize() )
setLabelImage("mysizeDisplay", "size" .. charData:get("bodysize") .. ".png")

-- Clear train mem variable

NyyLIB.castertrain=nil

-- Clear memorized spells

resetSpellCount()

-- assign an arbitrary memcount

charData:set("memcount", 25)

-- Not casting

spell:clear()

group:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Your soul is transported to The Fugue Plane as your crumbling body succumbs.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Capture powername</name>
					<script>NyyLIB.powersname= matches[2]:trim()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Name             : ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Change powers durations</name>
					<script>--	 armor=1200, 
--	 haste=324, 
--	 dragonscales=360,
--	 blur=202,	
--	 globe_of_invulnerability=324,
--	 displace=1200,
--	 time_stop=175,
--	 stoneskin=240,
--	 elemental_ward=180


-- Target Effect    : Add globe of invulnerability for 4 minutes 


-- Target Effect    : Modify hitpoints by 254 for 8 minutes 40 seconds 2 pulses  
-- vit - will also show on other powers
--local num

--num = tonumber(matches[2])*60 + tonumber(matches[3])

local num=0

if tonumber(matches[2]) then
	num=tonumber(matches[2])*60
end

if tonumber(matches[3]) then
	num=num+ tonumber(matches[3])
end

if NyyLIB.powersname ~= nil then
	power:set( to_snake(NyyLIB.powersname), num )
else
	echo("Powersname is nil\n")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Target Effect    : Modify hitpoints by [0-9]+ for ([0-9]+) minutes ([0-9]+) seconds ([0-9]+) pulses</string>
						<string>Target Effect    : Modify hitpoints by [0-9]+ for ([0-9]+) minutes ([0-9]+) seconds </string>
						<string>Target Effect    : Add globe of invulnerability for ([0-9]+) minutes ?([0-9]+)? ?(seconds)?</string>
						<string>Target Effect    : Add haste for ([0-9]+) minutes ([0-9]+) seconds</string>
						<string>Self Effect      : Add time stop for ([0-9]+) minutes ([0-9]+) seconds</string>
						<string>Target Effect    : Modify target hitroll by -33 for ([0-9]+) minutes ([0-9]+) seconds</string>
						<string>Target Effect    : Add stoneskin for ([0-9]+) minutes ?([0-9]+)? ?(seconds)?</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>StatusGroup</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Status of Bonble</name>
					<script>sendingStatus = false

local charname = matches[2]

-- pet:isNamed(xnamelist)

if pet:isNamed(charname) then
	charname = pet:isNamed(charname)
end

if groupList:ingroup(charname) or pet:isNamed(charname) then
	NyyLIB.statuschar = charname

	local duration=buff:get("healing_aura", charname)

	-- include healing aura
	if duration then
		buff:del(charname)
		buff:set(charname, "healing_aura", duration)
	else
		buff:del(charname)
	end
end

if not showstatus then
	enableTrigger("gagstatus")
end

enableTrigger("endstatusgag")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Status of (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capturestatus</name>
					<script>local min, sec, dur

--display(NyyLIB.statuschar)

if NyyLIB.statuschar ~= "" then
	min=tonumber(matches[3])
	sec=tonumber(matches[4])

	if sec == 0 then
		dur=min*60+NyyLIB.ticktimer
	else
		dur=min*60+sec
	end

	-- TODO
	-- Nyth Flare                (  0:24)
	--if to_snake(matches[2]) == "nyth_flare" then
		-- blind
	--end

	buff:set(NyyLIB.statuschar, to_snake(matches[2]), dur)

	if matches[5] ~= nil then
		min=tonumber(matches[7])
		sec=tonumber(matches[8])

		if sec == 0 then
			dur=min*60+NyyLIB.ticktimer
		else
			dur=min*60+sec
		end

		buff:set(NyyLIB.statuschar, to_snake(matches[6]), dur)

	end

	if not showstatus then
		eraseLine()
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z ]+) +\([ ]*([0-9]+):([0-9]+)\)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endstatusgag</name>
					<script>-- this trigger must be located above the gagstatus trigger

disableTrigger("gagstatus")
disableTrigger("endstatusgag")
showstatus=false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gagstatus</name>
					<script>--
eraseLine()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>effects</name>
					<script>--Status of Innanin
---------------------------------------------------------------------------

--Effects
---------------------------------------------------------------------------
--haste                     hide                      infravision               
--no summon                 protection from evil      sense life                
--slow poison               sneak          </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Effects$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>effect: hide</name>
					<script>setHide(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>   hide                      </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>There are no active status effects.</name>
					<script>if command == "STATUS " then
	buff:del(whoami())
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>There are no active status effects.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>SplitClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>lootlist</name>
					<script>-- add to list

table.insert(NyyLIB.groupitems, 1, matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>[ ]+(.+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The following items exist in the group cache for</name>
					<script>NyyLIB.groupitems = {}
enableTrigger("lootlist")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The following items exist in the group cache for</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>acceptbid</name>
					<script>-- need to improve itename capture (bid on, please, no bid, etc)

local biditem=string.lower(string.trim(matches[3]))

-- confirm valid bidder
for nx=1, #NyyLIB.validbidders, 1 do
	if NyyLIB.validbidders[nx]:lower() ==
		 string.lower(matches[2]) then
		expandAlias("@bid add " .. matches[2] .. " " .. biditem, false)
		return
	end
end


</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) tells you 'bid (.*)'</string>
						<string>([A-Za-z]+) tells you '(abstain)'</string>
						<string>([A-Za-z]+) tells you '([A-Za-z]+)'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="yes">
					<name>acceptdice</name>
					<script>local dice, name

name = multimatches[1][2]
dice = multimatches[5][4]:trim()

if name == "You" then
	name = whoami()
end

if NyyLIB.trackbid ~= nil then
	if NyyLIB.trackbid[name] == 0 then
		expandAlias("@adddice " .. name .. " " .. dice, false)
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile>C:/Users/Chris/.config/mudlet/profiles/toril 006/NyyLIB.006/beep.wav</mSoundFile>
					<colorTriggerFgColor>#0000ff</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) group.* '</string>
						<string>FG13BG2</string>
						<string>I've rolled a 100 sided dice 1 times, the total result is:</string>
						<string>FG9BG0</string>
						<string>([ 0-9]+)'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>6</integer>
						<integer>0</integer>
						<integer>6</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Mounted</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your mount rises up on its hind legs at lets forth a baleful howl!</name>
					<script>timer:set("howlcd", 7)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your mount rises up on its hind legs at lets forth a baleful howl!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your wolf refuses to obey your command!</name>
					<script>mud:send("howl")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your wolf refuses to obey your command!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>A massive snarling dire wolf answers your summons!</name>
					<script>mount:set( "mount" )</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A massive snarling dire (wolf) answers your summons!</string>
						<string>A hell (hound) answers your summons!</string>
						<string>A heavy (warhorse) answers your summons!</string>
						<string>A zealous (griffon) answers your summons!</string>
						<string>answers your summons!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your mount misses Elaith Waterstill with its charge!</name>
					<script>setBashing(false)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your mount misses .* with its charge!</string>
						<string>Your mount charges .* and .*</string>
						<string>Your mount refuses to trample!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Remount in combat</name>
					<script>--display("set dismounted")

dismounted = true

if mount:get() then
  mud:send("mount")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You lose your balance and are dismounted.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>summon return</name>
					<script>mount:set(nil)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your mount gently nuzzles your hand before trotting away and disappearing.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>mount</name>
					<script>-- You climb on and ride A heavy warhorse.
-- You climb on and ride a hell hound.
-- You skillfully climb on and ride A heavy warhorse in the midst of battle.
-- You climb on and ride a pack pony.

if not checkMask("mountedCombat") then
	return
end

local fname="MountDismount"
local label=findlabel(fname)

if label ~= nil then
	setLabelImage(fname, "dismount.png")
end

if mount:get() == nil then
	mount:set("unknown")
end

mount:setMounted(true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You skillfully climb on and ride (.*) in the midst of battle.</string>
						<string>You climb on and ride (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dismount</name>
					<script>-- You dismount A heavy warhorse.
-- You dismount a hell hound.
-- You stop riding a hell hound.

--Your mount heads south, and you head for the ground!
--You fall to the ground.  You stop riding.


if not checkMask("mountedCombat") then
	return
end

local fname="MountDismount"
local label=findlabel(fname)

if label ~= nil then
	setLabelImage(fname, "mount.png")
end

-- was dismounted
if dismounted==true then
	return
end

mount:setMounted(false)
setBashing(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You dismount</string>
						<string>You stop riding</string>
						<string>You fall to the ground.  You stop riding.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You would bash your brains out on the roof, better dismount.</name>
					<script>-- failed movement

--Nurpy flies south.
--You follow Nurpy south.
--
--You would bash your brains out on the roof, better dismount.

mud:send("dismount")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You would bash your brains out on the roof, better dismount.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You maneuver your wolf to outflank Shalyssa Lurialar!</name>
					<script>timer:set("outflankcd", 6)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You maneuver your wolf to outflank</string>
						<string>You fail to outflank</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BOT</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>WaterXP</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A sea elf adventurer swims here.</name>
						<script>echo("adventurer found\n")
NyyLIB.bots.advfound=1

display("Adventurer:" )

NyyLIB.bots.advposition = map:getRoom()

display( map:getRoom() )

-- mud:send("give pearl adventurer")
-- expandAlias("@fwalk 86308")

--#COLOR red</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A sea elf adventurer swims here.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exits: -N -E -S -W -U -D</name>
						<script>-- room movement
NyyLIB.bots.position = NyyLIB.bots.position or 0


NyyLIB.bots.position = NyyLIB.bots.position+1</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Exits: -N -E -S -W -U -D</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You snap your fingers.</name>
						<script>NyyLIB.bots.position=0

if NyyLIB.bots.advposition == 0 then
	NyyLIB.bots.xval=NyyLIB.bots.xval+1

	if NyyLIB.bots.xval ~= 6 then
		expandAlias(".e5n")
		mud:send("snap")
	else
		NyyLIB.bots.xval=0
		NyyLIB.bots.yval=NyyLIB.bots.yval+1

		if NyyLIB.bots.yval ~= 3 then
			expandAlias(".d5n")
			mud:send("snap")
		end
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You snap your fingers.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You get a near-perfect pearl from corpse of a marid farmer.</name>
						<script>expandAlias("@fwalk 86308")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You get a near-perfect pearl from corpse of a marid farmer.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>TM_Mochanokul</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Banzai! 
To the rescue...</name>
						<script>if prompt:get("enemycondition") ~= "awful" then
	mud:send("tug suit")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Banzai! To the rescue...</string>
							<string>Mochanokul fails miserably in his attempt to rescue you.</string>
							<string>Mochanokul rises to his feet.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A fiery spark blazes about, forming a large pillar for flame.</name>
						<script>-- restart, 3min wait

setBashing(false)
rescueSent=false
NyyLIB.damaged = false

function startspark()
	mud:send("kill spark")
	mud:send("tug suit")
	--mud:send("shieldpunch")
end

tempTimer(180, startspark)

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A fiery spark blazes about, forming a large pillar for flame.</string>
							<string>a fiery spark is dead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CMShadows</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You switch opponents!</name>
						<script>mud:send("kill 2.shadow")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You switch opponents!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are already fighting them!</name>
						<script>mud:send("kill 1.shadow")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are already fighting them!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You try to switch opponents, but you become confused!</name>
						<script>mud:send("kill 3.shadow")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You try to switch opponents, but you become confused!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You strike out wildly about the area in a mighty burst of power!
You critically wound a shadow with a powerful bludgeon!</name>
						<script>function starthit()
	mud:send("hitall")
end

mud:send("kill 4.shadow")

tempTimer(20, starthit)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You strike out wildly about the area in a mighty burst of power!</string>
							<string>You are too disoriented to hitall again!</string>
							<string>You failed to strike any targets!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Zurg</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wooden bucket rests here, filled with water.</name>
						<script>for k,v in pairs(NyyLIB.buckets) do
	if v == map:getRoom() then
		return
	end
end

table.insert(NyyLIB.buckets, 1, map:getRoom() )

echo("\n[Found bucket in room: " .. map:getRoom() .. "]\n")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wooden bucket rests here, filled with water.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SMTrain</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>trainstation</name>
						<script>testnum = testnum or 0

local currentroom = map:getRoom()

if currentroom == NyyLIB.nextstop then
	disableTrigger("trainstation")

	if NyyLIB.smtrainposition == nil then
		if getPath(currentroom, 48603) then
			mud:send("gsay Stopping train and returning to inn (48603)" .. " &lt;." .. compressSpeedwalk() .. "&gt;" )

			expandAlias("@fwalk 48603", false)
		else
			mud:send("gsay Ending train" )
		end

		disableTrigger("SMTrain")
	else
		local stopname=NyyLIB.smtrainstops[NyyLIB.smtrainposition][2]

		cecho("\n\n&lt;cyan&gt;[Reached train station: &lt;green&gt;(" .. currentroom .. ")&lt;cyan&gt; " .. stopname .. "]\n\n")

		if _G[stopname] ~= nil then
			cecho("&lt;cyan&gt;[Calling function: " .. stopname .. "]\n")
			_G[stopname]()
			tempTimer(2, [[NextTrainStop()]])
		else
			if not pcharsInRoom then
				mud:send("glance " .. string.split(stopname, " ")[1] )
				tempTimer(2, [[StartFight()]])
			else
				cecho("&lt;red&gt;[Players in room - Moving to next station]\n")
				NextTrainStop()
			end
		end
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^&lt; .* &gt;</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>checkhealth</name>
						<script>if matches[2] == "You don't see that here." then
--	cecho("\n&lt;red&gt;[Target is already dead.]\n")
else
	NyyLIB.traintarget=true
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) is in an excellent condition.</string>
							<string>(You don't see that here.)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>(.*) is dead! R.I.P. ^Your blood freezes as you hear the rattling death cry of (.*)[.]</name>
						<script>if matches[2] == "an onyx dagger with a pulsing ruby hilt" then
	return
end

if matches[2] == "an emerald and ruby encrusted dagger" then
	return
end

if _G["NextTrainStop"] == nil then
	expandAlias("@resettrain", false)
	return
end

if NyyLIB.smtrainposition == nil then
	-- end train / return to bank
	NyyLIB.trainecho=0
	tempTimer(5, [[NextTrainStop()]])
else
	if map:getRoom() ~= NyyLIB.smtrainstops[NyyLIB.smtrainposition][1] then
		-- current room isn't expected room - this happens if a kill occurs right when you path through a room
		NyyLIB.traintarget=false

		--cecho("\n&lt;red&gt;[Error: Current room isn't expected room]\n")
		--cecho("&lt;red&gt;[map:getRoom() " .. map:getRoom() .. "]\n")
		--cecho("&lt;red&gt;[NyyLIB.nextstop " .. NyyLIB.nextstop .. "]\n")
		--cecho("&lt;red&gt;[NyyLIB.smtrainposition " .. NyyLIB.smtrainposition .. "]\n")

		-- If an fwalk was already sent, don't send another
		if not fwalkQue and map:countMovement() == 0 then
				fwalkQue=true
				echoDebug("&lt;red&gt;[Queuing fwalk to " .. NyyLIB.nextstop .. "]\n")
				tempTimer(5, [[expandAlias("@fwalk " .. NyyLIB.nextstop)]])
		end
	else
		NyyLIB.trainecho=0

		if callNextTrain == nil then
			callNextTrain=true
			look:send()
			cecho("&lt;red&gt;\n\n[Calling function: NextTrainStop()]\n")

			-- Suggested by Vooku - only 3 second delay if no followers
			if groupList:size() &gt; 1 then
				tempTimer(6, [[NextTrainStop()]])
			else
				tempTimer(3, [[NextTrainStop()]])
			end
		end
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your blood freezes as you hear the rattling death cry of (.*)[.]</string>
							<string>No target for your power could be found!</string>
							<string>They're not here!</string>
							<string>I don't see that person here.</string>
							<string>You don't see them here!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>EC: nasty wounds</name>
						<script>local xname=string.lower(matches[2])

if NyyLIB.smtrainposition == nil then
	return
end

local xtarget=string.lower(NyyLIB.smtrainstops[NyyLIB.smtrainposition][2])

-- TODO need to capitalize all words in name, not just first

if NyyLIB.trainecho ~= 1 then
	if string.findPattern(xtarget, xname) then
--	if string.split(NyyLIB.smtrainstops[NyyLIB.smtrainposition][2], " ")[1] == string.title(matches[2]) then
		NyyLIB.trainecho=1
--		send("gcmd [" .. string.title(xtarget) .. " has nasty wounds!]")


		local str = NyyLIB.smtrainstops[NyyLIB.smtrainposition][2]
		local nextmob = string.gsub(" "..str, "%W%l", string.upper):sub(2)

		mud:send("gcmd [" .. nextmob .. " has nasty wounds!]")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>E: (.*) EC: nasty wounds</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Purniel group-says 'stats reset'</name>
						<script>NyyLIB.stats={}
mud:send("gcmd [Resetting Stats]")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* group-(say|project)[s]? 'stats reset'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Purniel group-says 'stats display''</name>
						<script>printStats(3)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* group-(say|project)[s]? 'stats display'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ssassav gets a small pile of coins from corpse of Ersenas.</name>
						<script>local charname=matches[2]

if groupList:ingroup(charname) then
	mud:send("gsay looting from " .. whoami() .. " bad! bad " .. charname .. "!" )
	mud:send("FOLLOWERS pause " .. charname)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) gets a small pile of coins from corpse of .*</string>
							<string>([A-Za-z]+) gets something from corpse.</string>
							<string>([A-Za-z]+) gets a few coins from corpse.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>a human paladin is dead! R.I.P.</name>
						<script>if getPath(map:getRoom(), NyyLIB.nextstop) then
	mud:send("gcmd Moving to: " .. NyyLIB.smtrainstops[NyyLIB.smtrainposition][2] ..
							" (" .. NyyLIB.smtrainstops[NyyLIB.smtrainposition][1] .. ") " ..
 							" &lt;." .. compressSpeedwalk() .. "&gt;")
	
	NyyLIB.traintarget=false

	expandAlias("@fwalk " .. NyyLIB.nextstop)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^a human paladin is dead! R.I.P.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A mage in the Spellguard clambers to her feet.</name>
						<script>sendBash("spellguard")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A mage in the Spellguard clambers to her feet.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Aratha Sul is dead! R.I.P.</name>
						<script>mud:send("get lucky corpse")
mud:send( p("lucky") )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Aratha Sul is dead! R.I.P.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>dismount on xp</name>
						<script>if mount:getMounted() then
	mud:send("dismount")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^You receive .* XP .* experience.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Your mount refuses to trample</name>
						<script>mount:charge( getEnemy() )
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Your mount refuses to trample!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>newroom</name>
						<script></script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList />
						<regexCodePropertyList />
						<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>botRoomCapture</name>
							<script>-- location matters on this trigger to prevent double firing

-- terminate capture on blank line
if matches[1] == "" then
	disableTrigger("botRoomCapture")
	return
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^.*$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>^Exits: .*</name>
							<script>-- new room entered

enableTrigger("botRoomCapture")

pcharsInRoom = false</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^Exits: .*</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>player in room</name>
							<script>-- Waf  (RP) (Barbarian) stands in mid-air here, fighting A burly bouncer.
-- Rahar  (Shield Dwarf) hovers in mid-air here, fighting Elaith Waterstill.

-- Cyre Tahl'Veras the Huntsman of Ashen Lorenthal (Moon Elf) stands here.

-- Tutenef  (Human) hulks here.
-- Trenik  (RP) (Human) oozes here.
-- Trenik  (RP) (Human) blazes in mid-air here.
-- Trenik  (RP) (Human) oozes in mid-air here.

if inwho(matches[2]) then
	pcharsInRoom=true
end</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Z][a-z]+)  .* (sits|stands|hovers|oozes|blazes|hulks) .*[.]</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</TriggerGroup>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>petition disable</name>
						<script>-- Suggestion from @Afu

mud:send("@stoptrain")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:&lt; .* &gt; )?([A-Za-z]+ )responds to your petition with (.*)</string>
							<string>^(?:&lt; .* &gt; )?(.* )responds to your group with (.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>PsiBomb</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A wispy smoke colored portal hovers just above the center of the room.</name>
						<script>if NyyLIB.psibomb ~= true then
	NyyLIB.psibomb = true
	mud:send("enter portal")
	mud:send("enter hole")
	mud:send("enter rift")
	mud:send(".uw")
	mud:send("ultra 2.drake")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A wispy smoke colored portal hovers just above the center of the room.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You are dead!</name>
						<script>NyyLIB.psibomb=false</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You are dead!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You do not have enough psp's to project that.</name>
						<script>-- disable trigger set
disableTrigger("PsiBomb")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You do not have enough psp's to project that.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bel</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>It seems to be locked.</name>
						<script>belcount = belcount or 0

belcount = belcount + 1

mud:send("open door")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>It seems to be locked.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>The door SLAMS shut and locks with a heavy thud.</name>
						<script>belcount=0

mud:send("GSAY door is closed!")
mud:send("ST")
mud:send("OPEN door")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>The door SLAMS shut and locks with a heavy thud.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ok.</name>
						<script>belcount = belcount or 0

mud:send("gsay &lt;&lt;&lt; The door is open! After " .. belcount .. " attempts! &gt;&gt;&gt;")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Ok.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SMTrainCaster</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Tuw group-says 'Attacking: Forell'</name>
						<script>-- only do this if not already in combat
if not inCombat() and assistSent == nil then
	local nextroom = NyyLIB.nextroomstop or map:getRoom()

	-- move to correct room if lost

	if nextroom ~= map:getRoom() then
		expandAlias("@fwalk " .. nextroom)	
	else
		fleeMem()
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) group-says 'Attacking: .*</string>
							<string>([A-Za-z]+) group-says 'Killing .*</string>
							<string>([A-Za-z]+) group-says '\[Attacking: .*</string>
							<string>([A-Za-z]+) group-says 'Going on .*</string>
							<string>(Entetee) is ENRAGED!</string>
							<string>([A-Za-z]+) group-says 'Target .*</string>
							<string>([A-Za-z]+) .* resulting in some strange noises and some blood.</string>
							<string>([A-Za-z]+) group-says 'bash .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You flee downward!</name>
						<script>if NyyLIB.castertrain then
	NyyLIB.castertrain = matches[2]

	mud:send("pray", false)
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You flee ([nsewud]).*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>finish mem/pray return to fight</name>
						<script>fightreturn=true

if NyyLIB.castertrain ~= nil then
	mud:send("ST")

	if NyyLIB.reversedirs[NyyLIB.castertrain] == nil then
		cecho("\n&lt;red&gt;[Error: unknown direction to return to fight]\n")
		display(NyyLIB.castertrain)
		mud:send("ST")
		NyyLIB.casterttrain=nil
		return
	end

	expandAlias(NyyLIB.reversedirs[NyyLIB.castertrain], false)
	NyyLIB.castertrain=nil
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your prayers are complete.$</string>
							<string>.* group-says '.* has nasty wounds.*</string>
							<string>.* group-says '.* is -=Nasty Wounds=-'</string>
							<string>.* group-says '.* is -=P-Hurt=-'</string>
							<string>.* group-says 'ph'</string>
							<string>.* group-says '.* is pretty hurt and will die soon.'</string>
							<string>.* group-says '.* is not lookin good, Nasty!'</string>
							<string>Who can concentrate with all that clanging and screaming?</string>
							<string>.* group-says '.*  - pretty hurt -'</string>
							<string>But you don't have any spells in your thoughts!</string>
							<string>You can't concentrate with all the racket!</string>
							<string>Your studies are complete.</string>
							<string>.* group-says '.* has some nasty wounds!'</string>
							<string>.* group-says '.* is doomed!! \(Nasty Wounds\)'</string>
							<string>Our enemy will join Kelemvor soon.(pretty hurt)</string>
							<string>Hoppil group-says '.. Pretty Hurt'</string>
							<string>Your skin crawls as you hear a death cry nearby!</string>
							<string>.* in the afterlife!! \(Pretty Hurt\)'</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>(.*) is dead! R.I.P.</name>
						<script>spell:clear()

fightreturn=false
NyyLIB.castertrain=nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) is dead! R.I.P.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Harlindrel group-says 'Moving to: Lavis Ryl (48524)  &lt;.sen&gt;'</name>
						<script>-- Harlindrel group-says 'Moving to: Ultrumm (49135)  &lt;.2e5s5w3nu&gt;'

NyyLIB.castertrain=nil

NyyLIB.nextroomstop = tonumber(matches[2])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>.* group-says .*Moving to: .* \(([0-9]+)\).*&lt;.*&gt;.*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>^Your blood freezes as you hear the rattling death cry of (.*)[.]</name>
						<script>if mount:get() then
	mud:send("dismount")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Your blood freezes as you hear the rattling death cry of (.*)[.]</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CPNoble</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>You get a signet ring from corpse of a Calimport noble.</name>
						<script>mud:send("put signet hole")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>You get a signet ring from corpse of a Calimport noble.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A Calimport noble stands here arrogantly.</name>
						<script>sendBash("noble")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A Calimport noble stands here arrogantly.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>AutoPortal</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Sarrshis enters a blood-red portal and disappears among the mist.</name>
						<script>-- a humming portal of violet mist suddenly glows brightly!
-- Pidibeple slowly fades out of existence.

-- Ezarak enters a rainbow colored portal and disappears among the mist.

-- todo
-- Atraz utters the words, 'uizuguburuhl'.
-- The ghost of a huge air elemental utters the words, 'invisibility'.
-- if previous line = invis

-- if more people have entered portal then warriors in group, enter portal

local charname = matches[2]
local portalname = matches[3]

enteredPortal = enteredPortal or {}


if groupList:ingroup(charname) and charData:get("autoportal") then
	enteredPortal[charname] = "entered"

	-- return if &lt; 6 people in group, or no warriors
	if groupList:size() &lt; 6 or #(groupList:pc("warrior")) == 0 or alreadyEnteredPortal then
		return
	end

	if table.size(enteredPortal) &gt; #(groupList:pc("warrior")) then
		enteredPortal={}

		alreadyEnteredPortal=true

		spell:clear()

		mud:send("ST")

		if portalname == "fades" then
		-- special exit or invis

			if map:getRoom() ~= nil then
				local specialexit = getSpecialExitsSwap( map:getRoom() )

				-- TODO: why only use if 1 exit?

				if table.size(specialexit) == 1 then
					for k,v in pairs(specialexit) do
						if mount:getMounted() then
							mud:send("dismount")
						end

						local exitcmd=string.split(k, "|")[1]

						if pet:status() or mount:get() ~= nil then
							mud:send("ORDER followers " .. exitcmd)
						end

						cecho("\n&lt;green&gt;[Using special exit '&lt;cyan&gt;" .. exitcmd .. "&lt;green&gt;' to room &lt;cyan&gt;" .. v .. " : " .. getRoomName(v) .. "&lt;green&gt;]\n")

						map:processMovement(exitcmd)
						--mud:send (exitcmd)
					end
				end
			end
		else
			if mount:getMounted() then
				mud:send("dismount")
			end

			if pet:status() or mount:get() ~= nil then
				mud:send("ORDER followers enter " .. portalname)
			end
			
			mud:send("enter " .. portalname)
		end

		look:send()
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) enters a blood-red (portal) and disappears among the mist.</string>
							<string>([A-Za-z]+) enters a planar (rift) and disappears among the mist.</string>
							<string>([A-Za-z]+) enters a (wormhole) and disappears among the darkness.</string>
							<string>([A-Za-z]+) enters a rainbow colored (portal) and disappears among the mist.</string>
							<string>([A-Za-z]+) slowly (fades) out of existence.</string>
							<string>([A-Za-z]+) enters a (moonwell) and disappears among the mist.</string>
							<string>([A-Za-z]+) enters the dimensional (fold) and reappears elsewhere...</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>AutoMem</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ozzec opens an ancient tome and begins studying it intently.</name>
						<script>-- mem started ingroup
automem = automem or 0

if groupList:ingroup(matches[2]) then
	automem = automem + 1

	if automem &gt;= 2 then
		spell:setMoving(false)
	end

	echoDebug("\n&lt;red&gt;[+1 automem " .. automem .. " memcount " .. charData:get("memcount") .. "\n")
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z]+) opens an ancient tome and begins studying it intently.</string>
							<string>([A-Za-z]+) takes out (his|her) holy symbol and begins praying intently.</string>
							<string>([A-Za-z]+) takes out (his|her) holy symbol and begins praying intently</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Sorry, you aren't allowed to do that in combat.</name>
						<script>automem=0</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Sorry, you aren't allowed to do that in combat.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>AutoAssist</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Autoassist - barely wounds</name>
					<script>-- ^(.+) attacks .*
-- .* attacks (.+), landing .*

-- The spectre of a human noble barely wounds a human noble with its average drain.
-- The spectre of a human noble misses a human noble with its drain.
-- The spectre of a human noble barely wounds a human noble with its average drain.

-- triggered by combat occuring in same room

local testname= matches[2]

if testname == whoami() then
	return
end

if charData:get("autoassist") then
	if groupList:ingroup(testname) then
		if not inCombat() and groupList:getTanking(whoami()) == 0 then
			--display(testname)
			if testname ~= whoami() then
				sendAssist(testname)
			end

			-- Send assist if ungrouped pet following self

			testname = pet:member(testname)

			if testname then
				sendAssist(testname)
			end
		end
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.+) barely wounds .* with .*</string>
						<string>^(.+) attack only grazes .*</string>
						<string>^(.+) slams .* shield into .*</string>
						<string>.* attacks (.+), landing .*</string>
						<string>^(.+) sends .* sprawling with a powerful bash.</string>
						<string>^([A-Za-z]+) tried to backstab.*</string>
						<string>^([A-Za-z]+) places .* in the back of.*</string>
						<string>.* assists (.+) heroically.$</string>
						<string>^(.+) sends a powerful force missile slamming into .*</string>
						<string>^(.+) heroically rescues.*</string>
						<string>^(.+) does an acrobatic maneuver in battle, and trips up .*</string>
						<string>^(.+) dodges .*</string>
						<string>^(.+) misses .* with .*</string>
						<string>^(.+) attacks .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>assist sent</name>
					<script>-- failed assist attempts

assistSent=nil
look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are already fighting them!</string>
						<string>Assist whom?</string>
						<string>That person is not fighting anyone.</string>
						<string>You can't see who is fighting</string>
						<string>You stumble and miss your attack!</string>
						<string>Maybe you should get on your feet first?</string>
						<string>You can't get to</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Counters</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>successful rescues</name>
					<script>-- You are rescued by Atorax, you are confused, but grateful!

if matches[2] == "Banzai" then
	addStat(whoami(), "successrescue")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "successrescue")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(Banzai)! To the rescue...</string>
						<string>([A-Za-z]+) heroically rescues .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>failed rescues</name>
					<script>-- Atorax fails miserably in his attempt to rescue you.

if matches[2] == "You" then
	addStat(whoami(), "failedrescue")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "failedrescue")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) fail the rescue.</string>
						<string>([A-Za-z]+) futilely tries to rescue .*</string>
						<string>([A-Za-z]+) fails miserably in .* attempt to rescue you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defShieldGlance (all)</name>
					<script>-- Ersenas's attack glances off your shield, but finds its mark!
-- Wobb partially blocks a githyanki patrol leader's attack with her shield!


-- there will still be a hit

if matches[2] == "your" then
	addStat(whoami(), "defShieldGlance")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defShieldGlance")
	end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* glances off (your) shield, but finds its mark!</string>
						<string>([A-Za-z]+)  partially blocks .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>STR: 100  AGI: 116  DEX:  83  CON: 106</name>
					<script>NyyLIB.str=matches[2]
NyyLIB.agi=matches[3]
NyyLIB.dex=matches[4]
NyyLIB.con=matches[4]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>STR: +([0-9]+) +AGI: +([0-9]+) +DEX: +([0-9]+) +CON: +([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Armor Class: -100  (100 to -100)  Agility Bonus: -10</name>
					<script>NyyLIB.agibonus=matches[2]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*\(100 to -100\)  Agility Bonus: -([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hitroll: 44   Damroll: 29</name>
					<script>NyyLIB.hitroll=matches[2]
NyyLIB.damroll=matches[3]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Hitroll: ([0-9]+) *Damroll: ([0-9]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offParryPartial (all)</name>
					<script>-- A draconian warrior partially deflects Misi's lunge at it.

if matches[2] == "your" then
	addStat(whoami(), "offParryPartial")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offParryPartial")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* partially deflects ([A-Za-z]+)'s lunge.*</string>
						<string>.* partially deflects (your) lunge at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offDeflect (all)</name>
					<script>-- Tarthilmor Aerasume deflects your blow, and strikes back at YOU!
-- A githyanki captain deflects Lorle's blow, and strikes back at Lorle!

if matches[2] == "your" then
	addStat(whoami(), "offDeflect")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offDeflect")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* deflects (your) blow, and strikes back at YOU!</string>
						<string>.* deflects ([A-Za-z]+)'s blow, and strikes back at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defWeaponDeflect (all)</name>
					<script>-- You deflect Willa O'Greensleeves's blow, and strike back at Willa O'Greensleeves! (riposte)
-- Oggsk deflects an elite snow elf warrior's blow, and strikes back at an elite snow elf warrior!

if matches[2] == "You" then
	addStat(whoami(), "defWeaponDeflect")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defWeaponDeflect")
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) deflect.* </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defGraze (all)</name>
					<script>if matches[2] == "you" then
	addStat(whoami(), "defGraze")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defGraze")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* attack only grazes ([A-Za-z]+) as .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defDodge (all)</name>
					<script>-- Uggub dodges a dapper noble's attack.

if matches[2] == "You" then
	addStat(whoami(), "defDodge")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defDodge")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) dodge .*</string>
						<string>([A-Za-z]+) dodges .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defHit - through my defenses</name>
					<script>-- hit through my defense
if matches[2] == "you" then
	addStat(whoami(), "defHit")
else
	if groupList:ingroup(matches[2]) then
		addStat(whoami(), "defHit")
		
		-- TODO: this group probably be removed (for barely, at least)
		group:send()
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>barely wounds ([A-Za-z]+)</string>
						<string>slightly wounds ([A-Za-z]+)</string>
						<string>badly wounds ([A-Za-z]+)</string>
						<string>You stagger from</string>
						<string>wounds ([A-Za-z]+) harshly </string>
						<string>severely wounds ([A-Za-z]+)</string>
						<string>critically wounds ([A-Za-z]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offMissed - missed attack (all)</name>
					<script>if matches[2] == "You" then
	addStat(whoami(), "offMiss")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offMiss")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) miss .* with .*</string>
						<string>^([A-Za-z]+) misses .* with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offHit - me</name>
					<script>-- Your weak hit barely wounds a massive turnip.


-- Elaith Waterstill staggers from your massive slash!
-- You enshroud Lavis Ryl in a mist of blood with your massive slash!
-- Lavis Ryl is nearly slain by the force of your massive slash!
-- Your final slash sends Lavis Ryl's head bouncing along the ground.

-- Seipora Rein is nearly slain by the force of your massive bludgeon!
-- You cave in Seipora Rein's chest, she dies rather quickly.
-- You crushed Forell Luckaun's skull, I'm afraid he's dead.

-- hit
addStat(whoami(), "offHit")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your awesome .*</string>
						<string>Your strong .*.</string>
						<string>Your mighty .*.</string>
						<string>Your powerful .*.</string>
						<string>Your massive .*.</string>
						<string>Your average .*.</string>
						<string>You enshroud .*</string>
						<string> .* is nearly slain by the force of your .*</string>
						<string>You critically wound .*</string>
						<string>Your weak hit .*</string>
						<string>.* staggers from your massive .*[!]</string>
						<string>Your final .* sends .* head bouncing along the ground.</string>
						<string>You cave in .* chest, .* dies rather quickly.</string>
						<string>You crushed .*[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offHit - other</name>
					<script>-- Yugguk barely wounds Forell Luckaun with his powerful slash.

if groupList:ingroup(matches[2]) then
	addStat(matches[2], "offHit")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) barely wounds .*</string>
						<string>^([A-Za-z]+) critically wounds .*</string>
						<string>^([A-Za-z]+) wounds .*</string>
						<string>^([A-Za-z]+) enshrouds .*</string>
						<string>^([A-Za-z]+) slightly wounds .*</string>
						<string>^([A-Za-z]+) brutally wounds .*</string>
						<string>^([A-Za-z]+) severely wounds .*</string>
						<string>^.* staggers from ([A-Za-z]+)'s awesome .*</string>
						<string>^.* is nearly slain by the force of ([A-Za-z]+)'s .*</string>
						<string>^.* is slashed into two by a masterly stroke performed by ([A-Za-z]+).</string>
						<string>^([A-Za-z]+) badly wounds .*</string>
						<string>^.* staggers from ([A-Za-z]+)'s massive .*</string>
						<string>^([A-Za-z]+) pierces.*, whose body falls lifeless to the ground.</string>
						<string>^([A-Za-z]+) pierces the heart of .* who falls to the ground clutching at the wound.</string>
						<string>^.* staggers from ([A-Za-z]+)'s strong .*</string>
						<string>^([A-Za-z]+) neatly beheads .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offDodge (all)</name>
					<script>-- miss - dodge

if matches[2] == "you" or matches[2] == "You" then
	addStat(whoami(), "offDodge")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offDodge")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>dodges (you)r futile attack.</string>
						<string>.* dodges ([A-Za-z]+)'s attack.</string>
						<string>(You)r attack glances harmlessly off of .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defMiss - missed attack (all)</name>
					<script>-- A challenge warrior's attack only grazes Graxod as he dodges aside!
-- Tarthilmor Aerasume deflects your blow, and strikes back at YOU!


-- attack doesn't get through my defense

if matches[2] == "you" then
	addStat(whoami(), "defMiss")
end

if groupList:ingroup(matches[2]) then
	addStat(matches[2], "defMiss")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> misses (you) </string>
						<string>.* missed ([A-Za-z]+) with .*</string>
						<string>.* misses ([A-Za-z]+) with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>shield vamp</name>
					<script>addStat(whoami(), "shieldvamp")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your shield glows brightly as it steals some lifeforce</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defParry (all)</name>
					<script>-- Grxx parries a mage in the Spellguard's lunge at him.

if matches[2] == "You" then
	addStat(whoami(), "defParry")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defParry")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) parry .*</string>
						<string>([A-Za-z]+) parries .* lunge at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offParry (all)</name>
					<script>-- An elite caravan guard parries your futile lunge at him.
-- A magical skeleton parries Nisaya's lunge at it.
-- Grxx parries a mage in the Spellguard's lunge at him.

if matches[2] == "your" then
	addStat(whoami(), "offParry")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offParry")
	end
end
	</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* parries ([A-Za-z]+)'s lunge at .*</string>
						<string>.* parries (your) futile lunge at .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defShieldBlock (all)</name>
					<script>-- Graxod blocks a member of the High Guard's attack with his shield!
-- A large ogre blocks Sashishe's attack with his shield!
--Wobb blocks a githyanki Defender's attack with her shield!
-- .* blocks ([A-Za-z]+)'s attack with his shield!


if matches[2] == "You" then
	addStat(whoami(), "defShieldBlock")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defShieldBlock")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) block .*</string>
						<string>([A-Za-z]+) blocks .* attack with .* shield!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offGraze - other</name>
					<script>--Hoppel's attack only grazes a githyanki warrior as he dodges aside!
--Your attack only grazes a tl'a'ikith as he dodges aside!

if matches[2] == "Your" then
	addStat(whoami(), "offGraze")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offGraze")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+)'s attack only grazes .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>defParryPartial (all)</name>
					<script>-- Lashimer partially deflects a shadowy spectre's lunge at him.

if matches[2] == "You" then
	addStat(whoami(), "defParryPartial")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "defParryPartial")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(You) partially deflect</string>
						<string>([A-Za-z]+) partially deflects .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>offShieldBlock (other)</name>
					<script>-- A large ogre blocks Sashishe's attack with his shield!

if groupList:ingroup(matches[2]) then
	addStat(matches[2], "offShieldBlock")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* blocks ([A-Za-z]+)'s attack with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ganar summons a healing light that surround the entire group.</name>
					<script>-- Bafog summons a healing light that surround the entire group.
-- Vare summons a holy light that surrounds the entire group.
-- Rokpat summons a holy light that surrounds the entire group.


if matches[2] == "You" then
	addStat(whoami(), "GroupHeal")
	return
end

addStat(matches[2], "GroupHeal")

if groupList:size() &gt; 1 then
	group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a healing light that surround the entire group.</string>
						<string>(You) summon a healing light that surrounds the entire group.</string>
						<string>([A-Za-z]+) summons a holy light that surrounds the entire group.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Nilebbeple starts casting a spell called 'Vitality'</name>
					<script>
addStat(matches[2], "Vitality")


if groupList:ingroup(matches[2]) then
	tempTimer(4, [[group:send()]])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) starts casting a spell called 'Vitality'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>invoker spells</name>
					<script>--</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a fearsome meteor swarm!</string>
						<string>Billowing clouds of incendiary gases pour from ([A-Za-z]+)'s fingertips!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hosol summons a holy light to surround Hosol and close his wounds.
</name>
					<script>-- full heal
-- Rynshana summons a holy light to surround Ravad and close his wounds.
-- Your feel a rush of warmth as your wounds are healed.
-- You summon a holy light to surround Lilabipple and close her wounds.
-- You summon a holy light to surround a gray slaad and close its wounds.[heal trigger]
-- Lilebeple summons a holy light to surround Tatris and close his wounds.


if matches[2] == "Your" then
	addStat(whoami(), "gotFullHeal")
	return
end

if matches[2] == "You" then
	addStat(whoami(), "castFullHeal")

	if not groupList:ingroup(matches[3]) then
		return
	end

	addStat(matches[3], "gotFullHeal")

	return
end

if groupList:ingroup(matches[2]) then
	addStat(matches[2], "castFullHeal")
end

if groupList:ingroup(matches[3]) then
	addStat(matches[3], "gotFullHeal")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a holy light to surround ([A-Za-z]+) and close .*</string>
						<string>(Your) feel a rush of warmth as your wounds are healed.</string>
						<string>(You) summon a holy light to surround ([A-Za-z ]+) and close .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Hosol surrounds Ashashas in a brilliant aura of 
holy power.</name>
					<script>-- healingaura - add buff (20 sec timer)
-- Repeats 5 times every 4 seconds = 20 sec
-- triggers after 4, 4, 4, 4, 4 (heal at 4, 8, 12, 16, 20

--Mizes completes his spell...
--You are surrounded in a brilliant aura of holy power.

spell:whocast()

if groupList:ingroup(matches[2]) then
	-- ([A-Za-z]+) surrounds ([A-Za-z]+) in a brilliant aura of holy power.
	addStat(matches[2], "castHealingAura")

	if groupList:ingroup(matches[3]) then
		buff:set(matches[3], "healing_aura", 20)

		addStat(matches[3], "gotHealingAura")
	end
end

if matches[2] == "You" then
	if matches[3] == nil then
		-- You are surrounded in a brilliant aura of holy power.
		buff:set(whoami(), "healing_aura", 20)

		addStat(whoami(), "gotHealingAura")

		if spell:whocast() == whoami() then
			addStat(whoami(), "castHealingAura")
		end
	else
		-- You surround Harlindrel in a brilliant aura of holy power.
		addStat(whoami(), "castHealingAura")

		if groupList:ingroup(matches[3]) then
			buff:set(matches[3], "healing_aura", 20)

			addStat(matches[3], "gotHealingAura")
		end
	end
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) surrounds ([A-Za-z]+) in a brilliant aura of holy power.</string>
						<string>(You) are surrounded in a brilliant aura of holy power.</string>
						<string>(You) surround ([A-Za-z]+) in a brilliant aura of holy power.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lilithelle has died!</name>
					<script>-- death counter

if groupList:ingroup(matches[2]) then
	addStat(matches[2], "death")
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) has died!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your body warms as some of your wounds are healed.</name>
					<script>-- heal cast on self
-- Your body warms as some of your wounds are healed. 

-- Your body warms as your wounds are healed. groupheal?

-- You summon a healing light that surrounds the entire group.

addStat(whoami(), "castHeal")
addStat(whoami(), "gotHeal")

for k,char in pairs(groupList:pc()) do
	buff:del(char, "blind")
	buff:del(char, "blindness")
end

group:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your body warms as some of your wounds are healed.</string>
						<string>Your body warms as your wounds are healed.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Daggararoa is infused with vitality.</name>
					<script>-- Daggararoa is infused with vitality. (cast by me)
--([A-Za-z]+) is infused with vitality. (someone else)
-- You feel vitalized. (by me or someone else)


local caster=spell:whocast()


if caster ~= nil then
	addStat(caster, "Vitality")
end

if matches[2] == "You" then
	sendStatus()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) is infused with vitality.</string>
						<string>(You) feel vitalized.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are rescued by Harlindrel!</name>
					<script>-- You are rescued by the spectre of a human noble!

if groupList:ingroup(matches[2]) then
	addStat(matches[2], "successrescue")
end

look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are rescued by (.*)!</string>
						<string>You are rescued by (.*), you are confused, but grateful!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Kazah starts casting an offensive spell called 'Spectral Hand'</name>
					<script>-- track total spellcast
if matches[2] == "You" then
	addStat(whoami(), "spellCast")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "spellCast")
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) starts casting .*</string>
						<string>(You) start chanting...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You maneuver your mount to avoid A naked woman's attack!</name>
					<script>-- mount block

addStat(whoami(), "defMountBlock")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You maneuver your mount to avoid</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>planetar heal</name>
					<script>-- planetar heal proc
addStat(whoami(), "planetar")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Warm, radiating sunlight exudes from your blade, healing your wounds with its powerful energy.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ranger</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>armor splinter</name>
						<script>-- Lulaz strikes the weak spots in a black dragon scout's armor, leaving him vulnerable.
-- You strike the weak spots in a black dragon scout's armor, leaving him vulnerable.

-- The green dragon consort's armor resists the impact of Melenes's carefully aimed strikes. (failed)

if matches[2] == "You" then
	addStat(whoami(), "offHitAP")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offHitAP")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) strikes the weak spots in .*</string>
							<string>(You) strike the weak spots in .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>evis</name>
						<script>-- You swing your weapons in lethal arcs, dousing the area with an elite barbazu soldier's blood.
-- Lulaz swings his weapons in lethal arcs, dousing the area with an elite narzugon's blood.

if matches[2] == "You" then
	addStat(whoami(), "offHitEV")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offHitEV")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(You) swing your weapons in lethal arcs, dousing the area with .*</string>
							<string>(Lulaz) swings his weapons in lethal arcs, dousing the area with .*</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>blade storm</name>
						<script>-- Lulaz spins and leaps through the fray, unleashing a torrent of steel on his enemies!

if matches[2] == "You" then
	addStat(whoami(), "offHitBS")
else
	if groupList:ingroup(matches[2]) then
		addStat(matches[2], "offHitBS")
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*) spins and leaps through the fray, unleashing a torrent of steel on his enemies!</string>
							<string>(You) spin and leap through the fray, unleashing a torrent of steel on your enemies!</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>AutoRoller</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>roller dice</name>
					<script>local value= tonumber(matches[3])

if value &gt;= 90 and value &lt; 95 then
	NyyLIB.roller = NyyLIB.roller + 1
elseif value &gt;= 95 and value &lt; 100 then
	NyyLIB.roller = NyyLIB.roller + 2
elseif value == 100 then
	NyyLIB.roller = NyyLIB.roller + 3
end

value= tonumber(matches[6])

if value &gt;= 90 and value &lt; 95 then
	NyyLIB.roller = NyyLIB.roller + 1
elseif value &gt;= 95 and value &lt; 100 then
	NyyLIB.roller = NyyLIB.roller + 2
elseif value == 100 then
	NyyLIB.roller = NyyLIB.roller + 3
end


--if matches[3] == "mighty" then
--	NyyLIB.roller = NyyLIB.roller +	 1
--end

--if matches[6] == "mighty" then
--	NyyLIB.roller = NyyLIB.roller +	 1
--end

--if matches[3] == "heroic" then
--	NyyLIB.roller = NyyLIB.roller +	 2
--end

--if matches[6] == "heroic" then
--	NyyLIB.roller = NyyLIB.roller +	 2
--end


--if matches[3] == "perfect" then
--	NyyLIB.roller = NyyLIB.roller +	 3
--end

--if matches[6] == "perfect" then
--	NyyLIB.roller = NyyLIB.roller +	 3
--end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(Strength|Dexterity|Agility|Constitution|Power|Intelligence|Wisdom|Charisma): +(bad|fair|average|mundane|good|mighty|heroic|perfect)</string>
						<string>(Strength|Dexterity|Agility|Constitution|Power|Intelligence|Wisdom|Charisma): +([0-9]+)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Your basic stats:</name>
					<script>NyyLIB.roller=0</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your basic stats:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>RollerTrigger</name>
					<script>-- ^Constitution: .* Charisma: .*
-- (Strength|Dexterity|Agility|Constitution|Power|Intelligence|Wisdom|Charisma): +(bad|fair|average|mundane|good|mighty|heroic|perfect)

-- You may choose to reroll your character at this time. If you elect

rollerstats = rollerstats or {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

-- NyyLIB.roller - the value of current roll

local rollTarget = charData:get("autoroll", true)

if NyyLIB.roller ~= 0 then
	rollerstats[NyyLIB.roller] = rollerstats[NyyLIB.roller] + 1

	local nx
	
	for nx=1,(rollTarget-1),1 do
				
		local val=rollerstats[nx]
	end
end

if NyyLIB.roller &lt; rollTarget then
	send("y", false)
else
	-- sound
	sound("365641__furbyguy__8-bit-alarm.wav",nil,true)

	-- anti-timeout
	timer:set("autoroll", 120)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Constitution: .*Charisma: .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>DisplayPotions</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>When you look inside, you see:</name>
					<script>-- A hole of spatial distortion (carried) : 

-- enable potion detect trigger
enableTrigger("InventoryPotions")
enableTrigger("EndTrigger")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>When you look inside, you see:</string>
						<string>([A-Za-z ]+) \(carried\) : </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>InventoryPotions</name>
					<script>local itemname=matches[2]

-- Remove all (word) patterns: (magic), (illuminating), (glowing), (damaged), (invis)
itemname = string.gsub(itemname, " %(.+%)", "")

-- [#] itemname (i.e. multiple items)

if string.find(itemname, "] ") ~= nil then
	itemname = string.sub(itemname, string.find(itemname, "] ")+2)
end

itemname = NyyLIB.itemdb[itemname]

if itemname ~= nil then
	if itemname[1] == "potion" then
		itemname=itemname[2]
		cecho(" " .. charData:get("potionc", true) .. "[" .. itemname .. "]")
	elseif itemname[1] == "scroll" then
		itemname=itemname[2]
		cecho(" &lt;:medium_blue&gt;&lt;red&gt;" .. "[" .. itemname .. "]")
	else
		itemname=itemname[2]
		cecho(" &lt;:medium_blue&gt;&lt;green&gt;" .. "[" .. itemname .. "]")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>EndTrigger</name>
					<script>-- need to fix for badge

disableTrigger("EndTrigger")
disableTrigger("InventoryPotions")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt;.*&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>TorilMapper</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^Exits: (.*)</name>
					<script>local xexits=matches[2]
local roomPortal = false

-- last command entered was look direction - return
if string.find(command, "L ") == 1 and not string.find(command, "L in") then
	return
end

-- TODO: correct room number in looking n/e/s/w/etc
-- You extend your sights northwards.
-- You extend your sights upwards.

-- clair - 'cast your sights far out' in the last 6 lines

for nx=1,6,1 do
	if string.find( getLines(getLineNumber()-nx, getLineNumber())[1], "cast your sights far out") then
		roomPortal="Clair"
	end
end

-- looking in wormhole - 'You peer into'
-- You peer into a blood-red portal
-- You peer into a rainbow colored portal and see...
-- You peer into a moonwell and see...

-- TODO/tofix: this segment can't be reached (it returns from 'L') 

for nx=1,6,1 do
	local portal=string.match( getLines(getLineNumber()-nx, getLineNumber())[1], "You peer into a (.*) and see" )

	if portal ~= nil then
		roomPortal=portal
	end
end

-- last command entered was scan
-- This block will also attempt to solve location from scan results

if command == "SCAN" then
	local lineindex=1

	while ( string.find( getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([A-Za-z]+)[.][.][.]") == nil) do
		lineindex=lineindex+1

		if lineindex &gt; 150 then
			cecho("&lt;red&gt;[Scan error after 150 lines]\n")
			command = ""
			return
		end
	end

	local scandir= string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*")

	scanned[scandir]={}
	scanned[scandir]["roomname"]= getLines(getLineNumber()-lineindex+1, getLineNumber())[1]
	scanned[scandir]["exits"] = getExitTable(xexits)

	scanned[scandir]["roomids"] = map:findRoomIDTable( scanned[scandir]["roomname"], getExitTable(xexits), true)

	scanned["currentroomname"] = map:getRoomname()
	scanned["currentroomexits"] = map:getExits()

	filterScan(scandir) -- reverse checks all rooms

	if map:getRoom() == nil then
		local solveroom = solveScan(true)

		if solveroom ~= nil then
			map:setRoom(solveroom)
			centerview( map:getRoom() )
		end
	end

	return
end

-- was last command entry to special exit?
-- This is the block that echos the special exit usage message

if map:getRoom() ~= nil then
	local specialexit = getSpecialExitsSwap( map:getRoom() )

	local exitlist={}

	-- build list of special exits
	for k,v in pairs(specialexit) do
		-- key will be each special exit from this room example: "enter wave|dancer"
		local specialExit = string.split(k, " ")
		
		for k2,v2 in pairs(string.split(specialExit[2], "|")) do
			local testCommand = string.split(string.lower(command), " ")
			local testExit = string.lower(specialExit[1])
			
			-- Check for special command/partial command, exit
			if string.find(testExit, testCommand[1]) == 1 and testCommand[2] == string.lower(v2) then
				-- TODO - command2 causes problems with fwalk paths
				cecho("\n&lt;green&gt;[Using special exit '&lt;cyan&gt;" .. k .. "&lt;green&gt;' to room &lt;cyan&gt;" .. v .. " : " .. getRoomName(v) .. "&lt;green&gt;]\n")
				map:setRoom(v)
				centerview( map:getRoom() )

				-- remove first movement from queue
				map:removeMovement()

				return
			end
		end
	end
end

-- find last blank line received, room name is first following line of format title the doesn't end in period or start with [

local lineindex=1

-- find last promptline received
while prompt:isStringPrompt( getLines(getLineNumber()-lineindex, getLineNumber())[1] ) == false do
	lineindex=lineindex+1

	if lineindex &gt; 1500 then
		echoDebug("&lt;red&gt;[Searched more then 1500 lines unable to locate last prompt for roomname]\n")
		return
	end
end

local teststring = getLines(getLineNumber()-lineindex, getLineNumber())[1]

while map:isRoomName(teststring) == false do
	lineindex=lineindex-1
	teststring = getLines(getLineNumber()-lineindex, getLineNumber())[1]
end

-- if claired decrease index by 1
local checkline= getLines(getLineNumber()-lineindex, getLineNumber())[1]

if checkline ~= nil then
	if string.find( checkline, "cast your sights far out") then
		lineindex=lineindex-1
	end

	if string.find( checkline, "You peer into") then
		lineindex=lineindex-1
	end
end

-- TODO: clair/portal shouldn't be setting roomname

local roomName = getLines(getLineNumber()-lineindex, getLineNumber())[1]

map:setRoomname( roomName )

if roomName == nil then
	return
end

-- Remove all (word) patterns: (Shadowed), (Airy), except: (Water), (Fogged) (No Ground), (burning)
local buildName = string.gsub(roomName, " %(.+%)", "")

if string.find( roomName, "%(burning%)" ) then
	buildName = buildName .. " (burning)"
end

if string.find( roomName, "%(Water%)" ) then
	buildName = buildName .. " (Water)"
end

if string.find( roomName, "%(Fogged%)" ) then
	buildName = buildName .. " (Fogged)"
end

if string.find( roomName, "%(No Ground%)" ) then
	buildName = buildName .. " (No Ground)"
end

roomName = buildName

-- in case roomname was on same line as prompt (it happens!)
if string.find( roomName, "&gt; ") ~= nil then
	roomName = string.sub(roomName, string.find(roomName, "&gt; ")+2) 
end

-- if not a portal, can set name/exits
if not roomPortal then
	map:setExits( getExitTable(xexits) )
	
	-- clear trailing whitespace
	roomName = roomName:trim()
	
	map:setRoomname(roomName)
end

-- pop last movement (if there was one)

local lastMovement = map:popMovement()

local testMovement = string.match( tostring(lastMovement), "^DRAG .* ([nsewud]).*")

if testMovement then
	echoDebug("&lt;green&gt;[testMovement: " .. tostring(testMovement) .. "]\n")
	lastMovement=testMovement
end


-- if lastMovement was to open a door, pop again

if string.find(tostring(lastMovement), "^open ") then
	lastMovement = map:popMovement()
end


-- this function is called twice (because of potential inserts)
sendBufferedMovements()
sendBufferedMovements()


if lastMovement then
	if lastMovement == "enter" then
		expandAlias("@find", false)
	else
		map:update(lastMovement)
	end
end

if not roomPortal then
	if map:getRoom() == nil then
		map:setRoom( map:findRoomID( map:getRoomname(), map:getExits(), true) )
	
		--map:update( map:getRoom() )
		map:update(nil)
	end
end

if xexits == nil then
	cecho("&lt;red&gt;[Error: nil match on exits]\n")
end

-- Does the mapper think I am where the mud thinks I am?

local id= map:getRoom()
		
if not roomPortal and id ~= nil and not forceFind then
	local mapRoomName = string.gsub(tostring( getRoomName( id )) , " %(.+%)", "")
	
	-- remove (airy), (water), etc before comparing
	
	if mapRoomName ~= string.gsub(tostring( map:getRoomname() ) , " %(.+%)", "")   then
		if not charData:get("maperror", true) then
			cecho(string.format(" &lt;red&gt;[Error: mud '&lt;cyan&gt;%s&lt;red&gt;' doesn't match mapper '&lt;cyan&gt;%s&lt;red&gt;' at '&lt;cyan&gt;%d&lt;red&gt;'] ", map:getRoomname(), mapRoomName, id ) )
		end
	end
end

-- forceFind=nil

-- display vnum at the end of exits line
if charData:get("vnum", true) then
	if not roomPortal then
		if map:getRoom() ~= nil then
			cecho("&lt;forest_green&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s] ", " ", map:getRoom() ))
		else
			cecho("&lt;red&gt;" .. string.format("%" .. (20-string.len(xexits)) .. "s [%s] ", " ", "Map not in sync, type &lt;green&gt;@find &lt;red&gt;or &lt;green&gt;scan&lt;red&gt; to attempt resync"))
		end
	else
		local clairedroomid = map:findRoomID( roomName, getExitTable(xexits), true)
		local clairzone = map:findRoomArea( roomName, getExitTable(xexits) )

		if clairzone == nil then
			cecho("&lt;red&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s] ", " ", roomPortal))
		else
			if clairedroomid == nil then
				cecho("&lt;red&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s: &lt;green&gt;%s&lt;red&gt;] ", " ", roomPortal, clairzone))
			else
				cecho("&lt;red&gt;" .. string.format("%" .. (15-string.len(xexits)) .. "s [%s: %d &lt;green&gt;%s&lt;red&gt;] ", " ", roomPortal, clairedroomid, clairzone))
			end
		end
	end
end

if getHide() then
	cecho("&lt;blue&gt; [Hidden]")
end

echo("\n")

if map:countMovement() == 0 then
	if NyyLIB.tosend ~= nil then
		send(NyyLIB.tosend)
	end

 	NyyLIB.tosend=nil 
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>forcefind</name>
					<script>-- As you step into the ruby, there is a blinding flash of light!

--Your vision descends into darkness as your feel your soul pulled back into
--your mortal form. As the transference completes. you feel your body wracked
--with terrible pain. You open your eyes and take a first, shuddering breath.

scanned={}

--if timer:get("forcefind") then
--	return
--end

forceFind = true

tempTimer(1.5, [[expandAlias("@find", false)]])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Suddenly the darkness falls revealing different surroundings.</string>
						<string>You are instantaneously teleported nearby!</string>
						<string>You enter something and reappear elsewhere...</string>
						<string>You start to become less and less solid, until you reappear elsewhere!</string>
						<string>You recite a scroll of cave escape which turns to dust in your hands.</string>
						<string>You recite an ensorcelled scroll of the Mistwalker which turns to dust in your hands.</string>
						<string>Your soul is instantly whisked away from the dreary Fugue Plane when you</string>
						<string>Someone demands your presence NOW!</string>
						<string>has summoned you!</string>
						<string>You feel a Presence touch you, its divine hand cupping itself</string>
						<string>Your vision descends into darkness as your feel your soul pulled back into</string>
						<string>The world goes dark.  When you can see again, you are in your guild.</string>
						<string>You disembark this ship.</string>
						<string>OH NO!  Something has gone wrong!  You feel lost!</string>
						<string>forceful crunch of the landing.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You flee ([nsewud]).*</name>
					<script>-- currently moving
spell:setMoving(true)

-- erase spellqueue if any spells present
spell:eraseQueue()

scanned={}

map:update(matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You flee ([nsewud]).*</string>
						<string>You follow .* ([nsewud]).*</string>
						<string>You escape ([nsewud]).*</string>
						<string>You stop fighting and attempt to retreat to the ([nwes]).*!</string>
						<string>You find traces of tracks leading ([nsewud]).*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Failed movement</name>
					<script>-- failed room movement

-- Animated plants secure your feet and prevent your exit!

-- Alas, you cannot go that way. . . .


-- You're busy spellcasting! - follow has already processed
-- need to record last room/direction

--&lt; 104h/104H 118v/126V P: std &gt; 
--Bloogak lumbers down.
--You follow Bloogak down.

--A magic force blocks movement downwards.
--Irohple leaves down.

--&lt; 104h/104H 118v/126V P: std &gt; 

-- Changed to erase entire queue

--map:clearQueue() -- &lt;-- already sent movements still need to be processeed



-- need to pop last sent movement from queue

map:removeMovement()

-- Erase unsent movements from queue

map:trimMovement()

-- error above: What about movements already sent/not yet processed?</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>That isn't the direction to your guild, type look room to view</string>
						<string>Alas, you cannot go that way</string>
						<string>Nah... You feel too relaxed to do that...</string>
						<string>Perhaps you should get on your feet first?</string>
						<string>Oof!  It seems that .* is in your way.</string>
						<string>The .* seems to be closed.</string>
						<string>Sorry, you aren't allowed to do that in combat.</string>
						<string>There is no .* here.</string>
						<string>You are too exhausted</string>
						<string>You need a boat to go there.</string>
						<string>.* is blocking your path!$</string>
						<string>You would bash your brains out on the roof, better dismount.</string>
						<string>Stepping off .* at this height might not be such a good idea.</string>
						<string>humiliates you, and blocks your way.</string>
						<string>The passage is too tight to fly.</string>
						<string>You'd surely drown!</string>
						<string>An impenetrable wall of ice blocks passage</string>
						<string>preventing you from going</string>
						<string>You need to board a ship to travel the oceans.</string>
						<string>The entrance is locked and barred tight.</string>
						<string>There is no .* here.</string>
						<string>Try flapping your arms!  (Couldn't hurt)</string>
						<string>You can't drag something when you're flying.</string>
						<string>What do you want to drag?</string>
						<string>You are much too big to fit through the holes in the floor.</string>
						<string>You collapse under your carried load!</string>
						<string>A magic force blocks movement downwards.</string>
						<string>You are stuck in a huge spider web!</string>
						<string>Animated plants secure your feet and prevent your exit!</string>
						<string>Your mount is too exhausted for you to follow.</string>
						<string>You crawl past</string>
						<string>The flesh golem roughly grabs you and tosses you backwards!</string>
						<string>Something strikes out at you from the shadows!</string>
						<string>You're busy spellcasting!</string>
						<string>Sorry, you aren't allowed to do that in combat.</string>
						<string>a gate guard whispers 'We don't want your type here, get lost.'</string>
						<string>The unstable tunnel to the west has collapsed on itself. There is absolutely</string>
						<string>A shady old man whispers 'This area is far below you, unless you wish to fight me.'</string>
						<string>The deadly cold coming down the mountain's peak makes it impossible to progress any further.</string>
						<string>Alas, you can't go that way.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You sit down.</name>
					<script>-- can't be moving TODO: trying to spam recline?

map:clearQueue()

spell:setMoving(false)

setHide(false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You sit down.</string>
						<string>You drop to your belly.</string>
						<string>You sit down and relax.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Doorbash movement</name>
					<script>if matches[2] == "did" then
	map:update(NyyLIB.doorbash)
end

NyyLIB.doorbash=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You (did) it! The door budges under your weight, and you charge into a new place!</string>
						<string>You feel stupid, about to bash open doorway down?</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>scanlandmarks</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A portal of swirling clouds hovers here.</name>
						<script>-- set room on ethereal

--if map:getRoom() ~= nil then
--	return
--end

map:setRoom(88233)
centerview( map:getRoom() )

if command == "SCAN" then
	-- You scan north...
	local lineindex=1

	while string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") == nil do
		lineindex=lineindex+1

		if lineindex &gt; 150 then
			echoDebug("&lt;red&gt;[Unable to locate scan message]\n")
			return
		end
	end

	local scandir = string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") 

	local setroom = getRoomExits(88233)[NyyLIB.reversedirs[scandir]]

	--display(setroom)

	map:setRoom(setroom)
	centerview( map:getRoom() )

	--display("Found on scan in dir " .. scandir)
end

if string.match(command, "^[nsewud]$") then
	map:setRoom(88233)
	centerview( map:getRoom() )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^A portal of swirling clouds hovers here.( \(magic\))?$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A violent maelstrom swirls here, drawing in the unwary.</name>
						<script>-- plane of air 93607: A violent maelstrom swirls here, drawing in the unwary.

map:setRoom(93607)
centerview( map:getRoom() )

if command == "SCAN" then
	-- You scan north...
	local lineindex=1

	while string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") == nil do
		lineindex=lineindex+1

		if lineindex &gt; 150 then
			echoDebug("&lt;red&gt;[Unable to locate scan message]\n")
			return
		end
	end

	local scandir = string.match(getLines(getLineNumber()-lineindex, getLineNumber())[1], "^You scan ([a-z]+).*") 

	local setroom = getRoomExits(93607)[NyyLIB.reversedirs[scandir]]

	--display(setroom)

	map:setRoom(setroom)
	centerview( map:getRoom() )

	--display("Found on scan in dir " .. scandir)
end

if string.match(command, "^[nsewud]$") then
	map:setRoom(93607)
	centerview( map:getRoom() )
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^A violent maelstrom swirls here, drawing in the unwary.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>kenjin teleport</name>
						<script>-- kenjin proc teleport

map:setRoom(93537)
centerview( map:getRoom() )</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^Suddenly he points it at YOU! You feel your stomach churn as you$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>It is pitch black...</name>
					<script>-- room entry into a pitch black room

-- last command entered was look or scan - return
if string.find(command, "l ") == 1 or string.find(command, "look ") == 1 or command == "SCAN" then
	return
end

-- pop last movement (if there was one)

local lastMovement = map:popMovement()

if lastMovement then
	if lastMovement == "enter" then
		expandAlias("@find", false)
	else
		map:update(lastMovement)
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>It is pitch black...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tells you @room</name>
					<script>local roomid = map:getRoom()

if roomid ~= nil then
	local zoneid=tonumber(getRoomUserData(roomid, "zoneid") )

	mud:send("T " .. matches[2] .. " " .. roomid .. ", " .. getRoomName(roomid) .. " : " .. NyyLIB.areaTable[zoneid] .. "\n")
else
	mud:send("T " .. matches[2] .. " Map not currently in sync")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) tells you '@room'</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ice teleport</name>
					<script>-- 86574

map:setRoom(86574)
centerview( map:getRoom() )
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You awake to find yourself in a dark and unfamiliar site, the stench</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>RoomClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>RoomCapture</name>
					<script>-- location matters on this trigger to prevent double firing

-- terminate capture on blank line
if matches[1] == "" then
	disableTrigger("RoomCapture")

	if gaglook then
		eraseLine()
	end

	return
end

selectCurrentLine()
copy()
appendBuffer("roomBuffer")

if gaglook then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>StartRoomCapture</name>
					<script>--gaglook=nil

if not roomWindow:exists() then
	return
end

-- last command entered was look direction - return
if string.find(command, "L ") == 1 then
	return
end

-- room is from clair, looking in portal

for nx=1,6,1 do
	local testLine = getLines(getLineNumber()-nx, getLineNumber())[1]
	
	if string.find( testLine, "cast your sights far out") then
		return
	end

	if string.match( testLine, "You peer into a (.*) and see" ) then
		return
	end
end

-- last command entered was scan
if command == "SCAN" then
	return
end

if roomBuffer == nil then
	roomBuffer = createBuffer("roomBuffer")
end

clearWindow("roomBuffer")

enableTrigger("RoomCapture")

local exitLine = getLineNumber()
local lineOffset = 1


-- capture line prior to exits (room name in brief)
local roomline = getLines(exitLine-lineOffset, exitLine)[1]
local linecheck = string.find(roomline, "%[")

while linecheck ~= nil do
	lineOffset=lineOffset+1

	roomline = getLines(getLineNumber()-lineOffset, getLineNumber())[1]
	linecheck = string.find(roomline, "%[")

	if lineOffset &gt; 100 then
		cecho("&lt;red&gt;[StartRoomCapture: error]\n")
		return
	end
end

-- move to line prior to exits that doesn't start with a [:
moveCursor(0, exitLine-lineOffset)

local roomline = getLines(exitLine-lineOffset, exitLine)[1]

-- changed was "&gt; "
local linecheck = string.find(roomline, "&gt;")

-- previous line started with a prompt
if linecheck ~= nil then
	selectSection(linecheck+1, string.len(roomline)-linecheck-1)
else
	-- include full line in capture window
	selectCurrentLine()
end

-- this is the room title
copy()
appendBuffer("roomBuffer")

--display( getLines(getLineNumber()-lineOffset-5, getLineNumber()+2) )

if gaglook then
	eraseLine()
end

-- return to exits line
moveCursorEnd( "main" )

-- include full line in capture window
selectCurrentLine()

copy()
appendBuffer("roomBuffer")

if gaglook then
	eraseLine()
end

look:set("LOOKSTART")

--display(linecheck)
--display(roomline)

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#aa007f</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>^Exits: .*</name>
					<script>NyyLIB.torescue=""

roomCombat=false</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits: .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You cast your sights far out, into the realms!</name>
					<script>gaglook=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You cast your sights far out, into the realms!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GroupHP</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Group heal</name>
					<script>-- group heal
-- Rokpat summons a holy light that surrounds the entire group.
-- Vooku summons a healing light that surround the entire group.

-- should increase hp accordingly

spell:clear("cb", true) -- noAbort set

for k,char in pairs(groupList:pc()) do
	buff:del(char, "blind")
	buff:del(char, "blindness")
end

-- only send group command if in a group
if groupList:size() &gt; 1 then
	group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) summons a healing light that surround the entire group.</string>
						<string>(You) summon a healing light that surrounds the entire group.</string>
						<string>([A-Za-z]+) summons a holy light that surrounds the entire group.</string>
						<string>(Your) vision returns!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>call group:send</name>
					<script>-- You summon a holy light to surround Hosol and close his wounds.
-- Lilebeple summons a holy light to surround Tatris and close his wounds.
-- Diac summons a holy light to surround Kitra and close her wounds.

if matches[2] ~= nil and matches[2] ~= "You" then
	sendStatus(matches[2])
end

--if groupList:size() &gt; 1 and matches[2] ~= nil then
if groupList:size() &gt; 1 then
	--display("X")
	group:send()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>in a brilliant aura of holy power.</string>
						<string>a holy light to surround</string>
						<string>to heal a death kiss.</string>
						<string>([A-Za-z]+) group-says 'I have</string>
						<string>(You) don't see them here!</string>
						<string>flips head over heels.</string>
						<string>OUCH!  That really did HURT!</string>
						<string>has created a devastating blast of sand!</string>
						<string>says 'I have</string>
						<string>A harmonious combination of notes from</string>
						<string>You finish a verse of the song of healing.</string>
						<string>(hates) your guts!</string>
						<string>You lay your blessed hands upon</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Condensed</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Duplicate line filter</name>
					<script>-- this trigger will go off on every line recieved

if matches[2] == nil then
	return
end

-- don't echo gagged text

if isGagged(matches[2]) then
	eraseLine()
	return
end


if charData:get("condensed", true)["duplicate"] then
	local linecheck = string.find(matches[2], "^&lt; .* &gt; ")

	-- line on same line as prompt
	if linecheck ~= nil then
		local endprompt = string.find(matches[2], " &gt; ")		

		if endprompt+2 == string.len(matches[2]) then
			condenseLine(matches[2])
		else
			linecheck = string.find(matches[2], "&gt; ")+1

			if moveCursor(string.find(matches[2], "&gt;")+#("&gt;")-1, getLineNumber()) then
				--display( getLines(getLineNumber()-5, getLineNumber()) )
				
  			--demonnic.chat:append("GSAY")
				
				insertText("\n\n")

				moveCursorEnd( "main" )

				-- feedTriggers

				--demonnic.chat:append("GSAY")
			end
		end
	else
		condenseLine(matches[2])
	end
else
	-- duplicate is turned off, but line on same line as prompt still needs to be corrected

	local linecheck = string.find(matches[2], "^&lt; .* &gt; ")

	-- line on same line as prompt
	if linecheck ~= nil then
		local endprompt = string.find(matches[2], " &gt; ")		

		if endprompt+2 ~= string.len(matches[2]) then
			linecheck = string.find(matches[2], "&gt; ")+1

			if moveCursor(string.find(matches[2], "&gt;")+#("&gt;")-1, getLineNumber()) then
  				insertText("\n\n")
			
				-- feedTriggers
			end
		end
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Assorted Gags</name>
					<script>--As Peri's mount opens its mouth, flames lick out to sear a banedead's body!
--Peri's mount's baleful howl freezes a banedead is its tracks!

if charData:get("condensed", true)["misc"] then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>shaft of light streaking towards</string>
						<string>is bathed in scorching flames!</string>
						<string>is stunned by the horrific visions!</string>
						<string>A fire elemental revels in</string>
						<string>A huge beam of white light shines down from the</string>
						<string>moves about the room gathering</string>
						<string>The flames engulfing</string>
						<string>Your strike passes through</string>
						<string>is partially absorbed!</string>
						<string>The globe around your body flares as it bears the brunt</string>
						<string>only grazes .* dodges aside!</string>
						<string>is outside of the area of the blast!</string>
						<string>mount opens its mouth, flames lick out to sear</string>
						<string>baleful howl freezes</string>
						<string>says 'I must assist my friend!'</string>
						<string>.* recognizes .*, and charges to attack .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Combat gags</name>
					<script>if charData:get("condensed", true)["combat"] then
	if groupList:ingroup(matches[2]) or matches[2] == "you" or matches[2] == "You" or matches[2] == "" or matches[2] == nil then
		eraseLine()
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^([A-Za-z]+) barely wounds .*</string>
						<string>^([A-Za-z]+) misses .* with .*</string>
						<string>.* misses (you) with .*</string>
						<string>.* misses ([A-Za-z]+) with .*</string>
						<string>(You) parry .* lunge at you.</string>
						<string>(You) miss .* with .*</string>
						<string>^([A-Za-z]+) assists .* heroically.</string>
						<string>(You).* barely wounds .*</string>
						<string>backwards several feet with a powerful kick.</string>
						<string>^([A-Za-z]+) attempts to circle around .*</string>
						<string>^([A-Za-z]+) circles around .*</string>
						<string>^([A-Za-z]+) makes a nice ballet step .*</string>
						<string>.* dodges ([A-Za-z]+)'s attack.</string>
						<string>.* gasps in agony as ([A-Za-z]+) strikes at .*</string>
						<string>^([A-Za-z]+) grits his teeth and viciously headbutts.*</string>
						<string>.* partially deflects ([A-Za-z]+)'s lunge at .*</string>
						<string>partially blocks .* attack with .*</string>
						<string>attack with your shield!</string>
						<string>attack glances off your shield, but finds its mark!</string>
						<string>You dodge</string>
						<string>dodges your futile attack.</string>
						<string>You partially deflect</string>
						<string>attack only grazes you as you dodge aside!</string>
						<string>You score a CRITICAL HIT!</string>
						<string>^You deflect .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ItemProcGags</name>
					<script>--Suddenly the room is filled with dark clouds, the very ground before Rahas 
--apparantly not quite as it had seemed just a moment ago. You picture Rahas
--dashing through some mystical land, on his way to a demon infested dungeon.
--Just before he arrives at it's entrance, a whisper is about the air. The 
--trickery of Brandobaris is suddenly apparent! You blink and it is all gone.
--Only Rahas seems to be grining.

--Dharn swings the warmaul of celestial glory in a mighty arc, crushing
--into Forell Luckaun's body with a mighty blow.  The weapon glows
--fiercely at the impact, and that glow seems to intensify the
--strike.  The celestial strike hammers into Forell Luckaun,
--who sways under the impact.

-- and torso, granting you a reptilian quickstrike ability! Your eyes gleam

if charData:get("condensed", true)["items"] then
	eraseLine()

	if matches[2] == "slithering" then
		if matches[3] == "your" then
			cecho("\n&lt;blue&gt;[" .. whoami() .. " : the mystical circlet of the coiled serpent]\n")
		else
			local xname=string.sub(matches[3], 1, string.find(matches[3], "'")-1)

			cecho("\n&lt;blue&gt;[" .. xname .. " : the mystical circlet of the coiled serpent]\n")
		end
	end

	if matches[2] == "khanjari" then
		cecho("\n&lt;blue&gt;[proc: an enchanted khanjari dagger]\n")
	end

	if matches[2] == "screaming" then
		cecho("\n&lt;blue&gt;[proc: a glittering dagger of the Nurturing Matriarch]\n")
	end

	if matches[2] == "fanged" then
		cecho("\n&lt;blue&gt;[proc: red dragon fanged]\n")
	end

	if matches[3] == "warmaul" then
		cecho("\n&lt;blue&gt;[" .. matches[2] .. " : warmaul of celestial glory]\n")
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>A momentary brilliant glow originating from</string>
						<string>.* appearance. Countless serpents begin to uncoil,</string>
						<string>(slithering) and sliding their way down and around (.*) arms, neck,</string>
						<string>and torso, granting .* a reptilian quickstrike ability! .*</string>
						<string>a vivid yellow the brief enchantment begins to fade. Quickly as</string>
						<string>they descended, the serpents twist and twine their way back to the magic</string>
						<string>within their circlet.</string>
						<string>features twist in a grimace of absolute fury, as</string>
						<string>a warped broadsword tightly.  With a howl of rage,</string>
						<string>powerfully.  In a frenzy of howling fury</string>
						<string> squeezes the ironwood haft</string>
						<string>dwarven waraxe and wades fearlessly into battle.  Magic surges</string>
						<string>through the glowing golden runes as</string>
						<string>A sudden intense rush of physical fury spiderwebs its way up and down</string>
						<string>Physical power emanating from the tip of .* enchanted (khanjari) dagger</string>
						<string>races towards its wielder within a narrow strip of bright white light. A significant sounding</string>
						<string>BOOM reverberates between your ears as the light settles</string>
						<string>An eerie feeling creeps into your mind as a dark mystical power consumes</string>
						<string>wisps of feathery darkened light ooze forth from the blade</string>
						<string>enchanted (khanjari) dagger, surrounding</string>
						<string>is taken by its ferocity and is plunged into a trance.</string>
						<string>reappears, grinning as</string>
						<string>A (screaming) can be heard for miles as</string>
						<string>glittering dagger glows brightly, and then</string>
						<string>is bathed in scorching flames!</string>
						<string>jumps back and holds a red dragon fanged dagger out towards</string>
						<string>The blade becomes a blur as it rapidly changes into the head of Ilxarzzinazzium</string>
						<string>himself.  With a load roar the head lashes out towards</string>
						<string>it's giant maw.  As suddenly as the head appeared it dissappears back into</string>
						<string>a red dragon (fanged) dagger leaving no trace of itself.</string>
						<string>A red dragon (fanged) dagger suddenly begins glowing brightly and vibrating.</string>
						<string>The blade of the dagger slowly opens and begins to emerse the whole room in</string>
						<string>bright yellow, red, and white flames that scorch everything in sight.</string>
						<string>swings the warmaul of celestial glory in a mighty arc, colliding</string>
						<string>The weapon glows fiercely at the</string>
						<string>impact, and the radiance seems to reach out and</string>
						<string>in a brilliant luminescence. the warmaul of celestial glory continues</string>
						<string>body, crushing through unimpeded</string>
						<string>from the might of its wielder's swing.  The aura around</string>
						<string>intensifies, building to a painful glare as</string>
						<string>the holy power unleashed by the celestial strike.</string>
						<string>body sems to dissolve, slumping down into a lifeless corpse as</string>
						<string>withdraws the (warmaul) of celestial glory</string>
						<string>([A-Za-z]+) swings the (warmaul) of celestial glory in a mighty arc, crushing</string>
						<string>body with a mighty blow.  The weapon glows</string>
						<string>fiercely at the impact, and that glow seems to intensify the</string>
						<string>strike.  The celestial strike hammers into</string>
						<string>who sways under the impact.</string>
						<string>a vivid yellow as the brief enchantment begins to fade. Quickly as</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SpellGags</name>
					<script>-- A doppelganger of 

-- falters as its undead force is seized and drained!


-- screams in exquisite pain as a lightning bolt unleashed by

if charData:get("condensed", true)["spells"] then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>sends out an almost endless carpet of arachnoids and insects to kill</string>
						<string>burst of lava coats</string>
						<string>directs waves of freezing ice towards</string>
						<string>storm of hail.</string>
						<string>swarm of fiery meteors.</string>
						<string>incendiary cloud torches</string>
						<string>bursts into red hot flames from</string>
						<string>reels from the sonic assault!</string>
						<string>blasting winds and snow chill</string>
						<string>sends a rainbow of prismatic spray from</string>
						<string>shivers slightly.</string>
						<string>staggers slightly, but manages to keep</string>
						<string>staggers and almost falls!</string>
						<string>looks a little less chilled.</string>
						<string>calls forth a massive wave of ice!</string>
						<string>electrical blast causes</string>
						<string>The tendrils of electricity wrapped around</string>
						<string>explodes in a shower of frost!</string>
						<string>shaft of light streaking towards</string>
						<string>sunray strikes</string>
						<string>The lightning bolt slams into</string>
						<string>looks really sick, and shivers uncomfortably.</string>
						<string>whose swings contact only air!</string>
						<string>body begins to rot and putrify under the assault of</string>
						<string>ancestors rend</string>
						<string>The flames engulfing .* subside.</string>
						<string>spell is partially absorbed by</string>
						<string>movements slow from the freezing cold!</string>
						<string>A torrent of howling souls rips at</string>
						<string>magic has been dispelled!</string>
						<string>The area erupts in a massive INFERNO of heat and flames!</string>
						<string>sends eight shimmering multicolored beams of light spraying</string>
						<string>with a storm of ice.</string>
						<string>.* shudders violently as .* is shattered!</string>
						<string>A massive stone rises from below</string>
						<string>Your ancestral spirits rend</string>
						<string>A splash of water sprays</string>
						<string>is coated in crimson ooze.</string>
						<string>shudders in agony as .* thunderblast jolts .*</string>
						<string>swarm of phantasmal blades slashes</string>
						<string>shudders in pain from the searing winds of</string>
						<string>waves of freezing ice towards</string>
						<string>burst of negative energy!</string>
						<string>You wave the gasses towards</string>
						<string>directs waves of fire toward</string>
						<string>The pummeling violence of hail echoes through the region!</string>
						<string>Waves of heat seem to drink the water right out of your bones!</string>
						<string>Then leaps and blasts into</string>
						<string>You fill .* with the fiery power of death!</string>
						<string>covered in the crimson fluid.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Dragon gags</name>
					<script>if charData:get("condensed", true)["dragon"] then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>is shocked by the electrical charge!</string>
						<string>chokes and gasps on the poison fumes!</string>
						<string>is splattered by the sizzling acid!</string>
						<string>is slammed by the powerful blast of air!</string>
						<string>staggers in pain as the massive tail smashes into</string>
						<string>is knocked down on</string>
						<string>is chilled by the glacial frost!</string>
						<string>is scorched by the intense flames!</string>
						<string>screams in terror as</string>
						<string>is gassed by</string>
						<string>breathes cold.</string>
						<string>is partly turned to ashes, as</string>
						<string>is drained by the negative energy!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>archery gags</name>
					<script>if charData:get("condensed", true)["arrows"] then
	if groupList:ingroup(matches[2]) or matches[2] == "" or matches[2] == nil then
		eraseLine()
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) fires .*</string>
						<string>([A-Za-z]+)'s arrows are turning into large shards of ice as they are fired!</string>
						<string>ammunition, but doesn't seem to find any.</string>
						<string>Crack! It impacts on</string>
						<string>is struck by the hail of thorns!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ItemProcGags (2)</name>
					<script>--Jazarr slightly wounds a baby green dragon with his strong bludgeon.
--[proc: a four-headed battleaxe of abyssal doom]
--shudder pitifully as he fights to cling to conciousness, when
--at the very last moments of effectiveness, the wave changes form.
--It shoots out tens of tiny thin wisps of energy, each alike and
--writhing in unison as they wend their way up a baby green dragon's body,
--forming into a compact mass. Growing double upon itself, the mass
--soon consumes a baby green dragon, turning him into a quivering mound of
--... nothing.
--a baby green dragon is dead! R.I.P.

--shudder pitifully as he fights to cling to conciousness. As the
--assault begins to fade, Lavis Ryl is unable to recover and falls
--to the ground. As you watch, the space all around their body
--shrinks and expands nearly constantly. Unable to withstand the
--massive forces directed at him, Lavis Ryl ceases the struggle
--at last and the magics release their hold.

--You scream in pain as your wrists are sliced open within your own gauntlets!
--Blood starts dripping down your arms as your vision blurs, causing you
--to fly into a maddening rage. Your entire world turns crimson as the intense
--fury of battle overwhelms you!

--As the nasty spikes on your gauntlets tear into the flesh of your opponent
--something inside your head triggers a seemingly infinite loop of carnage,
--repeating itself over and over. Your movement speed increases with every loop
--as you focus in on the bloodshed.

--Suddenly the room is filled with dark clouds, the very ground before Rahas 
--apparantly not quite as it had seemed just a moment ago. You picture Rahas
--dashing through some mystical land, on his way to a demon infested dungeon.
--Just before he arrives at it's entrance, a whisper is about the air. The 
--trickery of Brandobaris is suddenly apparent! You blink and it is all gone.
--Only Rahas seems to be grining.

--Enona's an enchanted khanjari dagger. As the finger-like tendrils writhe and wriggle
--their way up her arms, Enona is infused with a surprising finesse of movement.

--Nukakukac's eyes flash green, and he grins evilly.  Venomous toxins
--ooze from the dread gythka, and cause the blade to acquire an
--oily sheen.  The toxins are forced into Seipora Rein's bleeding wounds
--as Nukakukac slashes wildly.
--Nukakukac sends a small amount of caustic goo flying from his dread gythka,
--hitting Corland Deepforge squarely in the chest.

--An arched and jagged wave of negative energy lashes out in a great
--cone from the massive quadribladed axe wielded by Lilpekal. The
--space between Lilpekal and Corland Deepforge seems to spin wildly as the
--cone of energy penetrates its stunned victim. Corland Deepforge begins to
--shudder pitifully as he fights to cling to consciousness.

if charData:get("condensed", true)["items"] then
	eraseLine()

	if matches[2] == "bloodstone" then
		cecho("\n&lt;blue&gt;[proc: a bloodstone studded shortsword]\n")
	end

	if matches[2] == "crimson" then
		cecho("\n&lt;blue&gt;[proc: a glowing crimson dagger]\n")
	end

	if matches[2] == "gythka" then
		cecho("\n&lt;blue&gt;[proc: the enchanted dread gythka of the thri-kreen]\n")
	end

	if matches[2] == "quadribladed" then
		cecho("\n&lt;blue&gt;[proc: a four-headed battleaxe of abyssal doom]\n")
	end

	if matches[2] == "gauntlets" then
		cecho("\n&lt;blue&gt;[" .. whoami() .. " : a pair of berserker battle gauntlets &lt;green&gt;(stat increase)&lt;blue&gt;]\n")
	end

	if matches[2] == "spikes" then
		cecho("\n&lt;blue&gt;[" .. whoami() .. " : a pair of berserker battle gauntlets (hitall)]\n")
	end

end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>rush suddenly, pivoting around on the ball</string>
						<string>foot to reverse</string>
						<string>With a sudden feint,</string>
						<string>attack routine with a dizzying flourish.</string>
						<string>slashes a (bloodstone) studded shortsword towards</string>
						<string>flinches back reflexively.  Paired sets of runes along</string>
						<string>spins about agilely, driving a powerful slash into</string>
						<string>body with a bloodstone studded longsword.  As the blade is wrenched clear of</string>
						<string>^the wound, .*</string>
						<string>glowing (crimson) dagger bathes the room in eerie crimson light as a scathing beam</string>
						<string>of pulsing pale energy fires from the blade at</string>
						<string>of pulsing green energy fires from the blade at</string>
						<string>nearly trips and falls.</string>
						<string>glowing crimson dagger draws green energy into itself.</string>
						<string>The dagger bursts into brilliant crimson fire which engulfs</string>
						<string>of pulsing dark energy fires from the blade at</string>
						<string>eyes flash green, and</string>
						<string>ooze from the dread (gythka), and cause the blade to acquire an</string>
						<string>oily sheen.  The toxins are forced into</string>
						<string>slashes wildly.</string>
						<string>sends a small amount of caustic goo flying from .* (gythka)</string>
						<string>hitting .* squarely in the chest.</string>
						<string>An arched and jagged wave of negative energy lashes out in a great</string>
						<string>cone from the massive (quadribladed) axe wielded by</string>
						<string>seems to spin wildly as the</string>
						<string>cone of energy penetrates its stunned victim.</string>
						<string>fights to cling to consciousness.</string>
						<string>You scream in pain as your wrists are sliced open within your own (gauntlets)!</string>
						<string>Blood starts dripping down your arms as your vision blurs, causing you</string>
						<string>to fly into a maddening rage. Your entire world turns crimson as the intense</string>
						<string>fury of battle overwhelms you!</string>
						<string>As the nasty (spikes) on your gauntlets tear into the flesh of your opponent</string>
						<string>something inside your head triggers a seemingly infinite loop of carnage,</string>
						<string>repeating itself over and over. Your movement speed increases with every loop</string>
						<string>as you focus in on the bloodshed.</string>
						<string>shudder pitifully as he fights to cling to conciousness. As the</string>
						<string>assault begins to fade, </string>
						<string>to the ground. As you watch, the space all around their body</string>
						<string>shrinks and expands nearly constantly. Unable to withstand the</string>
						<string>massive forces directed at </string>
						<string>at last and the magics release their hold.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ItemProcGags (3)</name>
					<script>--cone from your massive quadribladed axe. The space between you and
--penetrate her body. Still, she shudders pitifully, trying to cling to
--consciousness as the incredible power finally begins to subside.


--A moonblade with a golden hilt blurs into motion, striking
--flurry of attacks slices open cross-cuts across
--slides a moonblade with a golden hilt across the wound
--to inflict even greater damage.
--The runes along a moonblade with a golden hilt abruptly glow fiercely, emitting a
--warm glow that drifts across
--its body, and a loud sizzling sound can be heard as its body dissolves
--under the positive energy.
--seems to wilt under the positive energy discharge, cringing back away from the glare.



--Tafi kneels to the ground, wrapping her cloak around her body, chanting
--softly.  Smoke begins to issue from her cloak and begins to swirl around her 
--entire body, obscuring her in a swirling maelstrom of colors.  You see
--small disturbances in the column of smoke, tails flying out, wings breaking

--dragons are spinning around Tafi in the smoke, each representing a 
--different color.  The dragons suddenly break out of the column, and take spots 
--a few feet away from Tafi, their heads pointing down at her, their wings softly 
--beating. In unison, they all breathe their magic onto her, white, red, black
--blue and green breath slams into her resting body, disappating the smoke column
--and creating an aura around her, coating her with their basic elemental essence.
--The five dragons then begin to swirl around her, picking up speed, until they are 
--just a blur.  Then each swirling color breaks off from the group, flying into
--her cloak, reverting to the depiction of the dragon they represented.

--Xerena jumps back and holds both of her red dragon fanged daggers out
--in front of her. The blades of the daggers begin to glow and ignite in
--flames. A billowing vortex opens up and unleashes images of Ilxarzzinazzium,
--Fierrosa, Infernos, and Scorxariam into the room.  The dragons savagely tear at
--everything in sight with their giant talons. Fire blankets the battlefield
--searing everything.  Giant spiked tails flail about haphazardly crushing
--anything they hit!



--You take a few steps back as you notice Razz's greaves explode in a 
--shower of frost, only to reform about him as rotating blades of
--eternal ice. Even from a distance you can feel the deadly cold's touch
--sting your face as the jagged ice shards gyrate furiously. It would be
--foolish to move any closer to him.

if charData:get("condensed", true)["items"] then
	eraseLine()

	if matches[2] == "khanjari" then
		cecho("\n&lt;blue&gt;[proc: an enchanted khanjari dagger]\n")
	end

	if matches[2] == "greaves" then
		cecho("\n&lt;blue&gt;[proc: a set of frozen ice shard greaves]\n")
	end

	if matches[2] == "Vaprak" then
		cecho("\n&lt;blue&gt;[proc: stupid legging proc]\n")
	end


end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>softly.  Smoke begins to issue from</string>
						<string>in a swirling maelstrom of colors.  You see</string>
						<string>small disturbances in the column of smoke, tails flying out, wings breaking</string>
						<string>dragons are spinning around </string>
						<string>different color.  The dragons suddenly break out of the column, and take spots</string>
						<string>, their heads pointing down at</string>
						<string>beating. In unison, they all breathe their magic onto</string>
						<string>blue and green breath slams into </string>
						<string>and creating an aura around</string>
						<string>The five dragons then begin to swirl around</string>
						<string>just a blur.  Then each swirling color breaks off from the group, flying into</string>
						<string>cloak, reverting to the depiction of the dragon they represented.</string>
						<string>(greaves) explode in a</string>
						<string>shower of frost, only to reform about </string>
						<string>eternal ice. Even from a distance you can feel the deadly cold's touch</string>
						<string>sting your face as the jagged ice shards gyrate furiously. It would be</string>
						<string>foolish to move any closer to</string>
						<string>A ghostly portal suddenly opens, and a tall spectral troll steps out. He nods</string>
						<string>and whistles. The ancient ghost of a venerable silver dragon appears</string>
						<string>high above. It cries out, and a woosh of infernal energy radiates about the area</string>
						<string>augmenting those whomm are acknowledged by (Vaprak).</string>
						<string>Icis the Frigid snaps into visibility...and pats</string>
						<string>A wild elf of Darktree appears from behind a tree.</string>
						<string>An infernal giant strides in...and kicks</string>
						<string>A goblin tinker sneaks up and stabs</string>
						<string>who temporarily ducks out of sight.</string>
						<string>gasps and turns pale as an iron golem passes by.</string>
						<string>A group of elite soldiers march up and salute</string>
						<string>A lightning elemental flies in...and embraces</string>
						<string>kneels to the ground, wrapping</string>
						<string>the edges of the column, quiet grumblings breaking the silence.  Five tiny</string>
						<string>an enchanted (khanjari) dagger. As the finger-like tendrils writhe and wriggle</string>
						<string>is infused with a surprising finesse of movement.</string>
						<string>blinks as if</string>
						<string>A moonblade with a golden hilt blurs into motion, striking</string>
						<string>flurry of attacks slices open cross-cuts across</string>
						<string>slides a moonblade with a golden hilt across the wound</string>
						<string>to inflict even greater damage.</string>
						<string>The runes along a moonblade with a golden hilt abruptly glow fiercely, emitting a</string>
						<string>warm glow that drifts across</string>
						<string>its body, and a loud sizzling sound can be heard as its body dissolves</string>
						<string>under the positive energy.</string>
						<string>seems to wilt under the positive energy discharge, cringing back away from the glare.</string>
						<string>it's giant max.  The head of Ilxarzzinazzium chews through</string>
						<string>spits the lifeless, partially eatten body on the ground.  As suddenly as the head appeared,</string>
						<string>is scorched by the storm of fire.</string>
						<string>cone from your massive quadribladed axe. The space between you and</string>
						<string>shudders pitifully, trying to cling to</string>
						<string>consciousness as the incredible power finally begins to subside.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>SpellGags (2)</name>
					<script>-- screams in exquisite pain as a lightning bolt unleashed by

if charData:get("condensed", true)["spells"] then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>screams in exquisite pain as a lightning bolt unleashed by</string>
						<string>Bits of flesh fall to the floor as</string>
						<string>exposed skin shrivels and cracks in the extreme heat.</string>
						<string>his body, and a loud sizzling sound can be heard as his body dissolves</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Consent</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bitel has revoked her consent.</name>
					<script>consent:set( matches[2], nil)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) has revoked (his|her|its) consent.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>consent triggers</name>
					<script>-- Thaemos is consenting you.

consent:set(matches[2], true)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z]+) is consenting you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Corpse of Ilinal is lying here.</name>
					<script>-- ressurect corpses if have consent, not fighting, autores enabled, and spellcast enabled

local charname = matches[3]

if groupList:ingroup( charname ) then
	if consent:get(charname) then

		-- should only echo if not gagged
		if not gaglook then
			cecho(" &lt;green&gt;(consented)")
		end

		if not checkMask("cle") or not charData:get("autocast") then
			return
		end

		-- last command entered was look direction or scan - return  TODO: clair also
		if string.find(command, "L ") == 1 or string.find(command, "l ") == 1 or string.find(command, "look ") == 1 or command == "SCAN" then
			return
		end

		if charData:get("autores") and not inCombat() then
			-- mark as to res

			if getSpellCount("resurrect") &gt; 0 then
				spell:setNext("resu " .. matches[3])
			end
		end
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(Corpse) of ([A-Za-z]+) is lying here.</string>
						<string>(drags) corpse of ([A-Za-z]+) along behind .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Sounds</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>tells you</name>
					<script>sound("320181__dland__hint.wav",nil,true)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>tells you</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ressurect sound</name>
					<script>-- open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving
-- hand reaching down to touch ([A-Za-z]+) and .*
-- When it at last clears ([A-Za-z]+) stands before you, looking extremely tired!
-- ([A-Za-z]+) takes a first shuddering breath and rises from the dead. 

sound("139025__rj10328__131659-bertrof-game-sound-intro-to-game-80921-justinbw-buttonchime02up-4.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>open and ([A-Za-z]+) takes a deep breath. The radiance dissipates, leaving</string>
						<string>hand reaching down to touch ([A-Za-z]+) and .*</string>
						<string>([A-Za-z]+) takes a first shuddering breath and rises from the dead. </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Lilithelle drags corpse of Venumma along behind her.</name>
					<script>-- Yinelinol drags corpse of Kitra along behind him.
-- Misi drags corpse of Kitra along behind her.

-- Send consent request to corpse if person dragging was not cleric,
-- and corpse owner is grouped

-- Lilabipple drags corpse of General Edmund Blitz along behind her.

if charData:get("echodrag") then
	if groupList:ingroup(matches[2]) and whoclass(matches[2]) ~= "Cle" and groupList:ingroup(matches[3]) then
		mud:send("t " .. matches[3] .. " consent")
	end
end

-- corpse drag sound
sound("327909__ruonvniekerk__dragging-on-floor.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?^(.*) drags corpse of (.*) along behind .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>looting coins</name>
					<script>-- looting coins
sound("343462__rocotilos__real-coin-drop.wav")

-- look:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* gets a small pile of coins from corpse of .*</string>
						<string>.* gets a few coins from corpse.*</string>
						<string>You get a few coins from corpse.*</string>
						<string>You get a small pile of coins from corpse.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>inferno sound</name>
					<script>sound("45809__themfish__gas-fire-catch.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:&lt; .* &gt; )?The area erupts in a massive INFERNO of heat and flames!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>dragon roar</name>
					<script>-- A black dragon scout spreads his wings and ROARS, filling your heart with terror!
-- A young red dragon spreads his wings and ROARS, filling your heart with terror!

-- TODO - tiamat - https://www.freesound.org/people/tambascot/sounds/203105/


--display("dragon sound")

sound("85568__joelaudio__dragon-roar.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* wings and ROARS.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You are burned as you hit</name>
					<script>sound("368014__trngle__burning-match-into-water.wav")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You are burned as you hit</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>MobAlerts</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>An ogre shaman from Faang watches you closely.</name>
						<script>sound("72127__kizilsungur__sweetalertsound3.wav")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>An ogre shaman from Faang watches you closely.</string>
							<string>A servant of the Keep's lady is here tending official business.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Rares</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A shimmering portal of emerald mist floats in the air here.</name>
						<script>-- zoar portal</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>A shimmering portal of emerald mist floats in the air here.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You find</name>
					<script>-- You find a secret exit south!</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You find .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>An ice weird utters the words, 'iuophwabraz'.</name>
				<script>-- should be cleric only

if checkMask("cle") then
	spell:setNext("sp weird")
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>weird utters the words, 'iuophwabraz'.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>MobCapture</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Dragor Keenblade is a medium-sized level 56 shield dwarf. Are you mad!?</name>
					<script>mobs = mobs or {}

conSent=nil

-- room number : map:getRoom()
-- mobname
-- keywords (list)

local roomid = map:getRoom()

local mobname = matches[2]:trim()
local mobsize = matches[3]
local moblvl = matches[4]
local mobrace = matches[5]


if roomid ~= nil then
	mobs[roomid] = {[mobname]={moblvl,mobsize,mobrace} }
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>([A-Za-z '-]+) is a ([A-Za-z]+)-sized level ([0-9]+) (.*)[.].*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>They're not here!</name>
					<script>conSent=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>They're not here!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>PracticeSkills</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capture skills</name>
					<script>-- meditate                  (bad)           (21) 4 g, 1 s, and 1 c coins

-- mounted combat            (neophyte)      (8) 1 s coin

--display("Z")

toPractice = toPractice or {}

local skillname = matches[2]

if skillname ~= nil then
	skillname = skillname:trim()
	--display(skillname)
else
	display("error")
	display(matches)
	--display(matches)
	return
end

toPractice[skillname] = true
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.+) +\((bad|unlearned|neophyte|poor|very\sgood|below\saverage|average|above\saverage|good)\) +\([0-9]+\) .*coin.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capture scribable spells - trainer</name>
					<script>toScribe = toScribe or {}

local spellname = matches[2]:trim()

toScribe[spellname] = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) +([0-9]+)(nd|rd|th) circle [0-9].*coin.*</string>
						<string>^(.*) +1st circle $</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You practice 'specialize invocation' for a while...</name>
					<script>mud:send("prac " .. matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You practice '(.*)' for a while...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You don't feel comfortable enough to start to scribe.</name>
					<script>mud:send("rest")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You don't feel comfortable enough to start to scribe.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>scribenext</name>
					<script>-- scribe next
for k,v in pairs(toScribe) do
	mud:send("prac " .. k)
--	mud:send("scribe " .. k)
	toScribe[k]=nil
	return
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You finish scribing spell</string>
						<string>You already have that power in your spellbook.</string>
						<string>You already have that spell in your spellbook.</string>
						<string>You can't learn that power.</string>
						<string>You don't have that spell in any of your books or scrolls in learnable form!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>copyspells</name>
					<script>-- Detect Invisibility        1st circle [in spellbook]

toScribe = toScribe or {}

local spellname = matches[2]:trim()

toScribe[spellname] = true</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) +([0-9]+)(nd|rd|th) circle \[in spellbook\]</string>
						<string>^(.*) +1st circle $</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Resting now will most likely lead to your final rest!</name>
				<script>-- in combat, though prompt might have yet to update</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Resting now will most likely lead to your final rest!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>force switch</name>
				<script>--An (ice) golem .*, fighting
-- removed in ice^ gf only

if matches[2] == "ice" and map:getCurrentZone() ~= "The Golem Forge" then
	return
end

if prompt:get("enemy") ~= matches[2] then
	mud:send("kill " .. matches[2] )
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The (nightwing) .* fighting .*</string>
					<string>An (ice) golem .*, fighting</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Followers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Follower summary for</name>
					<script>-- start of followers on screen

--Follower summary for Nyyrazzilyss:
--Number of Followers: 1

--NPC:
--   274/274   HP  137/137  MV      + an opulent merchant (merchant opulent)


followers = matches[2]

pet:reset()

enableTrigger("endfollowers")
enableTrigger("capturefollower")
enableTrigger("gagpcfol")

if gagfollowers then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Follower) summary for .*:$</string>
						<string>You have no followers.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endfollowers</name>
					<script>-- disable trigger on first prompt

-- followers command has been sent/received
followersSent=nil

gagfollowers=true

disableTrigger("capturefollower")
disableTrigger("endfollowers")
disableTrigger("gagpcfol")

pet:cleanNames()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capturefollower</name>
					<script>--   2505/2505  HP  152/152  MV      + a gray slaad (gray slaad anvil)
--   2471/2569  HP  192/192  MV      + a hell hound (hell hound direraidermount wolf)
--     72/72    HP  167/167  MV      + a pack pony (pony pack)"a pack pony"
--  2317/2401  HP  197/197  MV      + a zealous griffon (griffon zealous mount paladinmount)
--  539/539   HP  152/152  MV      + the ghost of a human noble (ghost undead)
--   849/518   HP  153/153  MV      + the spectre of a human noble (spectre undead)

--	  237/237   HP  119/119  MV      + a dapper noble (noble dapper)
--    47/255   HP  120/120  MV      - a dapper noble (noble dapper)


--PC:
--   303/303   HP  106/106  MV      + Vivizaza
--   538/538   HP  133/137  MV      + Kurrak
--   235/235   HP  135/135  MV      - Nonfanos


local keywordlist=matches[6]


local keywords= string.split(keywordlist, " ")

local keyword=keywords[1]

local fullname=matches[5]:trim()

local inroom = matches[4] 	-- is the pet in the current room +=yes, -=no

if pet:isNamed( keywordlist ) then
	keyword= pet:isNamed(keywordlist)
	-- confirm name used

	pet:confirmName(keyword)
end

-- name un-named pets
if #keywords == 2 then
	mud:send("FOLLOWERS name " .. keyword .. " " .. pet:generateNumberName(keyword) )
end

pet:add(keyword, fullname, tonumber(matches[2]), tonumber(matches[3]), inroom, keywords )

-- set pet as being in this room
if inroom == "+" then
	pet:setRoom(keyword, map:getRoom() )
else
	-- use last known room for pet
	pet:setRoom(keyword, pet:getOldRoom(keyword) )
end



if gagfollowers then
	eraseLine()
end

if inroom == "-" then
	cecho("\n&lt;blue&gt;[&lt;green&gt;" .. string.title(fullname) .. " &lt;blue&gt;is not in the room]\n")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ *([-0-9]+)/([0-9]+) +HP +[0-9]+/[0-9]+ +MV *([+-]) (.*)\((.*)\)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>starts/stops following you.</name>
					<script>--You breathe life into corpse of a frost giant warrior with the awesome power of your art.
--The wight of a frost giant warrior starts following you.
-- The spectre of a human noble starts following you.

if matches[2] == "otherworldly" then
	mud:send("O followers snap")
end

gagfollowers=true

sendFollowers()
group:send()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>starts following you.</string>
						<string>Smoke begins to pour out of your bracer, swirling around you in a dizzying</string>
						<string>stops following you.</string>
						<string>You feel the presense of an (otherworldly) being enter the room.</string>
						<string>That person isn't here.</string>
						<string>hates your guts!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>One, is the loneliest number...</name>
					<script>-- You have no followers.

pet.followers = {}
pet.used = {}

if checkMask("fighter") then
	mount:setMounted(false)
	mount:set(nil)
end

group:send()

if gagfollowers then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>One, is the loneliest number...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>*, fighting ({@NyyLIB/RescueListClass/rescuelist|YOU}){!|.}</name>
					<script>local who = matches[2]

local petrescue=rescuelist:get()

-- last command entered was too look in a direction - return
if string.find(command, "look ") == 1 or string.find(command, "l ") == 1 then
	return
end

-- combat is occuring in this room
roomCombat=true

if petrescue == nil then
	return
end

if who == "YOU" then
  who = whoami()
else
	if table.contains(petrescue, who) == false then
		return
	end
end

if charData:get("petrescue") ~= "NONE" then
	if who == whoami() then
		NyyLIB.torescue=whoami()
		return
	end
end

if charData:get("petrescue") == "ALL" then
	if NyyLIB.torescue ~= whoami() then
		local member  = table.index_of(petrescue, who)
		local already = table.index_of(petrescue, NyyLIB.torescue)

		if NyyLIB.torescue == "" then
			already=30
		end

		if member &lt; already then
			NyyLIB.torescue = who
		end
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*[,] fighting (.*)[.]</string>
						<string>.*[,] fighting (YOU)!.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ok.</name>
					<script>-- command has been sent to pet

petcommand=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Ok.$</string>
						<string>is busy, but will execute your order as soon as possible.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The ghost of a human noble completes its spell...</name>
					<script>-- spell completed</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The ghost of a human noble completes its spell...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Name (zzz) added to the ghost of a human noble successfully.</name>
					<script>-- This name is now assigned

pet:useName( matches[2] )
sendFollowers()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Name \((.*)\) added to (.*) successfully[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>followers gags</name>
					<script>if gagfollowers then
	eraseLine()
end

</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Number of Followers:.*</string>
						<string>^NPC:$</string>
						<string>You have no followers.</string>
						<string>^PC:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>pet spellcasting</name>
					<script>-- The wraith of a human noble completes its spell...</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) completes its spell...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The spectre of a human noble heroically rescues the wight of a human noble.</name>
					<script>-- The spectre of a human noble heroically rescues the wight of a human noble.

if pet:member(matches[2]) then
	sendFollowers()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* heroically rescues (.*)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The spectre of a human noble fails miserably in its attempt to rescue you.</name>
					<script>-- The spectre of a human noble fails miserably in its attempt to rescue you.

local name=pet:member(matches[2])

if name then
	mud:send("ORDER " .. name .. " rescue " .. whoami() )
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) fails miserably in its attempt to rescue you.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>ghost getting attacked</name>
					<script>--A disgusting slithering vine badly wounds the ghost of a shambling mound with its powerful bite.

-- ghost getting attacked

local ghostname=pet:member(matches[2])

if ghostname and not ghostRescue then
	if pet:status("spectre") then
		local petname= pet:getTable("spectre")[1]

		ghostRescue = true

		mud:send("ORDER " .. petname .. " rescue " .. ghostname)
	end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.* wounds (the ghost .*) with .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The spectre of a human noble heroically rescues the ghost of a human noble.</name>
					<script>ghostRescue=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^The spectre .* heroically rescues the ghost .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Aren't we funny today...</name>
					<script>sendFollowers()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Aren't we funny today...</string>
						<string>has quit the game, consent lost.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>follower movement</name>
					<script>-- The skeleton of a dapper noble shambles in from the south.
-- The skeleton of a dapper noble shambles in from below.
-- A gray slaad flies in from the south.
-- The spirit worg flies in from the east.

-- The shadow of a dockhand flies in from the west.

-- TODO: multiple pets with identical names

local shortname= idMob(matches[2])
--local petname= pet:member( matches[2] )

for k,name in pairs( pet:getTable(shortname) ) do
	if pet:getRoom(name) ~= map:getRoom() then
		pet:setRoom(name, map:getRoom() )
		pet:setInRoom(name, true)
		return
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) shambles in from .*[.]</string>
						<string>^(.*) flies in from .*[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>follower ordered movement</name>
					<script>-- The spectre of a human noble flies west.

local roomid = map:getRoom()
local petname = pet:member(matches[2])
local dirmoved = matches[3]

if roomid == nil or not petname then
	return
end

-- move pet to bordering room

pet:setRoom(petname, getRoomExits(roomid)[dirmoved])
pet:setInRoom(petname, false)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) flies (north|south|east|west|up|down)[.]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>gagpcfol</name>
					<script>-- ^ *([-0-9]+)/([0-9]+) +HP +[0-9]+/[0-9]+ +MV *([+-]) (.*)\((.*)\)$

-- gag pc followers

if gagfollowers then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ *([-0-9]+)/([0-9]+) +HP +[0-9]+/[0-9]+ +MV *([+-]) (.*)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The shadow of a dockhand stands here.</name>
					<script>-- check current room

-- command ~= "look" then

if command ~= "L" and command ~= "LOOK" then
	return
end

local shortname= idMob(matches[2])
--local petname= pet:member( matches[2] )

for k,name in pairs( pet:getTable(shortname) ) do
	if pet:getRoom(name) ~= map:getRoom() then
		pet:setRoom(name, map:getRoom() )
		pet:setInRoom(name, true)
		return
	end
end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(.*) stands here.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Utilities</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>CapturePowers</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>powers list</name>
						<script>-- Sandblast                           Spell     Study      Level 46
powerslist = powerslist or {}

sortpowerslist={}

-- info needed: capture spellname, level



powerslist[#powerslist+1] = { matches[2]:trim(), matches[3]:trim()}

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>(.*)Spell     Study      Level ([0-9]+)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>capture name</name>
						<script>-- Name             : Sandblast

powername = matches[2]:trim()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Name             : (.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>capture alias</name>
						<script>-- Alias            : sb     

--

sortpowerslist = sortpowerslist or {}


-- info needed: powername, alias, chardata, function

local level=nil

if powerslist == nil then
	return
end


for nx=1, #powerslist, 1 do
	if powerslist[nx][1] == powername then
		level=powerslist[nx][2]
	end
end

if level == nil then
	display("Unable to find level")
	return
end

sortpowerslist[#sortpowerslist+1] = {to_snake(powername), matches[2]:trim(), level, "", ""}
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Alias            : (.*)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
				<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>spell powers v2</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList />
					<regexCodePropertyList />
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>spellname</name>
						<script>-- Elemental Fire Embodiment           [efe   ]   Study           10th circle

capSpellList = capSpellList or {}

capSpellList[#capSpellList+1] = matches[2]:trim()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>([A-Za-z ]+)\[[a-z ]{6}\]   Study           [0-9]0?(st|nd|rd|th) circle</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</TriggerGroup>
			</TriggerGroup>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Rugrag futilely tries to rescue Lilabipple!</name>
				<script>if groupList:ingroup(matches[2]) then
	pet:rescue(matches[3])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(.*) futilely tries to rescue (.*)!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Recharge</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>endrecharge</name>
					<script>disableTrigger("capturerecharge")
disableTrigger("endrecharge")

nogagRecharge=nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt;.*&gt;</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>The following powers are currently recharging:</name>
					<script>--The following powers are currently recharging:

-- - Eviscerate in 21 seconds 1 pulse 
-- - Sweeping Strike in none

enableTrigger("capturerecharge")
enableTrigger("endrecharge")

if not nogagRecharge then
	eraseLine()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The following powers are currently recharging:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>capturerecharge</name>
					<script>-- Sandstorm in ([0-9]+) seconds .*

--The following powers are currently recharging:

-- - Eviscerate in 21 seconds 1 pulse 
-- - Sweeping Strike in none
-- - Armor Splinter in 1 second 3 pulses 

--  - Furious Assault in 1 minute 6 seconds 

--  - Sandstorm in 5 minutes 45 seconds 1 pulse 
--  - Sandstorm in 2 minutes 2 seconds 2 pulses 

--  - Dominating Smite in none

local powername = to_snake(matches[2])

local timeleft

if matches[2] == "recharging" or matches[3] == "none" or matches[3] == "pulse" then
	timeleft=0
else
	if matches[4] == nil then
		timeleft = tonumber(matches[3])
	else
		timeleft = tonumber(matches[3])*60
		
		if tonumber(matches[4]) then
			timeleft = timeleft + tonumber(matches[4])
		end
	end
end

timer:set(powername, timeleft)


if not nogagRecharge then
	eraseLine()
end


-- cecho("&lt;red&gt; [" .. powername .. ":" .. timeleft .. "]\n")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> - ([A-Z][A-Za-z ]+) in ([0-9]+) seconds .*</string>
						<string> - ([A-Z][A-Za-z ]+) in ([0-9]) minutes? ([0-9]+) seconds?</string>
						<string> - ([A-Z][A-Za-z ]+) in (1) second .*</string>
						<string> - ([A-Z][A-Za-z ]+) in (none)</string>
						<string> - ([A-Z][A-Za-z ]+) in [123] (pulse) </string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>autoclose</name>
				<script>mud:send("close door")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The door is opened from the other side.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't see who is fighting</name>
				<script>-- need di

if checkMask("ran") then
	if spell:getSlot(2) &gt; 0 then
		spell:cast("BSE")
	end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't see who is fighting</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>clickable url</name>
				<script>for i,v in ipairs(matches) do
	selectString(matches[i], 1)
	setLink([[openUrl("]]..matches[i]..[[")]], matches[i])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>\b(?:(?:(?:https?|ftp|telnet)://[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+|www|ftp)(?:\.[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+)+|[\w\d._%+\-]+@[\w\d.\-]+\.[\w]{2,4})\b</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>paging</name>
				<script>pagingmode = true</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[RETURN for more, q to quit\]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>PowersSpells</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>You have the following spells available:</name>
					<script>-- enable trigger group

enableTrigger("powersSpellsCapture")
enableTrigger("promptendspells")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have the following spells available:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>promptendspells</name>
					<script>-- disable trigger

disableTrigger("powersSpellsCapture")
disableTrigger("promptendspells")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^&lt; .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>powersSpellsCapture</name>
					<script>--  - Heroism

cecho("  &lt;cyan&gt;[" .. string.upper(tostring( powerAliases:getAlias( to_snake(matches[2])) )) .. "]")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^ - ([A-Za-z ]+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You aren't wearing anything!</name>
				<script>equip:setWeapon("None")

initClass()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You aren't wearing anything!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that without solid ground underneath you!</name>
				<script>timer:set("noground", 30)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that without solid ground underneath you!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Rerolling this character.</name>
				<script>-- Autoroll: This displays rolling stats summary

if isActive("RollerTrigger", "trigger") == 0 then
	return
end


clearWindow()

-- set start time as epoch
rollTime = rollTime or os.time()

local currentTime=os.time()

local rollTarget = charData:get("autoroll", true)

if NyyLIB.roller ~= 0 then
	--rollerstats[NyyLIB.roller] = rollerstats[NyyLIB.roller] + 1

	local nx
	local total=0
	
	local echostring = "\n&lt;cyan&gt;["
	
	for nx=1,(rollTarget-1),1 do
				
		local val=rollerstats[nx]
	
		total=total+val
		
		echostring = echostring .. " " .. nx .. ": " .. val
	end
		
	cecho( echostring .. "]\n" )	
	cecho( "&lt;cyan&gt;[Total Rolls: " .. total .. " Last Roll: " .. NyyLIB.roller .. " Target: " .. rollTarget .. "]\n")
	

	local rollDuration= currentTime-rollTime

	local speed= math.floor( total / (rollDuration / (60*60)) )
	
	local sec
	local min
	local hrs

	hrs=math.floor(rollDuration/(60*60))
	
	min=math.floor(rollDuration/60)-(hrs*60)

	sec=rollDuration-( ((hrs*60)+min)*60)

	cecho("&lt;cyan&gt;[Roll Time: " .. string.format("%d:%d:%02d", hrs, min, sec) ..
					" Rolls/hour: " .. speed .. "]\n")
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Rerolling this character.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>nobash</name>
				<script>-- set nobash

timer:set("nobash", 30)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>They are too small for you to do that!</string>
					<string>They are too large for you to do that!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Nah... You feel too relaxed to do that...</name>
				<script>mud:send("alert")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Nah... You feel too relaxed to do that...</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>MinimapClass</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Exits:</name>
					<script>if minimapBuffer == nil then
	minimapBuffer = createBuffer("minimapBuffer")
end

local endIndex=1

-- find last empty line received
while getLines( getLineNumber()-endIndex, getLineNumber())[1] ~= "" do
	endIndex=endIndex+1

	if endIndex &gt; 1500 then
		echoDebug("&lt;red&gt;[Searched more then 1500 lines unable to locate last prompt for roomname]\n")
		return
	end
end

local startIndex=endIndex+1

-- find 2nd last empty line received
while getLines( getLineNumber()-startIndex, getLineNumber())[1] ~= "" do
	startIndex=startIndex+1

	if startIndex &gt; 1500 then
		echoDebug("&lt;red&gt;[Searched more then 1500 lines unable to locate last prompt for roomname]\n")
		return
	end
end

if (startIndex-endIndex) == 14 then
	
	clearWindow("minimapBuffer")
	
	local nx
	
	moveCursor(0, getLineNumber()-startIndex)
	
	for nx=startIndex, endIndex+2, -1 do
		moveCursor(0, getLineNumber()+1)
		selectCurrentLine()
		copy()

		appendBuffer("minimapBuffer")
	end
	
	miniMap:update()
		
	moveCursorEnd()
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Exits:.*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>botcheck</name>
				<script>mud:send("gsay I am not a bot")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Lilabipple group-says '.*(robo|bot|afk) ?check.*'</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>NyyLIB</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>ClassAliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Bard</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>songs</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Offensive Harmony</name>
							<script>music(charData:get("drum"), "song of offensive harmony", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^haste$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Healing</name>
							<script>if checkMask("singer") then
	music(charData:get("lute"), "song of healing", "")
else
	mud:send("HEAL")
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^heal$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Renewal</name>
							<script>music(charData:get("piccolo"), "song of renewal", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^renew$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>The Elements</name>
							<script>music(charData:get("drum"), "song of the elements", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^elements$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Harming</name>
							<script>music(charData:get("mandolin"), "song of harming", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^harm$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Protection</name>
							<script>music(charData:get("harp"), "song of protection", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^prot$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Recovery</name>
							<script>music(charData:get("piccolo"), "song of recovery", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^recover$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Regeneration</name>
							<script>music(charData:get("lute"), "song of regeneration", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^regen$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Offensive Disruption</name>
							<script>music(charData:get("trumpet"), "song of offensive disruption", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^slow$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Sorcery</name>
							<script>music(charData:get("piccolo"), "song of sorcery", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^sorc$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Travel</name>
							<script>music(charData:get("lute"), "song of travel", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^travel$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Defensive Disruption</name>
							<script>music(charData:get("trumpet"), "song of defensive disruption", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^weak$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>stopmusic</name>
							<script>local label=findlabel("StopMusic")
label:echo([[&lt;p style="font-size:25px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;   &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])

mud:send("PLAY")

charData:set("song", "")
charData:set("_song", "")
charData:set("effect", "")
NyyLIB.songtimer = ""

resetSongs()
</script>
							<command></command>
							<packageName></packageName>
							<regex>^stopmusic$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Miscast</name>
							<script>music(charData:get("mandolin"), "song of miscast magic", "room")</script>
							<command></command>
							<packageName></packageName>
							<regex>^miscast$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Defensive Harmony</name>
							<script>music(charData:get("drum"), "song of defensive harmony", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^defend$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Song of Revelation</name>
							<script>music(charData:get("harp"), "song of revelation", "")</script>
							<command></command>
							<packageName></packageName>
							<regex>^reveal$</regex>
						</Alias>
					</AliasGroup>
					<AliasGroup isActive="yes" isFolder="yes">
						<name>spells</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex></regex>
						<Alias isActive="yes" isFolder="no">
							<name>Harmonious Blessing</name>
							<script>mud:send("c 'harmonious blessing' me")</script>
							<command></command>
							<packageName></packageName>
							<regex>^bless$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Phantom Armor</name>
							<script>local cls = whoclass()

if cls == "Ctr" then
	spell:cast("c 'armor' " .. matches[2])
elseif cls == "Bar" then
	spell:cast("c 'phantom armor' " .. matches[2])
elseif cls == "Enc" then
	spell:cast("c 'energy shield' " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^armor (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Detect Invisibility</name>
							<script>if checkMask("sing") then
	spell:cast("c 'detect invis' " .. matches[2])
else
	spell:cast("DI " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^di (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Faerie Fire</name>
							<script>spell:setMoving(false)

spell:cast("FF " .. matches[2])</script>
							<command></command>
							<packageName></packageName>
							<regex>^ff (.+)$</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Ray of Enfeeblement</name>
							<script>spell:setMoving(false)

if checkMask("singer") then
	spell:cast("c 'ray of enfeeblement'" .. (matches[2] or "") )
else
	spell:cast("RAY" .. (matches[2] or "") )
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^ray( .*)?</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Displacement</name>
							<script>-- displacement power is same as dragonscale

if checkMask("singer") then
	spell:cast("c 'displacement' " .. matches[2])
else
	spell:cast("DS " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^disp (.*)</regex>
						</Alias>
						<Alias isActive="yes" isFolder="no">
							<name>Feeblemind</name>
							<script>if checkMask("singer") then
	spell:cast("c 'feeblemind' " .. matches[2])
else
	spell:cast("FEEB " .. matches[2])
end</script>
							<command></command>
							<packageName></packageName>
							<regex>^feeb (.*)</regex>
						</Alias>
					</AliasGroup>
					<Alias isActive="yes" isFolder="no">
						<name>accompany</name>
						<script>if NyyLIB.accompany == 0 then
	for k,char in pairs(groupList:pc("singer")) do
		if char ~= whoami() then
			mud:send("accompany " .. char)
			NyyLIB.accompany = 1
			return
		end
	end
else
	mud:send("accompany stop")
	NyyLIB.accompany = 0
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^accompany$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>escape dir return backstab</name>
						<script>mud:send("ESCAPE " .. matches[2])

NyyLIB.escapedir = matches[2]
NyyLIB.roguereturn = matches[3]</script>
						<command></command>
						<packageName></packageName>
						<regex>^es([nsewud])([cbp])?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Psi</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>^sneak([neswud])$</name>
						<script>if checkMask("psi") then
	expandAlias(matches[2], false)
	mud:send("DARKNESS")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^sneak([neswud])$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Ctr</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>stone</name>
						<script>if whoclass() == "Ctr" then
	spell:cast("c 'stoneskin' " .. matches[2])
else
	spell:cast("ss " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^stone ([A-Za-z]+)</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Lic</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>soul bind</name>
						<script>if checkMask("necros") then
	spell:setMoving(false)
	
	spell:setNext("SB" .. (matches[2] or "") )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^sb( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>heal undead</name>
						<script>spell:setMoving(false)

spell:setNext("HU" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^hu( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ghost</name>
						<script>spell:setMoving(false)

spell:setNext("GHOST " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^ghost (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>spect</name>
						<script>spell:setMoving(false)

spell:setNext("SPECT " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^spect? (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ssh</name>
						<script>local petname = pet:getCasterTable()[1]

spell:setMoving(false)

if petname ~= nil and not timer:get("petcast") then
	timer:set("petcast", 6)
	mud:send("ORDER " .. petname .. " cast 'soul shackles'")
	return
end

spell:setNext("SSH")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ssh$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>pfu</name>
						<script>spell:setMoving(false)

spell:setNext("PFU" .. (matches[2] or "") )
</script>
						<command></command>
						<packageName></packageName>
						<regex>^pfu( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>embalm</name>
						<script>spell:setMoving(false)

spell:setNext("EMM" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^emm( .+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>wight</name>
						<script>spell:setMoving(false)

spell:setNext("WIGHT " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^wight (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>wraith</name>
						<script>spell:setMoving(false)

spell:setNext("WRAITH " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^wraith (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ghoul</name>
						<script>spell:setMoving(false)

spell:setNext("GHOUL " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^ghoul (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>zombie</name>
						<script>spell:setMoving(false)

spell:setNext("ZOMB " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^zomb (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shadow</name>
						<script>spell:setMoving(false)

spell:setNext("SHADOW " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^shadow (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>lt</name>
						<script>spell:setMoving(false)

spell:setNext("LT " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^lt (.+)$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Enc</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>swapts</name>
						<script>charData:init("swapts", "ds")

if charData:get("swapts") == "ds" then
	mud:send("forget ds")
	mud:send("mem ts")
	mud:send("prio ts")
	charData:set("swapts", "ts")
else
	mud:send("forget ts")
	mud:send("mem ds")
	mud:send("prio ds")
	charData:set("swapts", "ds")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^swapts$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>ds</name>
						<script>if checkMask("pal") or checkMask("blk") or checkMask("war") then
	useMeleePower("DS" .. (matches[2] or "") )
else
	spell:setMoving(false)

	spell:setNext("DS" .. (matches[2] or "") )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^ds( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>blur</name>
						<script>spell:setMoving(false)

spell:setNext("BL" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^blur( .+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>hs</name>
						<script>if checkMask("haster") or checkMask("pal") then
	spell:setMoving(false)
	spell:setNext("HS" .. (matches[2] or "") )
else
	mud:send("HS" .. (matches[2] or "") )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^hs( .*)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gi</name>
						<script>spell:setMoving(false)

spell:setNext("GI" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gi( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>memd</name>
						<script>mud:send("MEM")</script>
						<command></command>
						<packageName></packageName>
						<regex>^memd$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cast</name>
						<script>if not checkMask("casterSinger") and not checkMask("ran") and not checkMask("pal") and not checkMask("blk") then
	cecho("&lt;red&gt;[This class can't access casting scripts]\n")
	return
end

-- set to not moving, cast/mem ok

automem=3
memsent=false
spell:setMoving(false)
spell:setCurrent(nil)

mud:send("\n")

if checkMask("singer") then
	return
end

-- enable autocast
buttons:change("autocast", true, "SpellsButton")


</script>
						<command></command>
						<packageName></packageName>
						<regex>^cast$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>buff</name>
						<script>if matches[2] ~= nil then
	if checkMask("enc") then
		spell:cast("ds " .. matches[2])
		spell:cast("blur " .. matches[2])
		spell:cast("gi " .. matches[2])
		spell:cast("enl " .. matches[2])
		spell:cast("di " .. matches[2])
		spell:cast("fly " .. matches[2])
	elseif checkMask("cle") then
		spell:cast("vt " .. matches[2])
		spell:cast("ha " .. matches[2])
	end
else
	--
end

-- Spells()</script>
						<command></command>
						<packageName></packageName>
						<regex>^buff ?([A-Za-z]+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shift</name>
						<script>if checkMask("psi") then
	mud:send("SHIFT " .. matches[2], false)
else
	spell:setMoving(false)
	spell:cast("RELO " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^shift ([A-Za-z]+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rift</name>
						<script>if checkMask("psi") then
	mud:send("RIFT " .. matches[2], false)
else
	spell:cast("c 'gate' " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^rift (.*)$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Cle</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>ha</name>
						<script>--send("ha " .. matches[2], false)

if checkMask("cle") then
	spell:setMoving(false)

	spell:setNext("HA" .. (matches[2] or "") )
else
	mud:send("HA" .. (matches[2] or "") )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^ha( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rpoison</name>
						<script>mud:send( g("removepoison") )
mud:send("rem warmaul")
mud:send("hold removepoison")
mud:send("use removepoison")
mud:send("rem removepoison")
mud:send("wield warmaul")
mud:send("drop removepoison")</script>
						<command></command>
						<packageName></packageName>
						<regex>^rpoison$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>fh (full heal)</name>
						<script>spell:setMoving(false)

spell:setNext("FH" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^fh( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>vit</name>
						<script>spell:setMoving(false)

spell:setNext("VT" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^vit( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>prayd</name>
						<script>mud:send("PRAY")</script>
						<command></command>
						<packageName></packageName>
						<regex>^prayd$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>resu</name>
						<script>if not consent:get(matches[2]) then
	mud:send("t " .. matches[2] .. " consent")
end

spell:setMoving(false)

spell:setNext("RESU " .. matches[2])</script>
						<command></command>
						<packageName></packageName>
						<regex>^resu (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>castha</name>
						<script>spell:setMoving(false)

cecho("&lt;red&gt;[Queuing healing aura]\n")

--if NyyLIB.mtank ~= nil then
--	spell:setNext("ha " .. NyyLIB.mtank)
--end

for k,char in pairs(groupList:pc("warrior")) do
	spell:attempt(char, "healing_aura", "ha")
end



</script>
						<command></command>
						<packageName></packageName>
						<regex>^castha$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sp (silence person)</name>
						<script>-- sp is shieldpunch, silence

if checkMask("cle") or checkMask("sha") then
	spell:setNext("SP " .. matches[2])
else
	mud:send("SP " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^sp (.+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>realm</name>
						<script>spell:setMoving(false)

spell:setNext("REALM" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^realm( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Sha</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>summon totem</name>
						<script>mud:send( g("totem") )
mud:send( "rem warmaul" )
mud:send( "hold totem" )
mud:send( "use totem" )
mud:send( "rem totem" )
mud:send( "wield warmaul" )
mud:send( p("totem") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^totem$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>hex</name>
						<script>spell:setMoving(false)

spell:setNext("HEX " .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^hex (.+)$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Rog</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>cr</name>
						<script>if checkMask("rogue") then
	if timer:get("wraithform") then
		return
	end

	if buff:get("blind") then
		return
	end


	mud:send("CR")
	group:send()

	--cecho("\n&lt;red&gt;[Attacking with circle]\n")
	--cecho("&lt;red&gt;\n\n[&lt;cyan&gt;MELEE: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() .. "\n")
	cecho("&lt;red&gt;\n\n[&lt;cyan&gt;MELEE: &lt;red&gt;CIRCLE]\n")
elseif whoclass() == "Blk" or whoclass() == "Cle" then
	spell:setNext("cr")
else
	mud:send("CR")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^cr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>apb - apply poison blind</name>
						<script>mud:send("apply blind primaryweapon")
mud:send("apply blind secondaryweapon")</script>
						<command></command>
						<packageName></packageName>
						<regex>^apb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gpb - get blind poison container</name>
						<script>mud:send( "GET blind " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gpb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>appb - get blind container and apply</name>
						<script>expandAlias("gpb", false)
expandAlias("apb", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^appb$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aps - apply poison slow</name>
						<script>mud:send("apply slow primaryweapon")
mud:send("apply slow secondaryweapon")</script>
						<command></command>
						<packageName></packageName>
						<regex>^aps$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gps - get poison slow from container</name>
						<script>mud:send( "GET slow " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gps$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>apps - get, apply slow</name>
						<script>expandAlias("gps", false)
expandAlias("aps", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^apps$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>app - blind primary, slow secondary</name>
						<script>mud:send("apply blind primaryweapon")
mud:send("apply slow secondaryweapon")</script>
						<command></command>
						<packageName></packageName>
						<regex>^app$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gpp - get blind/slow container</name>
						<script>mud:send( "GET blind " .. charData:get("poisonbag") )
mud:send( "GET slow " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gpp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>appp - get/apply blind, slow</name>
						<script>expandAlias("gpp", false)
expandAlias("app", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^appp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>pick - hold pick</name>
						<script>mud:send("get string merchants")
mud:send("rem bane")
mud:send("hold string")</script>
						<command></command>
						<packageName></packageName>
						<regex>^pick$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>weapon</name>
						<script>mud:send("rem string")
mud:send("put string merchants")
mud:send("wield bane")</script>
						<command></command>
						<packageName></packageName>
						<regex>^weapon$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>assassinate</name>
						<script>if not checkMask("rog") then
	mud:send( string.upper(matches[2]) .. " " .. matches[3] )
	return
end

local timeleft=timer:get("assassinatetimer")

if not timeleft then
	timer:set("assassinatetimer", 24*60)
	mud:send("ASSASSINATE " .. matches[3])
else
	cecho("&lt;red&gt;[Assassinate in cooldown: &lt;green&gt;" .. timedisplay(timeleft) .. "&lt;red&gt;]\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^(assa?s?s?i?n?a?t?e?) (.+)</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>mpp - apply poison milky</name>
						<script>mud:send("apply milky primaryweapon")
mud:send("apply milky secondaryweapon")</script>
						<command></command>
						<packageName></packageName>
						<regex>^mpp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>gpm - get milky poison</name>
						<script>mud:send( "GET milky " .. charData:get("poisonbag") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^gpm$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>mppp - get/apply milky</name>
						<script>expandAlias("gpm", false)
expandAlias("mpp", false)</script>
						<command></command>
						<packageName></packageName>
						<regex>^mppp$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>backstab</name>
						<script>mud:send("BS " .. matches[2])
group:send()</script>
						<command></command>
						<packageName></packageName>
						<regex>^bs (.*)</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>A-P</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Nec</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>oc - order ghost cast</name>
						<script>mud:send("ORDER ghost cast '" .. matches[2] .. "'")</script>
						<command></command>
						<packageName></packageName>
						<regex>^oc (.*)</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Ele</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>eee</name>
						<script>spell:setMoving(false)

spell:setNext("EE" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^eee( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Pal</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>brand of judgement</name>
						<script>spell:setMoving(false)

spell:setNext("BOJ" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^boj( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>sunburst</name>
						<script>if checkMask("pal") then
	spell:setMoving(false)
	spell:setNext("SB" .. (matches[2] or "") )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^sb( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aura of life</name>
						<script>spell:setMoving(false)

spell:setNext("AL")</script>
						<command></command>
						<packageName></packageName>
						<regex>^al$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shield of warding (sonic wave)</name>
						<script>spell:setMoving(false)

spell:setNext("SW" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sw( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>divine bolt</name>
						<script>spell:setMoving(false)

spell:setNext("DB" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^db( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>cleansing spirit</name>
						<script>spell:setMoving(false)

spell:setNext("CS")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cs$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>heroism</name>
						<script>spell:setMoving(false)

spell:setNext("HR")</script>
						<command></command>
						<packageName></packageName>
						<regex>^hr$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>shield of faith</name>
						<script>spell:setMoving(false)

spell:setNext("SF")</script>
						<command></command>
						<packageName></packageName>
						<regex>^sf$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>aura of glory</name>
						<script>spell:setMoving(false)

spell:setNext("AG")</script>
						<command></command>
						<packageName></packageName>
						<regex>^ag$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>healing light</name>
						<script>spell:setMoving(false)

spell:setNext("HL")</script>
						<command></command>
						<packageName></packageName>
						<regex>^hl$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>noble shield (needle swarm)</name>
						<script>spell:setMoving(false)

spell:setNext("NS" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^ns( .+)?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>lay hands</name>
						<script>-- lay hands

mud:send("LH" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^lh( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Blk</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>soul touch</name>
						<script>-- soul touch

mud:send("SOT" .. (matches[2] or "") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^sot( .+)?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>War</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>shield bash</name>
						<script>-- shieldbash

if checkMask("war") then
	if not timer:get("shield_bash") then
		useMeleePower("SB" .. (matches[2] or "") )
		setBashing(true)
		return
	end
end
</script>
						<command></command>
						<packageName></packageName>
						<regex>^sb( .+)?$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<Alias isActive="no" isFolder="no">
				<name>restart</name>
				<script>local ver=getMudletVersion()

if ver["major"] == 3 then
	if ver["build"] == "" or ver["build"] == "-dev" then
		cecho("&lt;red&gt;[NyyLIB requires restart after installation.]\n")
		return
	end
end

cecho("&lt;red&gt;[NyyLIB requires minimum non-beta Mudlet version 3.x.x http://www.mudlet.org/download/ ]\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>^.+$</regex>
			</Alias>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>EquipProcs</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>clair</name>
					<script>if isIconActive("TiaManacle") then
	mud:send("SAY farsight " .. matches[2])
else
	mud:send( g("ball") )
	mud:send("gaze ball " .. matches[2])
	mud:send( p("ball") )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^clair (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>chpele</name>
					<script>mud:send("say strength of stone")</script>
					<command></command>
					<packageName></packageName>
					<regex>^chpele</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>shabay</name>
					<script>mud:send("EMOTE starts casting a spell called 'Shabay'.")
mud:send("SAY my heavenly home")</script>
					<command></command>
					<packageName></packageName>
					<regex>^shabay</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>blend</name>
					<script>if whoami() == "Adud" then
	mud:send("rem isha")
else
	mud:send("rem swirling")
end

mud:send("get 3.warder hole")
mud:send("wear warder")
mud:send("SAY blend")
mud:send("rem warder")

if whoami() == "Adud" then
	mud:send("wear isha")
else
	mud:send("wear swirling")
end

mud:send("put warder hole")</script>
					<command></command>
					<packageName></packageName>
					<regex>^blend$</regex>
				</Alias>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>TiaSleeves</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>healme</name>
						<script>mud:send("quaff glowing " .. charData:get("container") )</script>
						<command></command>
						<packageName></packageName>
						<regex>^healme</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Baatorian</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>slaad</name>
						<script>mud:send("SAY demonic conjuration")</script>
						<command></command>
						<packageName></packageName>
						<regex>^slaad</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>bash</name>
						<script>if checkMask("fighter") then
	setBashing(false)
	sendBash(matches[2])
else
	mud:send("ORDER followers bash " .. matches[2])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^bash ([A-Za-z]+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>oflee</name>
						<script>mud:send("ORDER followers flee")</script>
						<command></command>
						<packageName></packageName>
						<regex>^oflee$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>resc</name>
						<script>-- attempt rescue if have that skill, otherwise direct command to followers
-- TODO: Should confirm you have followes before sending

if checkMask("fighter") then
	sendRescue(matches[3])
else
	mud:send("ORDER followers rescue " .. matches[3])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^resc(ue)? ([A-Za-z]+)$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>rme</name>
						<script>mud:send("ORDER followers rescue " .. whoami())</script>
						<command></command>
						<packageName></packageName>
						<regex>^rme$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>TiaStaff</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>protect</name>
						<script>mud:send("SAY Protect me")</script>
						<command></command>
						<packageName></packageName>
						<regex>^protect$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>release</name>
						<script>mud:send("SAY Release")</script>
						<command></command>
						<packageName></packageName>
						<regex>^release$</regex>
					</Alias>
				</AliasGroup>
				<Alias isActive="yes" isFolder="no">
					<name>pendant</name>
					<script>mud:send("SAY infernal protection")</script>
					<command></command>
					<packageName></packageName>
					<regex>^pendant$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>dcult</name>
					<script>mud:send("rem swirling")
mud:send( g("ceremonial") )
mud:send("wear ceremonial")
mud:send("SAY draconian protection")
mud:send("rem ceremonial")
mud:send("wear swirling")
mud:send( p("ceremonial") )
</script>
					<command></command>
					<packageName></packageName>
					<regex>^dcult</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>bane</name>
					<script>local bane=charData:get("bane")

if bane == "blind" then
	mud:send("SAY Dragonblind")
elseif bane == "poison" then
	mud:send("SAY Dragonpoison")
elseif bane == "slow" then
	mud:send("SAY Dragonslow")
elseif bane == "strike" then
	mud:send("SAY Dragonstrike")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^bane$</regex>
				</Alias>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>TiaWarmaul</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>aid</name>
						<script>mud:send("SAY aid my companions")
group:send()</script>
						<command></command>
						<packageName></packageName>
						<regex>^aid$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>restore</name>
						<script>mud:send("SAY restore me")</script>
						<command></command>
						<packageName></packageName>
						<regex>^restore$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>NyyAliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@debug information</name>
					<script>-- this alias displays numerous internal variable values

-- should add command @debug nhc to echo results to nhc


expandAlias("@version", false)

local WindowWidth, WindowHeight = getMainWindowSize()
cecho("&lt;red&gt;Screen size: X: &lt;green&gt;" .. WindowWidth .. " &lt;red&gt;Y: &lt;green&gt;" .. WindowHeight .. "\n\n")

local hp=prompt:get("hp")
local maxhp=prompt:get("maxhp")
local psp=prompt:get("psp")
local maxpsp=prompt:get("maxpsp")
local mv=prompt:get("mv")
local maxmv=prompt:get("maxmv")
local tank=prompt:get("tank") or ""
local tankcon=prompt:get("tankcondition") or ""
local enemy=prompt:get("enemy") or ""
local enemycon=prompt:get("enemycondition") or ""
local enemypos=prompt:get("enemyposition") or ""
local pos=prompt:get("position") or ""

cecho(string.format("&lt;green&gt;hp: %d maxhp: %d\n", hp, maxhp) )
cecho(string.format("&lt;green&gt;mv: %d maxmv: %d\n", mv, maxmv) )

if psp ~= nil then
	cecho(string.format("&lt;green&gt;psp: %d maxpsp: %d\n", psp, maxpsp) )
end

echo (string.format("T: %s TC: %s E: %s EC: %s EP: %s P: %s\n", tank, tankcon, enemy, enemycon, enemypos, pos))

local current=spell:getCurrent() or "nil"

echo("\n")

cecho("&lt;red&gt;promt:get(tank) " .. tank .. "-\n")
echo("\n")

cecho("&lt;red&gt;spell:getCurrent(): " .. current .. "\n")
cecho("&lt;red&gt;spell:count(): " .. spell:count() .. "\n")

cecho("&lt;red&gt;To memorize (memcount): " .. charData:get("memcount") .. "\n")
cecho("&lt;red&gt;Seen mem'ing (automem): " .. automem .. "\n")

cecho("&lt;red&gt;spell:getMoving(): " .. tostring(spell:getMoving()) .. "\n")
cecho("&lt;red&gt;spell:getMem(): " .. tostring(spell:getMem()) .. "\n")


cecho("&lt;red&gt;look:get(): " .. tostring(look:get()) .. "\n")

cecho("&lt;red&gt;group:get() " .. tostring(group:get()) .. "\n")

echo("\n")

cecho("&lt;red&gt;meleePowerUsed " .. tostring(meleePowerUsed) .. "\n")

if memsent ~= nil then
	cecho("&lt;red&gt;memsent: " .. tostring(memsent) .. "\n")
end

cecho("&lt;red&gt;lastsent: " .. lastsent .. "\n")

if sendingStatus ~= nil then
	cecho("&lt;red&gt;sendingStatus: " .. tostring(sendingStatus) .. "\n")
end

cecho("&lt;red&gt;mud.sending: " .. tostring(mud.sending) .. "\n")

if NyyLIB.escapedir ~= nil then
	cecho("&lt;red&gt;NyyLIB.escapedir: " .. NyyLIB.escapedir .. "\n")
end

echo("\n")

if spell:count() &gt; 0 then
	cecho("&lt;red&gt;Queued spells (spell.spellcastqueue)\n")
	display( spell.spellcastqueue )
end

if ( #mud.varsendqueue &gt; 0 ) then
	cecho("&lt;red&gt;Queued commands (mud.varsendqueue):\n")
	display( mud.varsendqueue )
end

if groupList:whoTanking() then
	cecho("&lt;red&gt;Who's tanking (groupList:whoTanking()):\n")
	display ( groupList:whoTanking() )
end

display( enteredPortal )

cecho("&lt;red&gt;getEnemy(): " .. getEnemy() .. "\n")
cecho("&lt;red&gt;inCombat(): " .. tostring(inCombat()) .. "\n")
cecho("&lt;red&gt;assistSent: ")
display(assistSent)


display(  mud.varsendqueue )

cecho("&lt;red&gt;[End debug]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@debug$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@set</name>
					<script>local nx

-- set by itself, no arguments
if matches[2] == "@set" then
	cecho("&lt;red&gt;Usage: &lt;green&gt;@set key value &lt;red&gt;Example: &lt;green&gt;@set loot off &lt;red&gt;- turns off autoloot\n")
	echo("------------\n")

	for nx=1, #setvar, 1 do
		local key= setvar[nx][1]
		local value

		if key ~= "-" then
			if setvar[nx][2] == "" then
				value = charData:get(key, true)
			else 
				value = charData:get(key)
			end

			if type(value) == "boolean" then
				value=tostring(value)
			end

			if type(value) == "table" then
				value=""
			end

			-- if no value set, assign default value

			if value == nil then
				cecho("&lt;red&gt;[ nil value " .. key .. "]\n")
			end

			--if value == nil then
			--	value=setvar[nx][4]
			--	if setvar[nx][2] == "" then
			--		charData:set(key, value, true)
			--	else
			--		charData:set(key, value)
			--	end
			--end

			if setvar[nx][2] == "" or setvar[nx][2] == "*" then
				if key == "condensed" then
					local count=0

					cecho ( string.format("&lt;green&gt;%17s&lt;white&gt;\n", 	"[" .. key .. "]") )

					for k,v in pairs(charData:get("condensed", true)) do
						count = count + 1

						if count == 1 then
							echo("            ")
						end

						cecho(string.format("&lt;green&gt; %-9s&lt;white&gt; %5s |", k, tostring(v) ))

						if count == 4 then
							count=0
							echo("\n")
						end
					end
					echo("\n")
				else
					cecho ( string.format("&lt;green&gt;%17s&lt;white&gt; %-15s %20s  %s\n", 
								"[" .. key .. "]",
								value,
								table.concat(setvar[nx][3], "|"),
								setvar[nx][5] )
				 		)
				end
			else
				if setvar[nx][2] ~= "equip" then
					if checkMask(setvar[nx][2]) then
						cecho ( string.format("&lt;green&gt;%17s&lt;white&gt; %-15s %20s  %s\n", 
								"[" .. key .. "]",
								value,
								table.concat(setvar[nx][3], "|"),
								setvar[nx][5] )
					 		)
					end
				end
			end
		else
			echo("--------------\n")
		end
	end

	return
end

-- at least one argument provided

for nx=1, #setvar, 1 do
	local key= setvar[nx][1]

	if matches[4] == key then
		local classes=setvar[nx][2]
		local pattern=setvar[nx][3]
		local value=matches[5]

		if matches[5] == "true" then
			value=true
		end

		if matches[5] == "false" then
			value=false
		end

		-- Is the key changeable by this class?

		if classes == "" or classes == "*" then
			-- ok to change
		else
			if classes ~= "equip" then
				if checkMask(classes) then
					-- ok to change
				else
					-- not ok to change
					cecho("&lt;red&gt;[Not a valid key for this character class]\n")
					return	
				end
			end
		end

		-- Does the new value match acceptable patterns?

		if matches[4] == "border" then
			if matches[5] == "file" then	
				local tmp = invokeFileDialog(true, "Select border image")

				if tmp ~= "" then
					charData:set("border", string.gsub(tmp, "\\", "/"), true	)
				end
		
				echo("[Border imagefile: " .. charData:get("border", true) .. "]\n")
			elseif matches[5] == "default" then
				charData:set("border", "default", true)
			else
			
				charData:set("border", matches[5], true)
			end

			cecho("&lt;red&gt;[Border set to " .. charData:get("border", true) .. "]\n")

			setBorder()
			return
		end


		if matches[4] == "condensed" then
			if table.index_of(pattern, matches[5]) then
				local condensed = charData:get("condensed", true)

				condensed[matches[5]] = togBoolean(condensed[matches[5]])
				charData:set("condensed", condensed, true)

				cecho("&lt;red&gt;[Setting condensed mode " .. matches[5] .. " to " .. tostring(condensed[matches[5]]) .. "]\n")
				return
			end
		end

		if matches[5] == "" and table.index_of(pattern, "true") ~= nil then
			local nval

			if classes == "" then
				nval = togBoolean( charData:get(key, true) )
				charData:set(key, nval, true)
			else
				nval = togBoolean( charData:get(key) ) 
				charData:set(key, nval)
			end

			cecho("&lt;red&gt;[Setting " .. key .. " to " .. tostring(nval) .. "]\n")


			-- check if key is hideequip

			if key == "hideequip" then
				leftIcons()
			end

			-- check if key is hideicons

			if key == "hideicons" then
				showIconbar()
			end

			if key == "style" then
				if nval == true then				
					setStyle()
				else
					setAppStyleSheet("")
				end
			end

			buttons:sync()

			return
		end

		if matches[5] == "" or matches[5] == "#" or matches[5] == "*" then
			cecho("&lt;red&gt;[No value provided]\n")
			return
		end

		if (pattern[1] == "*" or table.index_of(pattern, matches[5]) ~= nil) or
			 (table.index_of(pattern, "#") and tonumber(matches[5])) then
			cecho("&lt;red&gt;[Setting " .. key .. " to " .. matches[5] .. "]\n")

			if classes == "" then
				charData:set(key, value, true)
			else
				charData:set(key, value)
			end

			if key == "chatfontsize" then
				demonnic.chat:redo()
			end

			if key == "hideequip" then
				leftIcons()				
			end

			if key == "hideicons" then
				showIconbar()
			end

			if key == "style" then
				if value == true then				
					setStyle()					
				else
					setAppStyleSheet("")					
				end
			end

			buttons:sync()

			return
		end

		cecho("&lt;red&gt;[Not a valid value for " .. key .. " : " .. table.concat(setvar[nx][3], "|") .. "]\n")

		return
	end
end

cecho("&lt;red&gt;[" .. matches[4] .. " is not a valid key]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>(^@set$)|(^@set ([A-Za-z]+) ?(.*)?$)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@mtank</name>
					<script>if matches[2] == nil then
	NyyLIB.mtank = nil

	cecho("&lt;green&gt;[Main tank cleared]\n")
else
	NyyLIB.mtank = string.title(matches[2])
	cecho("&lt;green&gt;[Main tank is now set to: &lt;red&gt;" .. NyyLIB.mtank .. "&lt;green&gt;]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@mtank ?([0-9.a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@target</name>
					<script>NyyLIB.target = matches[2]

if matches[2] == nil then
	cecho("&lt;red&gt;[Target cleared]\n")
else
	cecho("&lt;red&gt;[Target is now set to: &lt;green&gt;" .. NyyLIB.target .. "&lt;red&gt;]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@target ?([0-9.a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@save</name>
					<script>-- save data files

saveNyyLIB()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@save$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@backup</name>
					<script>function backupDirectory(xname)
	lfs.mkdir(backupPath(xname))

	for file in lfs.dir(homepath(xname)) do
    	-- file is the current file or directory name
		if file ~= "." and file ~= ".." then
	    	print( "Copying: " .. file )

			copyFile(homepath(xname) .. "/" .. file, backupPath(xname) .. "/" .. file)
		end
	end
end

function backupPath(xname)
	local path = charData:get("backupfolder", true) .. "\\" .. xname

	path=string.gsub(path, "\\", "/")	

	return(path)
end

if matches[2] == "logs" then
	cecho("&lt;red&gt;[Backing up profile logs files]\n")
	backupDirectory("log")
	return
end

if matches[2] == "set" then
	charData:set("backupfolder", invokeFileDialog(false, "Select destination folder for backups"), true )

	charData:set("backupfolder", string.gsub(charData:get("backupfolder", true), "/", "\\"), true )

	cecho("&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n")

	return
end

if matches[2] == "copy" then
	if charData:get("backupfolder", true) ~= nil then
		saveNyyLIB()

		cecho("\n&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n\n")

		backupFile("chardata.dat")
		backupFile("stats.dat")
		backupFile("wholist_v3")
		backupFile("notes.txt")

		backupFile("toril.map")
	else
		cecho("&lt;red&gt;[No backup folder selected]\n")
	end

	return
end

if matches[2] == "restore" then
	if charData:get("backupfolder", true) ~= nil then
		cecho("\n&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n\n")

		restoreFile("chardata.dat")
		restoreFile("stats.dat")
		restoreFile("wholist_v3")

		restoreFile("toril.map")

		loadwholist()
		
		local level=charData:get("level")

		charData:load()

		charData:init("level", level)

		initFullData()

		map:loadMap()

		buttons:sync()

		setBorder()
	else
		cecho("&lt;red&gt;[No backup folder selected]\n")
	end

	return
end

cecho("&lt;green&gt;[&lt;red&gt;WARNING:&lt;green&gt; This does not copy script changes]\n\n")
cecho("&lt;green&gt;[Usage: @backup set     - choose backup folder]\n")
cecho("&lt;green&gt;[       @backup copy    - copy data files to folder]\n")
cecho("&lt;green&gt;[       @backup restore - overwrite profile data files with backup folder]\n")
cecho("&lt;green&gt;[       @backup logs    - copy profile logfiles into backup folder\n")

if charData:get("backupfolder", true) ~= nil then
	cecho("\n&lt;red&gt;[Backup folder: " .. charData:get("backupfolder", true) .. "]\n")
else
	cecho("\n&lt;red&gt;[No backup folder selected]\n")
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@backup ?(set|copy|restore|logs)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@help</name>
					<script>--function mainpath(xname)
--	This function returns the full pathname inside the profile of a specific file
--end

function showHelp(xindex)
	local index, name
	local found=false
	
	cecho("\n")
	
	for line in io.lines(mainpath("helpfile.dat")) do
		if string.find(line, ";;") ~= nil then
			if found == false then
				index,name = string.match(line, ";;([0-9]+),([@0-9a-zA-Z _]+)")
			else
				-- end of help entry
				cecho("\n")
				return
			end
		else
			if index == tostring(xindex) or name == xindex or name == ("@" .. xindex) then
				found=true
				--display(line)
				cecho(line .. "\n")
			end
		end
	end
	
	if found == false then
		cecho("&lt;red&gt;[No help information found for: " .. xindex .. "]\n")
	end
end

function showIndex()
	local index, name
	local found=false
	local count=0
	
	for line in io.lines(mainpath("helpfile.dat")) do
		if string.find(line, ";;") ~= nil then
				index,name = string.match(line, ";;([0-9]+),([@0-9a-zA-Z _]+)")
				
				count=count+1
				
				cecho( string.format("&lt;green&gt;%-16s", name) )
		
				if count % 6 == 0 then
					echo("\n")
				end
		end
	end

	echo("\n\n")
end

if matches[2] == "" then
	showHelp("contents")
elseif matches[2] == "index" then
	cecho(string.format("&lt;red&gt;%50s\n\n", "Help Entries") )
	showIndex()
else
	showHelp(matches[2])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@help ?(.*)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@at (attack dir)</name>
					<script>if NyyLIB.target == nil then
	echo("[No target is currently set.]\n")
else
	mud:send(matches[2])
	mud:send("BACKSTAB " .. NyyLIB.target)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@at([nsewud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@attack</name>
					<script>NyyLIB.target = matches[2]

if matches[2] == nil then
	cecho("&lt;red&gt;[Target cleared]\n")
else
	cecho("&lt;red&gt;[Target is now set to: &lt;green&gt;" .. NyyLIB.target .. "&lt;red&gt;]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@attack ?([0-9.a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@chkstat</name>
					<script>cecho("&lt;red&gt;\n[Checking status on group]\n")

for k,char in pairs(groupList:pc()) do
	sendStatus(char)
end

for k,petname in pairs(pet:getTable()) do
	sendStatus(petname)
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@chkstat$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@setroom</name>
					<script>cecho("\n&lt;green&gt;[Searching for matching discovered rooms... ]\n")

if matches[2] == nil then
	local matchtable = {}

	-- Display list of possible matching rooms
	
	if map:getRoomname() ~= nil and map:getExits() ~= nil then
		matchtable = map:findRoomIDTable( map:getRoomname(), map:getExits() )
	end

	display(matchtable)
else
	local matchvalue = tonumber(matches[2])

	if roomLocked(matchvalue) == false then
		cecho("&lt;green&gt;[Room set to " .. matchvalue .. "]\n")

		map:setRoom(matchvalue)
		centerview( map:getRoom() )
	else
		cecho("&lt;red&gt;[Room " .. matchvalue .. " doesn't exist.]\n")
	end
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@setroom( [0-9]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@cd</name>
					<script>function countdown()
	NyyLIB.countdown = NyyLIB.countdown - 1

	local dir= string.upper(NyyLIB.fulldirs[string.lower(tostring(NyyLIB.countdir:trim()))])

	if NyyLIB.countdown &gt; 0 then
		mud:send("GSAY &lt;" .. NyyLIB.countdown .. "&gt; to movement " .. dir )
		tempTimer(1, [[countdown()]])
	else
		mud:send("GSAY &lt; ATTACKING " .. string.title(tostring(NyyLIB.target)) .. " " .. dir .. "! &gt;" )
		
		expandAlias("movea " .. NyyLIB.countdir, false)

		if NyyLIB.target ~= nil then
			mud:send("KILL " .. NyyLIB.target)
		else
			mud:send("HITALL all")
		end
	end
end

if matches[2] == nil then
	if NyyLIB.target == nil then
		cecho("&lt;red&gt;[Countdown script: No target set]\n")
	else
		cecho("&lt;red&gt;[Countdown script: " .. NyyLIB.target .. "]\n")
	end
else
	-- disable rescue
	if checkMask("fighter") then
		if charData:get("rescuetype") ~= "off" then
			buttons:change("rescuetype", "off", "rescue")
		end
	end

	-- change fleemode to 'lich'
	buttons:change("flee", "lich", "flee")

	NyyLIB.countdown = 6

	NyyLIB.countdir = matches[2]

	countdown()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@cd( [nsewud])?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fwalk</name>
					<script>-- map:getRoom() = nil (unknown) throws error

-- ^fwalk( [0-9A-Za-z]+)?( [A-Za-z]+)?


-- fwalk roomnum
-- fwalk add/del bookmarkname
-- fwalk bookmarkname

local var1
local var2

local addfwalk
local action=0

local tmpvar=charData:get("fwalk", true)

local tmplist={}

function fastwalk(xroomid)
	fwalkQue=false
	
	if roomLocked(xroomid) then
		cecho("&lt;red&gt;[Error: Destination room " .. xroomid .. " is locked]\n")
		return
	end

	if map:getRoom() == nil then
		cecho("&lt;red&gt;[Error: source room id is nil]\n")
		return
	end

	if getPath( map:getRoom(), xroomid) then
		doSpeedWalk()
	else
		cecho("&lt;red&gt;[Unable to find path to room#" .. xroomid .. "]\n")
	end
end

if tonumber(matches[2]) ~= nil then

	if inCombat() then
		cecho("&lt;red&gt;[Can't fwalk while in combat]\n")
		return(false)
	end

	fastwalk(tonumber(matches[2]))
else
	var1=string.trim(matches[2])
	var2=string.trim(matches[3])

	if var1 == "help" then
		cecho("&lt;red&gt;Usage: @fwalk roomnumber - fastwalk to specified room number\n")
		cecho("&lt;red&gt;       @fwalk name       - fastwalk to room indicated by fwalk name\n")
		cecho("&lt;red&gt;       @fwalk add name   - adds a fastwalk to the currently occupied room using 'name' \n")
  	cecho("&lt;red&gt;       @fwalk del name   - deletes fastwalk 'name'\n")
		cecho("&lt;red&gt;       @fwalk all        - list all fwalks regardless of location\n")
		cecho("&lt;red&gt;       @fwalk area       - list all fwalks in current area\n")
		return
	end
	
	echo("\n")

	if var1 == "all" then

		for k,v in pairs(charData:get("fwalk", true)) do

			if roomExists(v) then
				local zoneid=tonumber(getRoomUserData(v, "zoneid") )
				local pathlength=0

				if roomLocked(v) == false then
					if getPath( map:getRoom(), v) then
						pathlength=#speedWalkPath
					end
				end

				if pathlength ~= 0 then
					tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
				else
					tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
				end
			else
				tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3s] %s\n", "", v, k, "", "")
			end
		end

		cecho("&lt;white&gt;             Area                  Room#      fwalk     Distance          Room Name\n")
		printSorted(tmplist)

		return
	end

	if var1 == "area" then

		local roomid= map:getRoom()

		local internalid = getRoomArea( roomid )
		local zone=getRoomUserData(roomid, "zoneid")
		local currentareazoneid=tonumber(zone)

		for k,v in pairs(charData:get("fwalk", true)) do

			if roomExists(v) then
				local zoneid=tonumber(getRoomUserData(v, "zoneid") )
				local pathlength=0

				if roomLocked(v) == false then
					if getPath( map:getRoom(), v) then
						pathlength=#speedWalkPath
					end
				end

				if zoneid == currentareazoneid then
					if pathlength ~= 0 then
						tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
					else
						tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
					end
				end
			--else
			--	tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3s] %s\n", "", v, k, "", "")
			end
		end

		cecho("&lt;white&gt;             Area                  Room#      fwalk     Distance          Room Name\n")
		printSorted(tmplist)

		return
	end


	if map:getRoom() == nil then
		cecho("&lt;red&gt;[Current room is unknown]\n")
		return
	end

	-- check if var1 is existing marker - if so, fastwalk and exit

	for k,v in pairs(charData:get("fwalk", true)) do
		if k == var1 then
			cecho("&lt;green&gt;[Issue speedwalk to " .. var1 .. " at " .. v .. "]\n")
	
			fastwalk(v)

			return
		end
	end

	if var1 == "add" and var2 ~= nil then
		cecho("&lt;green&gt;[Adding fwalk for (" .. var2 .. ") to destination " .. map:getRoom() .. "]\n")

		tmpvar[var2] = map:getRoom()
		charData:set("fwalk", tmpvar, true)

		return
	end

	if var1 == "del" and tmpvar[var2] ~= nil then
		cecho("&lt;green&gt;[Deleting fwalk for (" .. var2 .. ") at destination " .. tmpvar[var2] .. "]\n")

		tmpvar[var2] = nil
		charData:set("fwalk", tmpvar, true)

		return
	end

	for k,v in pairs(tmpvar) do

		if roomExists(v) then
			local zoneid=tonumber(getRoomUserData(v, "zoneid") )
			local pathlength=0

			if roomLocked(v) == false then
				if getPath( map:getRoom(), v) then
					pathlength=#speedWalkPath
				end
			end

			if pathlength ~= 0 or map:getRoom() == v then
				tmplist[#tmplist+1] = string.format("[%-30s] [%6d %-15s] [%3d] %s\n", NyyLIB.areaTable[zoneid], v, k, pathlength, getRoomName(v))
			end
		end
	end

	cecho("&lt;white&gt;             Area                  Room#      fwalk     Distance          Room Name\n")
	printSorted(tmplist)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fwalk( [0-9a-zA-Z]+)?( [0-9a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@path</name>
					<script>-- findpath either to room number or fwalk name

function tt(s)
   local t={}

   for p in s:gmatch("..?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?") do
       t[#t+1]=p
   end

   for i,v in ipairs(t) do
       print("." .. v)
   end

	echo("\n")
end


function showfastwalk(xroomid)
	if roomLocked(xroomid) then
		cecho("&lt;red&gt;[Error: Destination room is locked]\n")
		return
	end

	assert(map:getRoom(), "[Error: source room id is nil]")

	if getPath(map:getRoom(), xroomid) then
		local path= compressSpeedwalk()

		if #speedWalkPath &gt; 100 then
			cecho("&lt;red&gt;Path length: &lt;green&gt;" .. #speedWalkPath .. " &lt;red&gt;rooms 100th room &lt;green&gt; " .. speedWalkPath[100] .. "\n\n")
		else
			cecho("&lt;red&gt;Path length: &lt;green&gt;" .. #speedWalkPath .. " &lt;red&gt;rooms\n\n")
		end

		cecho("&lt;red&gt;Path from current room (" .. map:getRoom() .. ") to " .. xroomid .. " (" .. getRoomName(xroomid) .. ")\n")


		--echo("Rooms we'll pass through: " .. table.concat(speedWalkPath, ", ") .. "\n\n")

		cecho("&lt;green&gt;Speedwalk: ." .. compressSpeedwalk() .. "\n\n")

		if string.len(path) &gt; 100 then
			tt(path)
		end

		cecho("&lt;red&gt;Reverse path from " .. xroomid ..  " (" .. getRoomName(xroomid) .. ") to current room: " .. map:getRoom() .. " (" .. getRoomName(map:getRoom()) .. ")\n")

		getPath(xroomid, map:getRoom())

		cecho("&lt;green&gt;Speedwalk: ." .. compressSpeedwalk() .. "\n\n")

	else
		cecho("&lt;red&gt;[Unable to find path to room vnum " .. xroomid .. "]\n")
	end
end

if tonumber(matches[2]) ~= nil then
	showfastwalk(tonumber(matches[2]))
else
	for k,v in pairs(charData:get("fwalk", true)) do
		if k == matches[2] then
			showfastwalk(v)
			return
		end
	end
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@path ?([0-9a-zA-Z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@room</name>
					<script>-- toggle display of room window on/off

roomWindow:toggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@room$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@pracall</name>
					<script>if table.size(toPractice) == 0 then
	cecho("&lt;red&gt;[No skills to practice]\n")
	return
end

for k,v in pairs(toPractice) do
	-- display(k)
	mud:send("prac " .. k)
	toPractice[k]=nil
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@pracall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@scribeall</name>
					<script>if table.size(toScribe) == 0 then
	cecho("&lt;red&gt;[No spells to scribe]\n")
	return
end

if matches[2] == "start" then
	enableTrigger("scribenext")

	for k,v in pairs(toScribe) do
		mud:send("prac " .. k)
		--mud:send("scribe " .. k)

		toScribe[k]=nil
		return
	end

	return
end

cecho("\n&lt;red&gt;[Type: '@scribeall start' to begin scribing the following spells:]\n")

for k,v in pairs(toScribe) do
	cecho("&lt;green&gt;" .. k .. "\n")
end

echo("\n")
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@scribeall ?(start)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@ungag</name>
					<script>local tmpvar = charData:get("gags", true)

if matches[2] == "" then
	echo("usage: @ungag text to ungag\n")
	echo("Existing gags:\n")
	display(tmpvar)
else
	for key,val in pairs(tmpvar) do
		if string.findPattern(matches[2]:lower(), val) then
			tmpvar[key]=nil
			echo(matches[2]:lower() .. " has been removed from gags.\n")
		end
	end

	charData:set("gags", tmpvar, true)

	display(tmpvar)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@ungag ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@roll</name>
					<script>if matches[2] == nil then
	cecho("&lt;red&gt;[Autoroller disabled.]\n")
	disableTrigger("RollerTrigger")
	return
end

local rollvalue = tonumber(matches[2])

charData:set("autoroll", rollvalue, true)

cecho("&lt;cyan&gt;[Autoroller enabled: Target= " .. rollvalue .. "]\n")

enableTrigger("RollerTrigger")
--mud:send("y")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@roll ?([0-9]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fpet</name>
					<script>local currentroom = map:getRoom()
local missingpet

cecho("&lt;red&gt;@fpet: find pets\n")
cecho("&lt;red&gt;Type '@fpet get' to retrieve lost pets\n\n")

if currentroom ~= nil then
	cecho("&lt;green&gt;Currently in: (" .. currentroom .. ") " .. getRoomName(currentroom) .. "\n\n")
else
	cecho("&lt;red&gt;Current room: unknown\n\n")
end

for k, petname in pairs(pet:getTable()) do
	local petroom = pet:getRoom(petname)

	if currentroom ~= nil and petroom ~= nil then
		local roomname = getRoomName(petroom)

		if petroom == currentroom then
  			cecho(string.format("&lt;green&gt;%16s : (%6s) %s\n", petname, tostring( pet:getRoom(petname) ), roomname) )
		else
  			cecho(string.format("&lt;red&gt;%16s : (%6s) %s\n", petname, tostring( pet:getRoom(petname) ), roomname) )
			missingpet = pet:getRoom(petname)
		end
	else
		cecho(string.format("&lt;red&gt;%16s : %6s\n", petname, tostring( pet:getRoom(petname) ) ) )
	end
end

if matches[2] == "get" then
	if currentroom == nil or missingpet == nil then
		cecho("&lt;green&gt;\n[No missing pets]\n")
		return
	end

	if not charData:get("autoopen") then
		cecho("&lt;red&gt;\n[autoopen is currently disabled. '&lt;green&gt;set autoopen true&lt;red&gt;' prior to using fpet get]\n")
		return
	end

	-- fwalk to room, then return to current room

	cecho("&lt;green&gt;Retrieving pet from: " .. missingpet .. "\n")

	local path=getPath( currentroom, missingpet )

	if path then
		path= compressSpeedwalk()
	end

	local reversepath= getPath( missingpet, currentroom)

	if reversepath then
		reversepath= compressSpeedwalk()
	end


	if path and reversepath then
		cecho("&lt;green&gt;Moving: " .. path .. ", " .. reversepath .. "\n")

		expandAlias("." .. path, false)
		expandAlias("." .. reversepath, false)
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fpet ?(get)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@gag</name>
					<script>local tmpvar = charData:get("gags", true)

if matches[2] == "reset" then
	cecho("&lt;red&gt;[ Resetting all custom gags ]\n")
	charData:set("gags", {}, true)
else
	if matches[2] == "" then
		cecho("&lt;red&gt;Usage:\n&lt;green&gt; @gag text to gag\n&lt;green&gt; #gag reset\n")
		cecho("&lt;red&gt;Existing gags:\n")
		display(tmpvar)
	else
		table.insert(tmpvar, matches[2]:lower())
		cecho("&lt;red&gt;[New gag created for: &lt;green&gt;" .. matches[2] .. "&lt;red&gt;]\n")
		charData:set("gags", tmpvar, true)
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@gag ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>claimall</name>
					<script>mud:send("auction list " .. whoami() )</script>
					<command></command>
					<packageName></packageName>
					<regex>^claimall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@version</name>
					<script>-- http://www.grokh.com/toril.db

NyyLIB.version = NyyLIB.version or "NyyLIB011dev"
NyyLIB.dbversion = NyyLIB.dbversion or "9/2/2018"

cecho ("\n&lt;red&gt;Script version: 9/2/2018 " .. NyyLIB.version .. " https://github.com/Nyyrazzilyss/NyyLIB\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@version$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>test</name>
					<script>
-- NyyLIB.mapwindow = Geyser.Mapper:new({name="mapper",x="66%",y=0,width="33%",height="50%"})

--testwindow = Geyser.Label:new({name="minimap", x=0, y=0, width="100%", height="100%"}, NyyLIB.mapwindow)


-- lua Geyser.Label:getWindow("gIconBarWindow"):setStyleSheet([[background-color: black]])

--rollerstats=nil
--rollTime=nil

--display( getUrl("http://regexlib.com/CheatSheet.aspx") )


--testArray= { [0]={}, [1]={}}

--display( table.size(testArray[0]) )


--testArray[1]= {"test1"}
--testArray[2] = {"test2"}



--display( string.format("%02x", 0) )

--lineCapture = {}
--currentLine = line

--local nx

--local r,g,b


--for nx=1, #currentLine, 1 do
--	selectSection(nx, 1)
	
--	r,g,b = getFgColor()
	
--	lineCapture[nx]={ string.sub(currentLine, nx, nx), r, g, b }
--end

--display(lineCapture)

--hechoLink("winALL", "|ca00040black!", [[send("hi")]], "This is a tooltip", true)

--getFgColor(windowName)
--This function returns the rgb values of the color of the first character of the current selection on mini console (window) windowName. If windowName is omitted Mudlet will use the main screen.
--Parameters
--windowName:
--A window to operate on - either a miniconsole or the main window.
--Example
--local r,g,b;
--selectString("troll",1)
--r,g,b = getFgColor()
--if r == 255 and g == 0 and b == 0 then
--    echo("HELP! troll is written in red letters, the monster is aggressive!\n");
--end





--for k,v in pairs(demonnic.chat.windows) do
--	display(k)
--end

--display(demonnic.chat.windows["ALL"].name)

--display( equip:getWeapon() )


--local lastRoom=map:getRoom()
--local lastRoomName= map:getRoomname()


--echo("KILLED in " .. lastRoomName .. " (" .. lastRoom .. ")" )

--testvar2 = getLines(getLineNumber()-500, getLineNumber())

--display(testvar2)

--display( string.byte(testvar2, 7) )
--display( string.byte(testvar2, 8) )
--display( string.byte(testvar2, 9) )

--display( string.by

--local testString= "the name of an item (magic) (illum) (damaged)"


--display( string.gsub(testString, " %(.+%)", "") )


--capture = string.gsub(capture, "%(magic%)", "")
--capture = string.gsub(capture, "%(illuminating%)", "")
--capture = string.gsub(capture, "%(glowing%)", "")
--capture = string.gsub(capture, "%(damaged%)", "")




--local roomid = map:getRoom()

--if roomid ~= nil then
--	local zoneid=tonumber(getRoomUserData(roomid, "zoneid") )

--	echo(roomid .. ", " .. getRoomName(roomid) .. " : " .. NyyLIB.areaTable[zoneid] .. "\n")
--end


--cmi:checkConnection()
--cmi:labelCmudZones(cmi.con)

--NyyLIB.broken = {}

--for line in io.lines(homepath("roomfix.txt")) do
--	NyyLIB.broken[tonumber(line)]=true
--end

--for k,v in pairs(NyyLIB.broken) do
--	local roomnumber=k
--	local zone=map:getZone(roomnumber)
--	local roomname = getRoomName(k)

--	if zone ~= nil then
--		echo( string.format("%s %d %s\n", zone, roomnumber, roomname) )
--	else
--		display(roomnumber)
--	end
	--display(k)
	--display(getRoomName(k))
--end


--	display( rex.match( "http://www.yahoo.com",
--						"\b(?:(?:(?:https?|ftp|telnet)://[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+|www|ftp)(?:\.[\w\d:#@%/;$()~_?\+\-=&amp;amp;]+)+|[\w\d._%+\-]+@[\w\d.\-]+\.[\w]{2,4})\b"
--					) )




--function testFunction()
--	return 1, 2
--nd


--local v1, v2 = testFunction()


--display( v1 )
--display( v2 )


--local v1 = testFunction()
--display(v1)


--display( tonumber( charData:get("movebuffer") ) )


--openUserWindow("testwindow")
--cecho("testwindow", "&lt;red&gt;hello &lt;blue&gt;bob!")
--resizeWindow("testwindow", 100, 100) -- name,width,height)


--for roomid, roomname in pairs(fullmap) do
--	local internalid = getRoomArea(roomid)

--	local zone=getRoomUserData(roomid, "zoneid")
--	local zoneid=tonumber(zone)

	-- first letter is lowercase

--	if string.findPattern(roomname, "^[a-z]") then
	--	echo ( string.format("%6d %20s %20s\n", roomid, NyyLIB.areaTable[zoneid], roomname ) )
--				echo ( string.format("[%25s] %20s\n", NyyLIB.areaTable[zoneid], roomname ) )
--	end

	-- last letter is a period

	--if string.findPattern(roomname, "[.]$") then
		--echo ( string.format("%6d %20s %20s\n", roomid, NyyLIB.areaTable[zoneid], roomname ) )
	--		echo ( string.format("[%25s] %20s\n", NyyLIB.areaTable[zoneid], roomname ) )
	--end
--end


--getPath( 48603, 86738)
--display(speedWalkDir)

-- cecho("&lt;red&gt;&lt;test line&gt; extra st--uff")

-- window:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])


--display( setLabelStyleSheet("gRoomWindow", [[border-image: url(]] .. mainpath("roomborder.png") .. [[)]]) )


--roomLabel = Geyser.Label:new({name="gRoomLabel", x="33%", y="0%", width="33%", height="15c",}) -- -92c, -80c
-- roomLabel:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])

--roomLabel:setStyleSheet([[border-image: url(]] .. mainpath("flames.png") .. [[)]])


--local WindowWidth, WindowHeight = getMainWindowSize()

--display(WindowWidth)
--display(WindowHeight)

--splashwindow:move("10%", "10%")
--splashwindow:resize("50%", "75%")

--for k,v in pairs(pet:getTable()) do
--	display(v)
--	display( pet:getHP(v) / pet:getMaxHP(v) )
--end

--local spectrename=pet:getTable("ghast")[1]

--display(spectrename)


--if pet:status("spectre") then



--if charData:get("autoglobe") then
--	for k,char in pairs(groupList:pc("hitter")) do
--		local hp=tonumber(groupList:getHP(char))

--		if not buff:get("globe_of_invulnerability", char) and hp ~= 0 then
--			display(char)
--		end
--	end
--end




--display( pet:isNamed("ghost ayngst undead") )


--testwindow = Geyser.Label:new({name="vote", x="20%", y="10%", width="60%", height="60%"})
--testwindow:setStyleSheet([[border-image: url(]] .. mainpath("splash.png") .. [[)]])



--display( string.match("test string", "aa") )

--display( string.match( "You peer into a wormhole and see", "You peer into (.*) and see" ) )

--	local dopplechar = string.match(spellname, "^dopple (.*)")

--for k,v in pairs( groupList:pc("psi") ) do
--	display(v)
--end












--display( string.find("aff test", "^ff") )



--local mobnames=
--		{ "zombie", "ghoul", "skeleton", "wight", "spectre", "ghast", "ghost"}

--for k,v in pairs(mobnames) do
--	display(v)
--end



--if string.findPattern("2.merchant", "(x[0-9]+)" ) ~= nil then
--	cecho(" &lt;red&gt;(x" .. (tonumber(string.findPattern(string.findPattern(previousline, "%(x([0-9]+)%)" ), "[0-9]+" ))+1) .. ")")
--end


--local tmp=to_snake("Globe of Invuln")

--display(tmp)

--display( to_english(tmp) )




--local scanresults = {}

--if #scanresults == 0 then
--	display("X")
--end



--	local WindowWidth, WindowHeight = getMainWindowSize()
--	local wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)

--	local tmp = (WindowWidth/3)/ wwidth
 

--display(tmp)


--	 demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
--   demonnic.chat.windows[tab]:setWrap(tmp) 



--labelID = createMapImageLabel(areaID, filePath, posx, posy, posz, width, height, zoom, showOnTop)

--Creates an image label on the map at the given coordinates, with the given dimensions and zoom. You might find the default room and image size correlation to be too big - try reducing the width and height of the image then, while also zooming in the same amount.
--The coordinates 0,0 are in the middle of the map, and are in sync with the room coordinates - so using the x,y values of getRoomCoordinates() will place the label near that room.
--See also: deleteMapLabel
--Example
-- 138 is our pretend area ID
-- next, inside [[]]'s, is the exact location of our image
-- 0,0,0 are the x,y,z coordinates - so this will place it in the middle of the map
-- 482 is the width of the image - we divide it by 100 to scale it down, and then we'll zoom it by 100 - making the image take up about 4 rooms in width then
-- 555 is the original width of the image
-- 100 is how much we zoom it by, 1 would be no zoom
-- and lastly, false to make it go below our rooms
--createMapImageLabel(138, [[/home/vadi/Pictures/You only see what shown.png]], 0,0,0, 482/100, 555/100, 100, false)


--display ( getAreaTable() )

--display( iconpath("back1.png") )

--local testpath="C:\\Users\\Chris\\.config\\mudlet\\profiles\\toril010rc2-2\\NyyLIB010rc2\\back1.png"

--display ( createMapImageLabel(8, testpath, 46, 19, 0, 200, 200, 100, true) )



--for i,v in pairs(Geyser.Label) do

--	display(v.name)

	--display(v.name)

	--if v.name == othername then
	--	return v
	--end
--end

-- regex match
--display( string.match("You scan north...", "You scan (%w)") )


--playSoundFile("\\tmp\\165331__ani-music__tubular-bell-of-death.wav")
--playSoundFile("\\tmp\\209740__yummie__minion-yahoo-2.wav")
--playSoundFile("\\tmp\\274736__sforsman__distort-ring-2.wav")
--playSoundFile("\\tmp\\85568__joelaudio__dragon-roar.wav")
--playSoundFile("\\tmp\\45809__themfish__gas-fire-catch.wav")
--sound("365641__furbyguy__8-bit-alarm.wav")
--sound("105308__kovrov__rumble.wav")
--sound("139025__rj10328__131659-bertrof-game-sound-intro-to-game-80921-justinbw-buttonchime02up-4.wav")


--local testpattern =string.gsub("test-st", "-", "[-]")

--if string.findPattern("thisisatest-string", testpattern) then
--	display("match")
--end



--	NyyLIB.RightLabel:move(nil, "50%")

-- the entire window is 100%, just partially off screen

--	demonnic.chat.container:move(nil, 0)
--	demonnic.chat.container:resize(nil, "40%")

-- iconbar = 20
-- bottomcount = 

--local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")

--clearWindow("gGroupStatusWindow")
--bottomWindow:show()

--bottomWindow:echo( parseLine("&lt;red&gt;test1 \ntest2 \n") )
</script>
					<command></command>
					<packageName></packageName>
					<regex>^test$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@guide - open todraels website</name>
					<script>openUrl("http://www.grokh.com/todrael/guides/newbie.html")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@guide$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@quest - open Valkurian Blades website</name>
					<script>openUrl("http://z15.invisionfree.com/Triterium_BBS")
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@quest$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@forum - open torilmud forums</name>
					<script>openUrl("http://www.torilmud.com/phpBB3/")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@forum$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>. speedwalk (tintin)</name>
					<script>if pagingmode then
	mud:send("")
	return
end

local dirString   =   matches[2]:lower()

for count, direction in string.gmatch(dirString, "([0-9]*)([neswud])") do      
	count = (count == "" and 1 or count)
   for i=1, count do
   		expandAlias(direction)
   end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^[.]([0-9nsweudNSWEUD]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>..reverse speedwalk (zmud)</name>
					<script>-- Walk reverse of path provided.
-- ..5ne will walk w5s

local reversePath = ""

local dirString   =   matches[2]:lower()

for count, direction in string.gmatch(dirString, "([0-9]*)([neswud])") do      
	reversePath = count .. NyyLIB.reversedirs[direction] .. reversePath
end

expandAlias("." .. reversePath, false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^[.][.]([0-9nsweudNSWEUD]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name># repeat (tintin)</name>
					<script>for nx=1, matches[2], 1 do
	mud:send(matches[3])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#([0-9]+) (.+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>masks</name>
					<script>local printcount=0


for k,v in pairs(masks) do
	if table.size(v) == 1 then
		echo( string.format("%-6s ", k) )
		--printcount=printcount+1

		--if printcount==5 then
		--	printcount=0
		--	echo("\n")
		--end
	end
end

echo("\n\n")

for k,v in pairs(masks) do
	if table.size(v) ~= 1 then
		echo( string.format("%-20s %s\n", k, table.concat(v, "|") ) )
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^masks$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>advert</name>
					<script>mud:send("NHC Toril Mud Client Script Updated: 4/22/18 011rc2 http://www.torilmud.com/phpBB3/viewtopic.php?f=4&amp;t=26684")</script>
					<command></command>
					<packageName></packageName>
					<regex>^advert$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>lf</name>
					<script>-- mud:send("gcc LF: phantom quill, talisman of demonic rage")
-- mud:send("gcc FT: skull-cap of truespeed, ashen cage, loop of shale, smoke filled crystal ball, seaweed ring, pelt of demonhide, headbands a-&gt;j, more")</script>
					<command></command>
					<packageName></packageName>
					<regex>^lf$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>sound</name>
					<script>mud:send("GCC LF: suggested sound id#'s and events to play them - https://www.freesound.org/")</script>
					<command></command>
					<packageName></packageName>
					<regex>^sound$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>p</name>
					<script>mud:send(p(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^p (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>g</name>
					<script>mud:send(g(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^g (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>loot</name>
					<script>for nx=matches[2], 1, -1 do
	mud:send("GET all.coins " .. nx .. ".corpse")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^loot ([0-9]+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>dep</name>
					<script>enableTrigger("DepositTrigger")
mud:send( p("all.coin") )
mud:send( g("all.coin") )
mud:send( p("all.lucky") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^dep$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>meph</name>
					<script>mud:send("rescue ekahk")
mud:send("rescue mephit")
mud:send("rescue 2.mephit")
mud:send("rescue 3.mephit")
mud:send("rescue 4.mephit")
mud:send("rescue 5.mephit")
mud:send("rescue slaad")</script>
					<command></command>
					<packageName></packageName>
					<regex>^meph$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>^swap ?(girdle|loop|slaad)?$</name>
					<script>local item=matches[2]

if item == nil then
	cecho("&lt;red&gt;[swap volance|onevolance|girdle|loop|slaad|slaads|time|oneslaad to change item]\n")
	return
end

if item == "volance" then
	mud:send("rem volance")
	mud:send("rem volance")
	mud:send("wear volance")
	mud:send("wear volance")
	timer:set("TiaVolance", 1)
elseif item == "warder" then
	mud:send("get warder hole")
	mud:send("rem warder")
	mud:send("put warder hole")
	mud:send("wear warder")
elseif item == "onevolance" then
	mud:send("get volance hole")
	mud:send("rem volance")
	mud:send("put volance hole")
	mud:send("wear volance")
elseif item == "sleeves" then
	timer:set("TiaSleeves", 0)
	mud:send("get gossamer hole")
	mud:send("rem gossamer")
	mud:send("put gossamer hole")
	mud:send("wear gossamer")
elseif item == "manacle" then
	mud:send("get unfettered hole")
	mud:send("rem unfettered")
	mud:send("put unfettered hole")
	mud:send("wear unfettered")
	timer:set("TiaManacle", nil)
elseif item == "manacles" then
	mud:send("rem manacle")
	mud:send("rem manacle")
	mud:send("wear 2.manacle")
	mud:send("wear manacle")
	timer:set("TiaManacle", nil)
elseif item == "time" then
	mud:send("rem time")
	mud:send("get 3.time hole")
	mud:send("wear time")
	mud:send("put time hole")
elseif item == "loop" then
	mud:send("rem loop")
	mud:send("rem loop")
	mud:send("wear 2.loop")
	mud:send("wear loop")
	timer:set("TiaLoop", 1)
elseif item == "slaad" then
	mud:send("rem baatorian")
	mud:send("rem baatorian")
	mud:send("wear 2.baatorian")
	mud:send("wear baatorian")
	timer:set("baatorian", 1)
elseif item == "slaads" then
	mud:send("get baatorian hole")
	mud:send("get baatorian hole")
	mud:send("rem baatorian")
	mud:send("rem baatorian")
	mud:send("put baatorian hole")
	mud:send("put baatorian hole")
	mud:send("wear baatorian")
	mud:send("wear baatorian")
	timer:set("baatorian", 1)
elseif item == "oneslaad" then
	mud:send("get 4.baatorian portable")
	mud:send("rem baatorian")
	mud:send("put baatorian hole")
	mud:send("wear baatorian")
elseif item == "girdle" then
	mud:send( g("girdle") )
	mud:send("rem girdle")
	mud:send( p("girdle") )
	mud:send("wear girdle")
	timer:set("SuppleGirdle", 1)
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^swap ?(sleeves|girdle|loop|slaad|slaads|time|oneslaad|volance|onevolance|manacle|manacles|warder)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>dresschar</name>
					<script>mud:send("storage retrieve hole")

mud:send("get insignia hole")
mud:send("wear insignia")

if whoami() == "Innanin" then
  mud:send("get merchants hole")
  mud:send("wear merchants")
  mud:send("get matriarch merchants")
  mud:send("wield matriarch")
  mud:send("get bane merchants")
  mud:send("wield bane")
  mud:send("get serpent hole")
  mud:send("get cringing merchants")
  mud:send("get buckles merchants")
  mud:send("get silvered merchants")
  mud:send("wear all")
  mud:send("get crescent merchants")
  mud:send("get kossuth merchants")
  mud:send("get congealed merchants")
  mud:send("get congealed merchants")
  mud:send("get cincture merchants")
  mud:send("get demonleather merchants")
  mud:send("wear all")
  mud:send("get lustrous merchants")
  mud:send("get lustrous merchants")
  mud:send("get darkness merchants")
  mud:send("get marilith merchants")
  mud:send("get extremely merchants")
  mud:send("get protruding merchants")
  mud:send("get gauntlets merchants")
  mud:send("get rakshasa merchants")
  mud:send("wear all")
  mud:send("get seal hole")
end

if whoami() == "Bombad" then
	mud:send("storage retrieve glory")
	mud:send("wield glory")
	mud:send("get chimera hole")
	mud:send("wear chimera")
	mud:send("get ashstone hole")
	mud:send("wear ashstone")
	mud:send("get fires hole")
	mud:send("wear fires")
	mud:send("get stud hole")
	mud:send("wear stud")
	mud:send("get segmented hole")
	mud:send("wear segmented")
	mud:send("get segmented hole")
	mud:send("wear segmented")
	mud:send("get mask hole")
	mud:send("wear mask")
	mud:send("get selari hole")
	mud:send("wear selari")
	mud:send("get waistwrap hole")
	mud:send("wear waistwrap")
	mud:send("get warder hole")
	mud:send("wear warder")
	mud:send("get time hole")
	mud:send("wear time")
	mud:send("get unfettered hole")
	mud:send("wear unfettered")
	mud:send("get baatorian hole")
	mud:send("wear baatorian")
	mud:send("get planetar hole")
	mud:send("wear planetar")
	mud:send("get rock hole")
	mud:send("get rock hole")
	mud:send("wear rock")
	mud:send("wear rock")
	mud:send("get balor hole")
	mud:send("wear balor")
	mud:send("get flame hole")
	mud:send("wear flame")
	mud:send("get seal hole")
end

if whoami() == "Rrissun" then
	mud:send("storage retrieve glory")
	mud:send("wield glory")
	mud:send("get chimera hole")
	mud:send("wear chimera")
	mud:send("get mask hole")
	mud:send("wear mask")
	mud:send("get warder hole")
	mud:send("wear warder")
	mud:send("get baatorian hole")
	mud:send("wear baatorian")
	mud:send("get rock hole")
	mud:send("get rock hole")
	mud:send("wear rock")
	mud:send("wear rock")
	mud:send("get waistwrap hole")
	mud:send("get time hole")
	mud:send("get planetar hole")
	mud:send("get matter hole")
	mud:send("wear all")
	mud:send("get unfettered hole")
	mud:send("get selari hole")
	mud:send("get symbol hole")
	mud:send("get symbol hole")
	mud:send("get symbol hole")
	mud:send("wear all")
	mud:send("get seal hole")
	mud:send("powers info vit")
end

if whoami() == "Adud" or whoami() == "Wopur" or whoami() == "Samem" or whoami() == "Ihgod" or whoami() == "Tutenef" then
	mud:send("storage retrieve valhalla")
	mud:send("wield valhalla")

	if whoami() ~= "Tutenef" then
		mud:send("get shield hole")
		mud:send("wear shield")
		mud:send("get berserker hole")
	else
		mud:send("get electricity hole")
		mud:send("get graven hole")
		mud:send("wield graven")
	end
	
	mud:send("get serpent hole")
	mud:send("get girdle hole")
	mud:send("get mask hole")
	mud:send("get stud hole")
	mud:send("get stud hole")
	mud:send("wear all")
	mud:send("get quiver hole")
	mud:send("get isha hole")
	mud:send("get cenobite hole")
	mud:send("get mail hole")
	mud:send("get stability hole")
	mud:send("get sorcerous.loop hole")
	mud:send("get sorcerous.loop hole")
	mud:send("wear all")
	mud:send("get volance hole")
	mud:send("get volance hole")
	
	mud:send("get shard hole")
	mud:send("get plates hole")
	mud:send("get bracer.mithril.mesh hole")
	mud:send("get darkwood hole")
	mud:send("wear all")
	mud:send("get seal hole")
end

if whoami() == "Samem" then
	mud:send("storage retrieve planetar")
end

if whoami() == "Nyyrazzilyss" then
	mud:send("get barrier hole")
	mud:send("wear barrier")
	mud:send("get arch hole")
	mud:send("get fires hole")
	mud:send("get all.drow hole")
	mud:send("get force hole")
	mud:send("get swirling hole")
	mud:send("wear all")
	mud:send("put drow hole")
	mud:send("get gossamer hole")
	mud:send("get slaadi hole")
	mud:send("get breeches hole")
	mud:send("get kinesis hole")
	mud:send("get kinesis hole")
	mud:send("wear all")
	mud:send("get sandals hole")
	mud:send("get baatorian hole")
	mud:send("get baatorian hole")
	mud:send("wear all")
end

if whoami() == "Bonble" then
  mud:send("get merchants hole")
  mud:send("wear merchants")
  mud:send("get matriarch merchants")
  mud:send("wield matriarch")
  mud:send("get ravenous merchants")
  mud:send("wield ravenous")
  mud:send("get serpent hole")
  mud:send("get gossamer hole")
  mud:send("get cringing merchants")
  mud:send("get buckles merchants")
  mud:send("get silvered merchants")
  mud:send("get crescent merchants")
  mud:send("wear all")
  mud:send("get gorget hole")
  mud:send("get congealed merchants")
  mud:send("wear congealed")
  mud:send("get baatorian hole")
  mud:send("get baatorian hole")
  mud:send("get insignia hole")
  mud:send("get girdle hole")
  mud:send("wear all")
  mud:send("get batskull hole")
  mud:send("get swirling hole")
  mud:send("get kinesis hole")
  mud:send("get rock hole")
  mud:send("get scalemail merchants")
  mud:send("get sharp hole")
  mud:send("get marilith merchants")
  mud:send("wear all")
  mud:send("get seal hole")
end

if whoami() == "Vottoc" then
  mud:send("get merchants hole")
  mud:send("wear merchants")
  mud:send("get fireballs merchants")
  mud:send("get cringing merchants")
  mud:send("get congealed merchants")
  mud:send("get congealed merchants")
  mud:send("get drogino merchants")
  mud:send("wear all")
  mud:send("get gorget hole")
  mud:send("get gorget hole")
  mud:send("get flesh merchants")
  mud:send("get baatorian hole")
  mud:send("get bracer hole")
  mud:send("get insignia hole")
  mud:send("get marilith merchants")
  mud:send("wear all")
  mud:send("get batskull hole")
  mud:send("get rock hole")
  mud:send("get dwarfhide merchants")
  mud:send("get giant hole")
  mud:send("get studs merchants")
  mud:send("get scalemail merchants")
  mud:send("get swirling hole")
  mud:send("get girdle hole")
  mud:send("wear all")
  mud:send("get matriarch merchants")
  mud:send("wield matriarch")
  mud:send("get bane merchants")
  mud:send("wield bane")
  mud:send("get seal hole")
end

if whoami() == "Ajac" or whoami() == "Imseh" or whoami() == "Aynep" or whoami() == "Cajeed" then
	mud:send("get barrier hole")
	mud:send("wear barrier")
	mud:send("get arch hole")
	mud:send("hold arch")
	mud:send("get chimera hole")
	mud:send("get mauve hole")
	mud:send("get batskull hole")
	mud:send("get fires hole")
	mud:send("get all.drow hole")
	mud:send("wear all")
	mud:send("get all.force hole")
	mud:send("get swirling hole")
	mud:send("get slaadi hole")
	mud:send("get gossamer hole")
	mud:send("wear all")
	mud:send("get kinesis hole")
	mud:send("get kinesis hole")
	mud:send("get breeches hole")
	mud:send("wear all")
	mud:send("get baatorian hole")
	mud:send("get baatorian hole")
	mud:send("get sharp hole")
	mud:send("wear all")
	mud:send("get sandals hole")
	mud:send("wear sandals")
end

if whoami() == "Rrassulis" then
	mud:send("get barrier hole")
	mud:send("wear barrier")
	mud:send("get arch hole")
	mud:send("hold arch")
	mud:send("get chimera hole")
	mud:send("get mauve hole")
	mud:send("get amethyst hole")
	mud:send("get all.force hole")
	mud:send("wear all")
	mud:send("get all.drow hole")
	mud:send("get swirling hole")
	mud:send("get slaadi hole")
	mud:send("get gossamer hole")
	mud:send("wear all")
	mud:send("get kinesis hole")
	mud:send("get rock hole")
	mud:send("wear all")
	mud:send("get baatorian hole")
	mud:send("get baatorian hole")
	mud:send("get sharp hole")
	mud:send("wear all")
	mud:send("get diamond hole")
	mud:send("wear diamond tail")
	mud:send("get seal hole")
end

mud:send("equip")</script>
					<command></command>
					<packageName></packageName>
					<regex>^dresschar$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>undresschar</name>
					<script>function removeAll()
	mud:send("rem all")
	mud:send("put all hole")
	mud:send("rem all")
	mud:send("put all hole")
	mud:send("rem all")
	mud:send("put all hole")
end

mud:send("storage access nyyrazzilyss")

mud:send("rem insignia")
mud:send("put insignia hole")

if whoami() == "Innanin" then
	mud:send("rem insignia")
	mud:send("rem circlet")
	mud:send("put all hole")
	mud:send("rem all")
	mud:send("put all merchants")
	mud:send("rem all")
	mud:send("put all merchants")
	mud:send("rem all")
	mud:send("put all merchants")
	mud:send("get portable merchants")
	mud:send("put merchants portable")
end
  
if whoami() == "Rrissun" or whoami() == "Bombad" then
	mud:send("rem warmaul")
	mud:send("storage store warmaul")
	removeAll()
end

if whoami() == "Ajac" or whoami() == "Imseh" or whoami() == "Aynep" or whoami() == "Rrassulis" or whoami() == "Cajeed" then
	removeAll()

	if whoami() == "Aynep" then
		mud:send("get tome hole")
	elseif whoami() == "Ajac" then
		mud:send("get midnight-blue hole")
	else
		mud:send("get planetar hole")
	end

   	mud:send("get barrel hole")
end

if whoami() == "Nyyrazzilyss" then
	mud:send("rem barrier")
	mud:send("put barrier hole")
	mud:send("rem fires")
	mud:send("put fires hole")
	mud:send("rem ice")
	mud:send("put ice hole")
	mud:send("rem drow")
	mud:send("rem drow")
	mud:send("put all.drow hole")
	mud:send("rem force")
	mud:send("put force hole")
	mud:send("rem swirling")
	mud:send("put swirling hole")
	mud:send("rem pixie")
	mud:send("put pixie hole")
	mud:send("rem belt")
	mud:send("put belt hole")
	mud:send("rem sleeves")
	mud:send("put sleeves hole")
	mud:send("rem bracer")
	mud:send("rem bracer")
	mud:send("put all.bracer hole")
	mud:send("rem ring")
	mud:send("rem ring")
	mud:send("put all.ring hole")
	mud:send("rem staff")
	mud:send("put staff hole")
	mud:send("rem breeches")
	mud:send("put breeches hole")
	mud:send("rem sandals")
	mud:send("put sandals hole")
end

if whoami() == "Samem" then
	mud:send("rem planetar")
	mud:send("storage store planetar")
end

if whoami() == "Adud" or whoami() == "Wopur" or whoami() == "Samem" or whoami() == "Ihgod" or whoami() == "Tutenef" then
	mud:send("rem valhalla")
	mud:send("storage store valhalla")
	removeAll()
end

if whoami() == "Bonble" then
	mud:send("rem gossamer")
	mud:send("rem serpent")
	mud:send("rem swirling")
	mud:send("rem baatorian")
	mud:send("rem baatorian")
	mud:send("rem kinesis")
	mud:send("rem rock")
	mud:send("rem sharp")
	mud:send("rem batskull")
	mud:send("put all hole")
	mud:send("rem sandals")
	mud:send("put sandals hole")
	mud:send("rem girdle")
	mud:send("put girdle hole")
	mud:send("rem all")
	mud:send("put all merchants")
	mud:send("rem all")
	mud:send("put all merchants")
	mud:send("get hole merchants")
	mud:send("put merchants hole")
end

if whoami() == "Vottoc" then
	mud:send("rem crown")
	mud:send("put crown merchants")
	mud:send("rem blood")
	mud:send("rem blood")
	mud:send("rem batskull")
	mud:send("put batskull merchants")
	mud:send("put all.blood merchants")
	mud:send("rem cringing")
	mud:send("put cringing merchants")
	mud:send("rem scalemail")
	mud:send("put scalemail merchants")
	mud:send("rem swirling")
	mud:send("put swirling hole")
	mud:send("rem sleeves")
	mud:send("put sleeves merchants")
	mud:send("rem baatorian")
	mud:send("rem baatorian")
	mud:send("put all.baatorian hole")
	mud:send("rem rock")
	mud:send("put rock hole")
	mud:send("rem matriarch")
	mud:send("put matriarch merchants")
	mud:send("rem bane")
	mud:send("put bane merchants")
	mud:send("rem boots")
	mud:send("put boots merchants")
	mud:send("rem merchants")
	mud:send("rem studs")
	mud:send("put studs merchants")
	mud:send("rem gorget")
	mud:send("put gorget hole")
	mud:send("rem gorget")
	mud:send("put gorget hole")
	mud:send("put merchants hole")
end

mud:send("put sack hole")

mud:send("storage store hole")

mud:send("equip")</script>
					<command></command>
					<packageName></packageName>
					<regex>^undresschar$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>encon</name>
					<script>mud:send("rem circlet")
mud:send("get hat hole")
mud:send("wear hat")
mud:send("put circlet hole")
mud:send("rem kinesis")
mud:send("rem kinesis")
mud:send("put kinesis hole")
mud:send("put kinesis hole")
mud:send("get power hole")
mud:send("wear power")
mud:send("get power hole")
mud:send("wear power")
mud:send("rem staff")
mud:send("put staff hole")
mud:send("get dagger hole")
mud:send("wield dagger")
mud:send("rem mask")
mud:send("get gem hole")
mud:send("wear gem")
mud:send("put mask hole")
mud:send("powers info time")
mud:send("powers info gi")
mud:send("powers info blur")
mud:send("powers info hs")</script>
					<command></command>
					<packageName></packageName>
					<regex>^encon$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>encoff</name>
					<script>mud:send("rem hat")
mud:send("get circlet hole")
mud:send("wear circlet")
mud:send("put hat hole")
mud:send("rem power")
mud:send("rem power")
mud:send("put power hole")
mud:send("put power hole")
mud:send("get kinesis hole")
mud:send("wear kinesis")
mud:send("get kinesis hole")
mud:send("wear kinesis")
mud:send("rem dagger")
mud:send("put dagger hole")
mud:send("get staff hole")
mud:send("hold staff")
mud:send("rem gem")
mud:send("put gem hole")
mud:send("get mask hole")
mud:send("wear mask")
mud:send("powers info time")
mud:send("powers info gi")
mud:send("powers info blur")
mud:send("powers info hs")</script>
					<command></command>
					<packageName></packageName>
					<regex>^encoff$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>fly</name>
					<script>if charData:get("container") == nil then
	cecho("&lt;red&gt;[container not set]\n")
	return
end

mud:send("rem swirling")
mud:send( p("swirling") )
mud:send( g("wings") )
mud:send("wear wings")</script>
					<command></command>
					<packageName></packageName>
					<regex>^fly$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>walk</name>
					<script>if charData:get("container") == nil then
	cecho("&lt;red&gt;[container not set]\n")
	return
end

mud:send("rem wings")
mud:send( p("wings") )
mud:send( g("swirling") )
mud:send("wear swirling")</script>
					<command></command>
					<packageName></packageName>
					<regex>^walk$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>food</name>
					<script>local container=charData:get("container")

if container == "" then
	cecho("&lt;red&gt;[container not set]\n")
	return
end

mud:send("EAT " .. charData:get("food") .. " " .. container)
mud:send( g(charData:get("canteen")) )
mud:send("DRINK " .. charData:get("canteen") )
mud:send( p(charData:get("canteen")) )</script>
					<command></command>
					<packageName></packageName>
					<regex>^food$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>seal</name>
					<script>mud:send( g("seal") )
mud:send("rec seal me")</script>
					<command></command>
					<packageName></packageName>
					<regex>^seal$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>vitme</name>
					<script>mud:send("quaff cactus " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^vitme$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>armor</name>
					<script>mud:send( g("ab") )
mud:send("rec ab me")</script>
					<command></command>
					<packageName></packageName>
					<regex>^armor$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>scaleme</name>
					<script>mud:send("quaff blood hole")
--mud:send("quaff blood " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^scaleme$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>hasteme</name>
					<script>mud:send("quaff haste " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^hasteme$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>zzz</name>
					<script>mud:send("get mistwalker hole")
mud:send("rec mistwalker me")

if checkMask("psi") then
	mud:send("darkness")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^zzz$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>multidrag</name>
					<script>display("drag " .. matches[2] .. " corpses " .. matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^multidrag ([0-9]+) ([nsewud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>tiap ?(gsay|acc)?</name>
					<script>if matches[2] == "gsay" then
	--send("gsay * Tiamat Points - This does NOT include current run")
end

for k,char in pairs(groupList:pc()) do
	if inwho(char) then
		local temp=string.format("[%11s] (%13s) %6d\n", char,	"@" .. inwho(char),getPoints(inwho(char)) )

		if matches[2] == nil then
			echo(temp)
		end

		if matches[2] == "gsay" then
			mud:send("GSAY * " .. temp)
		end

		if matches[2] == "acc" then
			mud:send("ACC * " .. temp)
		end
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^tiap ?(gsay|acc)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>testportal</name>
					<script>enteredPortal={}

alreadyEnteredPortal=true

spell:clear()

mud:send("ST")

display( map:getRoom())

if map:getRoom() ~= nil then
		local specialexit = getSpecialExitsSwap( map:getRoom() )

		display(specialexit)

		if table.size(specialexit) == 1 then
			for k,v in pairs(specialexit) do
					local exitcmd=string.split(k, "|")[1]

					display(exitcmd)

					
					map:processMovement(exitcmd)
					--mud:send (exitcmd)
			end
		end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^testportal$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@ynnd</name>
					<script>mud:send("t Ynndchiarhlizz worm " .. whoami() )</script>
					<command></command>
					<packageName></packageName>
					<regex>^@ynnd$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@fol mobname</name>
					<script>-- follow an unfollowable mob

toFollow = matches[2]

cecho("&lt;green&gt;[Now following: " .. string.title(matches[2]) .. "]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@fol (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@dp - divine powers/ bracelet</name>
					<script>mud:send("get mist.realms hole")
mud:send("rem baatorian")
mud:send("wear mist.realms")
mud:send("SAY stronmaus")
mud:send("rem mist.realms")
mud:send("put mist.realms hole")
mud:send("wear baatorian")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@dp$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@minimap</name>
					<script>-- toggle display of room window on/off

miniMap:toggle()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@minimap$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>MudAliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>follow</name>
					<script>mud:send ("FOL " .. matches[2] )</script>
					<command></command>
					<packageName></packageName>
					<regex>^fol (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>powers</name>
					<script>mud:send("POWERS " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^powers (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>help</name>
					<script>mud:send("HELP " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^help (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>forget spellname</name>
					<script>mud:send("FORGET " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^forget (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>eq</name>
					<script>mud:send("EQ")</script>
					<command></command>
					<packageName></packageName>
					<regex>^eq$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>mem spellname</name>
					<script>mud:send("MEM " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^mem (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>tog</name>
					<script>mud:send("TOG " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^tog (.+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>scan</name>
					<script>scanned={}
mud:send("SCAN")</script>
					<command></command>
					<packageName></packageName>
					<regex>^scan$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>l (look)</name>
					<script>gaglook=nil

mud:send("L" .. (matches[3] or "") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^(l|look)( .*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>nhc</name>
					<script>if charData:get("swedish", true) then
	mud:send ("NHC " .. swedish(matches[2]) )
else
	mud:send ("NHC " .. matches[2] )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^nhc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>tell</name>
					<script>-- que tell

mud:send ("T " .. matches[2] )</script>
					<command></command>
					<packageName></packageName>
					<regex>^t (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>gcc (swedish)</name>
					<script>if charData:get("swedish", true) then
	mud:send ("GCC " .. swedish(matches[2]) )
else
	mud:send ("GCC " .. matches[2] )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^gcc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>say swedish</name>
					<script>-- swedish disabled because it doesn't proc properly

mud:send ("SAY " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^say (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>ooc swedish</name>
					<script>if charData:get("swedish", true) then
	mud:send ("OOC " .. swedish(matches[2]), false)
else
	mud:send ("OOC " .. matches[2], false)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^ooc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>acc swedish</name>
					<script>if charData:get("swedish", true) then
	mud:send ("ACC " .. swedish(matches[2]) )
else
	mud:send ("ACC " .. matches[2] )
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^acc (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>gsay (gcmd)</name>
					<script>charData:init("gcmd", false)

-- don't gsay if only a single groupmember and train is active

if isActive("SMTrain", "trigger") ~= 0 and groupList:size() == 1 then
	return
end

if charData:get("gcmd") then
	if charData:get("swedish", true) then
		mud:send("GCMD " .. swedish(matches[2]) )
	else
		mud:send("GCMD " .. matches[2])
	end
else
	if charData:get("swedish", true) then
		mud:send("GSAY " .. swedish(matches[2]) )
	else
		mud:send("GSAY " .. matches[2] )
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^gsay (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>gcmd</name>
					<script>
-- don't gcmd if only a single groupmember and train is active

if isActive("SMTrain", "trigger") ~= 0 and groupList:size() == 1 then
	
	-- since not gcmd'ing, echo locally
	cecho("&lt;green&gt;\n" .. matches[2] .. "\n")
	--mud:send("")
	
	return
end

if charData:get("swedish", true) then
	mud:send("GCMD " .. swedish(matches[2]) )
else
	mud:send("GCMD " .. matches[2])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^gcmd (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>consent</name>
					<script>consent.chars= {}
mud:send("CONSENT", false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^consent$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>escape</name>
					<script>if checkMask("rogue") then
	NyyLIB.escapedir = matches[2]
	mud:send("ESCAPE " .. matches[2])
else
	NyyLIB.escapedir = matches[2]

	if checkMask("caster") then
		-- erase spellqueue if any spells present
		spell:eraseQueue()

		-- disable autocast
		buttons:change("autocast", false, "SpellsButton")

		spell:clear()
	end

	-- set as currently moving
	spell:setMoving(true)

	mud:send("FLEE", false)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^escape ([neswud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>mem</name>
					<script>-- Can't be moving if mem has been sent
spell:setMoving(false)
setQuake(false)

if checkMask("blk") then
	return
end

automem = 2

if memsent == true then
	cecho("&lt;red&gt;[Mem previously sent: type 'prepare' to force]\n")
	return
end

if spell:getMem() == true then
	cecho("&lt;red&gt;\n[Already meming - If not type 'prepare']\n")
	return
end


if charData:get("memcount") == nil or charData:get("memcount") == 0 and not checkMask("psi") then
	cecho("&lt;red&gt;\n[Mem has completed. Type 'memd' or 'prayd' to list spells. Type 'prepare' to force mem]\n")
	return
end

if inCombat() then
	echoDebug("&lt;red&gt;[Fighting, can't memorize]\n")
	return
end

if checkMask("singer") == false then
	mud:send("REST")
else
	cecho("&lt;red&gt;[Singers can't memorize.]\n")
	return
end

local label=findlabel("MemButton")

-- replace with function call

if label ~= nil then
	setLabelImage("MemButton", "stand.png")
	
	--label:setStyleSheet([[border-image: url(]] .. iconpath("stand.png") .. [[)]])
	--echoDebug("&lt;red&gt;[Setting membutton to stand]")
end

if checkMask("psi") then
	if charData:get("psicrystal") ~= "" then
		mud:send("chargepsp " .. charData:get("psicrystal") )
	end

	mud:send("MED")
else
	if checkMask("caster") then
		spell:clear()
	end

	-- prepare doesn't give spell count
	--send("prepare")

	memsent=true

	if checkMask("pray") then
		mud:send("PRAY")
	else
		mud:send("MEM")
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^(mem|pray)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>checkbucket</name>
					<script>function getbuckets()
	disableTrigger("Zurg")

	if #NyyLIB.buckets &gt; 0 then
		echo("[Buckets]\n")
		display( NyyLIB.buckets )

		mud:send("st")
		expandAlias("enter pathway", false)

		getPath(85075, NyyLIB.buckets[1])
	 	expandAlias("." .. compressSpeedwalk(), false)

		mud:send("darkness")
		mud:send("get all")
		mud:send("darkness")

		getPath(NyyLIB.buckets[1], 79574)
	 	expandAlias("." .. compressSpeedwalk(), false)

		table.remove(NyyLIB.buckets, 1)

		mud:send("put all.bucket hole")
		mud:send("drop all.squash")

		tempTimer(10, [[getbuckets()]])	
	else
		echo("[No buckets found.]\n")

		mud:send("rest")
		mud:send("darkness")
	end
end

expandAlias("@find", false)


local currentroom = map:getRoom()

if currentroom == 79573 or currentroom == 79574 then
	echo("[Running Zurg script]\n")

	NyyLIB.buckets={}
	enableTrigger("Zurg")

	tempTimer(3600, [[expandAlias("checkbucket")]])

	if currentroom == 79573 then
		expandAlias(".uw", false)
	end

	mud:send("st")
	mud:send("project schism")
	expandAlias("enter pathway")
	expandAlias(".2w2s2enwn2e", false)

	tempTimer(10, [[getbuckets()]])
else
	echo("[Not in Wagontrack Pass - Zurg script cancelled.]\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^checkbucket$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>who</name>
					<script>mud:send("WHO " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^who (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>status</name>
					<script>showstatus=true

local charname=matches[2]

if charname ~= nil then
	mud:send("STATUS " .. charname)
else
	mud:send("STATUS")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^status ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>con</name>
					<script>if matches[2] == nil then
	mud:send("CON")
else
	mud:send("CON " .. matches[2])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^con ?([A-Za-z]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>followers</name>
					<script>gagfollowers=nil

-- reset flag and resend
sendFollowers(false)
sendFollowers()
</script>
					<command></command>
					<packageName></packageName>
					<regex>^(fols|followers)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>stand</name>
					<script>automem=0

mud:send("ST")</script>
					<command></command>
					<packageName></packageName>
					<regex>^st$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>group</name>
					<script>mud:send("GROUP")

-- send followers after group if not rogue
if not checkMask("rog") then
	sendFollowers()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^group$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>order</name>
					<script>mud:send("ORDER " .. matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^o (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>recharge</name>
					<script>nogagRecharge = true

mud:send("RECHARGE")</script>
					<command></command>
					<packageName></packageName>
					<regex>^recharge$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Demonnic</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Shared</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Reset chasing</name>
						<script>demonnic.chaser:reset()</script>
						<command></command>
						<packageName></packageName>
						<regex>^chaseres$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Debug</name>
						<script>-- commented out 10/11/16

--if matches[2] then
--  demonnic:listCategories()
--else
--  demonnic:toggleDebug()
--end</script>
						<command></command>
						<packageName></packageName>
						<regex>^debug(?: (list))?$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>debug categories</name>
						<script>if matches[2] then
  demonnic:watchCategory( matches[2] )
else
  demonnic:listCategories()
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^debugc(?: (.*))?$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>Tabbed Chat</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="no" isFolder="no">
						<name>Toggle blinking (temporary change)</name>
						<script>if demonnic.chat.config.blink then
  demonnic.chat.config.blink = false
  demonnic.chat.tabsToBlink = {}
  demonnic:echo("Blinking temporarily turned &lt;red&gt;off&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to false in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
else
  demonnic.chat.config.blink = true
  demonnic.chat:blink()
  demonnic:echo("Blinking temporarily turned &lt;red&gt;on&lt;grey&gt;. It will reset if you edit your tabbed chat configuration, or close and reopen mudlet. To make it permanent, change demonnic.chat.config.blink to true in \"Demonnic-&gt;Tabbed Chat-&gt;Configuration options\" under scripts\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^dblink$</regex>
					</Alias>
					<Alias isActive="no" isFolder="no">
						<name>fixChat</name>
						<script>local currentsetting = demonnic.chat.config.location
local newsetting = ""
if currentsetting == "topright" then 
  newsetting = "bottomleft" 
elseif currentsetting == "topleft" then
  newsetting = "bottomright"
elseif currentsetting == "bottomleft" then
  newsetting = "topright"
elseif currentsetting == "bottomright" then
  newsetting = "topleft"
end

demonnic.chat.config.location = newsetting
demonnic.chat:create()
demonnic.chat.config.location = currentsetting
demonnic.chat:create()</script>
						<command></command>
						<packageName></packageName>
						<regex>^fixchat$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>SplitClass</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@bid</name>
					<script>local biditem= matches[4], bids, bidders
local xname=string.lower(matches[3]):title()

if matches[2] == "help" then
	echo("\n@bid init\n")
	echo("@bid addchar name, bid delchar name\n")
	echo("\n@bid start\n")
	echo("@bid open\n")
	echo("@bid stop\n")
	echo("\n@bid add charname itemname\n")
	echo("@adddice charname roll\n")
	echo("\n@bid status\n")
end

if matches[2] == "status" then	
	local allbidders

	allbidders=table.deepcopy(NyyLIB.validbidders)

	if NyyLIB.bids == nil then
		echo("Bidding is currently closed. Type 'bid help' for commands.\n")
		return
	end

	echo("Bids received:\n\n")

	display(NyyLIB.bids)

	for k,v in pairs(NyyLIB.bids) do
		table.remove(allbidders, table.index_of(allbidders, k))
		echo(k .. " - " .. v .. "\n")
	end

	echo("\nMissing bids:\n")

	display(allbidders)

	--display(NyyLIB.validbidders)

	echo("\nDice:\n")

	display(NyyLIB.trackbid)

end


if matches[2] == "init" then
	mud:send("GLIST")
	NyyLIB.validbidders = groupList:pc("all")

	disableTrigger("acceptbid")
	disableTrigger("acceptdice")

	NyyLIB.trackbid = {}

	cecho("\n&lt;green&gt;[Split script enabled:]\n")

	cecho("&lt;green&gt;[Total number of bidders: " .. #NyyLIB.validbidders .. "]\n")
	display(NyyLIB.validbidders)
end

if matches[2] == "delchar" then
	table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, xname))
	display(NyyLIB.validbidders)
end

if matches[2] == "addchar" then
	table.insert(NyyLIB.validbidders, 1, xname)
	display(NyyLIB.validbidders)
end

if matches[2] == "start" then
	mud:send("gsay [--------------------------]")
	mud:send("gsay tell " .. whoami() .. " 'bid itemname' or 'bid abstain'")
	mud:send("gsay Resend the tell if you wish to change it.")
	mud:send("gsay You will receive a confirmation tell on")
	mud:send("gsay a successful bid. Bids can NOT be changed")
	mud:send("gsay after all bids have been received.")
  
	NyyLIB.fullbidderlist=NyyLIB.validbidders

	expandAlias("@bid open")

end

if matches[2] == "open" then
	NyyLIB.bidding=1
	NyyLIB.bids={}

	mud:send("gsay Bids will now be accepted from " .. table.concat(NyyLIB.validbidders, "|"))
	enableTrigger("acceptbid")
end

if matches[2] == "add" then
	local abort=1
	local itemMatches=0

	if isActive("acceptbid", "trigger") == 0 then
		cecho("\n&lt;red&gt;[Bidding is currently closed.]\n")
		return
	end


	for nx=1, #NyyLIB.validbidders, 1 do
		if NyyLIB.validbidders[nx]:lower() == string.lower(matches[3]) then
			abort=0
		end
	end

	if abort == 1 then
		cecho("&lt;red&gt;[Not a valid bidder]\n")
		return
	end

	if table.contains(NyyLIB.groupitems, matches[3]) then
		biditem= NyyLIB.groupitems[table.index_of(NyyLIB.groupitems, xname)]
	else
		local nx
		local founditem
		local testitem = string.gsub(biditem, "-", "[-]") -- testitem is regex

		for nx=1, #NyyLIB.groupitems, 1 do
			if string.findPattern(NyyLIB.groupitems[nx]:lower(), testitem:lower()) then
				founditem = NyyLIB.groupitems[nx]
				itemMatches=itemMatches+1
			end
		end

		if itemMatches == 1 then
			biditem=founditem
		end
	end
	
	if biditem == "abstain" or table.contains(NyyLIB.groupitems, biditem) and itemMatches &lt; 2 then
		local dup=0

		mud:send("t " .. matches[3] .. " Bid received for " .. biditem)

		NyyLIB.bids[xname] = biditem

		bids= table.size(NyyLIB.bids)
		bidders = table.size(NyyLIB.validbidders)

		mud:send("gsay " .. bids .. "/" .. bidders .. " bids received")

		RedrawGroupStatus()
 
   		if bids == bidders then
			NyyLIB.activebids = NyyLIB.bids
			disableTrigger("acceptbid")
      		expandAlias("@sortbids", false)
		end
	else
		if itemMatches &gt; 1 then
			mud:send("t " .. matches[3] .. " Which " .. biditem .. "? There's more then one.")
		else
			mud:send("t " .. matches[3] .. " failed bid on " .. biditem)
		end
	end
end

if matches[2] == "stop" then
	cecho("\n&lt;red&gt;[Disabled bid script.]\n")
	NyyLIB.bidding=0
  	NyyLIB.bids=nil
  	NyyLIB.activebids=nil
  	NyyLIB.groupitems=nil
  	NyyLIB.validbidders=nil
  	NyyLIB.trackbid=nil
  	NyyLIB.fullbidderlist=nil
  	NyyLIB.biditem=nil
  	NyyLIB.trackbid2=nil

	disableTrigger("acceptbid")

	RedrawGroupStatus()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@bid ([A-Za-z]+)? ?([A-Za-z-']+)? ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@sortbids</name>
					<script>local abstain=0
local abstainwho=""
local abort=0
local nx
local key, val

-- remove abstain
for key,val in pairs(NyyLIB.activebids) do
	if val == "abstain" then
		abstain=abstain+1
	
		abstainwho = abstainwho .. " " .. key

		table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, key))
		NyyLIB.activebids[key] = nil
		abort=1
	end
end

if abstainwho ~= "" then
	mud:send("gsay &lt;&lt;&lt; " .. abstain .. " abstain by " .. abstainwho .. " &gt;&gt;&gt;")
end

for key,val in pairs(NyyLIB.activebids) do	
	local compete=0
	local who = key
	local item = val

	for k,v in pairs(NyyLIB.bids) do
		if item == v and who ~= k then
			compete=1
		end
	end

	if compete == 0 then
		mud:send("gsay &lt;&lt;&lt; Sole Bidder: " .. key .. " - " .. val .. " &gt;&gt;&gt;")

		table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, key))
		NyyLIB.activebids[key] = nil

		abort=1
	end
end

if abort == 0 then
	expandAlias("@nextbid", false)
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@sortbids$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@nextbid</name>
					<script>local abort = 0
local nx


if isActive("acceptbid", "trigger") ~= 0 or isActive("acceptdice", "trigger") ~= 0 then
	display("acceptbid " .. isActive("acceptbid", "trigger"))
	display("acceptdice " .. isActive("acceptdice", "trigger"))

	echo("\nBidding is currently ongoing.\n")
	return
end

NyyLIB.trackbid= {}

for key,val in pairs(NyyLIB.activebids) do
	if abort == 0 then
		local compete=""
		local who = key
		NyyLIB.biditem= val

		compete = NyyLIB.biditem .. ": " .. who    

		NyyLIB.trackbid[who] = 0

		NyyLIB.activebids[who]=nil

		for k,v in pairs(NyyLIB.activebids) do
			if NyyLIB.biditem == v then
				compete= compete .. ", " .. k

				NyyLIB.trackbid[k] = 0
				NyyLIB.activebids[k]=nil
			end
		end

		enableTrigger("acceptdice")
		send("gsay &lt;&lt;&lt; Competition! " .. compete .. " &gt;&gt;&gt;")
		abort=1
	end
end

if abort == 0 then
	disableTrigger("acceptdice")
	send("gsay This round of bidding has now completed.")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@nextbid$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@adddice</name>
					<script>local xname, xdice

NyyLIB.trackbid2={}

xname=string.lower(matches[2]):title()
xdice=tonumber(matches[3])

if NyyLIB.trackbid == nil then
	echo("[Bidding is not currently open. Type 'bid help' for commands.]\n")
	return
end


if NyyLIB.trackbid[xname] == nil then
	echo("[ " .. xname .. " doesn't exist in valid dice rollers]\n")
	return
end

cecho("\n&lt;red&gt;[Setting " .. xname .. " to dice roll of " .. xdice .. ".]\n")

NyyLIB.trackbid[xname] = xdice

if table.contains(NyyLIB.trackbid, 0) == false then
	local winval=0
	local winkey=""
	local tie=0
	local temp= "Dice: |"
	
	for k,v in pairs(NyyLIB.trackbid) do
		temp = temp .. k .. "-" .. v .. "|"
		if v &gt; winval then
			winval = v
			winkey = k
		end
	end

	mud:send("gsay " .. temp .. " &gt;&gt;")

	temp = winkey
  
	-- display(NyyLIB.trackbid)

	for k,v in pairs(NyyLIB.trackbid) do
		if (v == winval) and k ~= winkey then
			tie = 1
			NyyLIB.trackbid2[k] = 0
			temp = temp .. ", " .. k
		end
	end

	if tie == 1 then
		mud:send("gsay &lt;&lt; Finish Him! " .. winval .. " by " .. temp)

		NyyLIB.trackbid2[winkey] = 0
		NyyLIB.trackbid = NyyLIB.trackbid2
	else
		mud:send("gsay &lt;&lt; Winner: " .. winkey .. " (" .. winval .. ") " .. NyyLIB.biditem .. " &gt;&gt;")
		disableTrigger("acceptdice")
	
		table.remove(NyyLIB.validbidders, table.index_of(NyyLIB.validbidders, winkey))
		NyyLIB.activebids[winkey] = nil
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@adddice ([A-Za-z]+) ([0-9]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>createhistory</name>
					<script>local mydb = db:create("bidhistory",
		{
		bids = {
			whatgroup = db:Timestamp("CURRENT_TIMESTAMP"),
         itemname = "",
         round = 0,
       	charname = "",
	     	diceroll = 0,
         	_index = { {"itemname"} }
		}
	} )</script>
					<command></command>
					<packageName></packageName>
					<regex>^createhistory$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Counters</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@stats</name>
					<script>-- c_block: Shield block
-- c_glances: Glances off shield - will also hit
-- c_svamp: Vamp from shield

-- c_deflect: Deflect from sword
-- c_pdeflect: Partially deflect from sword - will also hit		"defParryPartial"
-- c_parry: Parry attack (count as miss)

-- c_dodge: dodge attack (count as miss)
-- c_graze: partial dodge - will also hit

-- c_hit: hit
-- c_miss: miss

--NyyLIB.c_crit

-- 'all avoidance is checked before ac'


if matches[2] == "heals" then
	printHeals()
	return
end

if matches[2] == "reset" then
	resetStats()

	return
end

local cntRescueFail=getStat(whoami(), "failedrescue")
local cntRescueSuccess=getStat(whoami(), "successrescue")

local c_attackmiss=getStat(whoami(), "offMiss")
local c_attackhit=getStat(whoami(), "offHit")

local c_block=getStat(whoami(), "defShieldBlock")
local c_dodge=getStat(whoami(), "defDodge")
local c_graze=getStat(whoami(), "defGraze")
local c_deflect=getStat(whoami(), "defWeaponDeflect")
local c_glances=getStat(whoami(), "defShieldGlance")
local c_svamp=getStat(whoami(), "shieldvamp")
local c_parry=getStat(whoami(), "defParry")
local c_pdeflect=getStat(whoami(), "defParryPartial")
local c_crit=getStat(whoami(), "crithit")

local c_hit=getStat(whoami(), "defHit")
local c_miss=getStat(whoami(), "defMiss")


local c_all=c_hit+c_miss + c_parry + c_deflect + c_dodge + c_block


local c_adjhit=c_all-c_miss

local output = {}

local skillblocked = c_block + c_parry + c_deflect + c_dodge
local partialblock=  c_pdeflect + c_graze + c_glances


local v2allhit = c_hit + skillblocked
local v2weapon = c_parry + c_deflect + c_pdeflect

-- csv line

output[#output+1] = string.format("//%s,%s,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", 
											charData:get("statname"), whoami(), NyyLIB.str, NyyLIB.agibonus, NyyLIB.hitroll, NyyLIB.damroll,
												cntRescueFail, cntRescueSuccess, c_attackmiss, c_attackhit,
											c_block,c_dodge,c_graze,c_deflect,c_glances,c_svamp,c_parry,c_pdeflect, c_crit,c_hit,c_miss)

--output[#output+1] = string.format("[Based on AC alone, %2.1f%% (%d) hit, %2.1f%% (%d) missed]\n",
--							v2allhit*100/c_all, c_all,
--							c_miss*100/c_all, c_miss)
							
--output[#output+1] = string.format("[Of hits/potential hits (%d), %2.1f%% (%d) of them were dodged, %2.1f%% (%d) of them partially]\n",
--								v2allhit,
--								(c_dodge+c_graze)*100/v2allhit,
--								 c_dodge+c_graze,
--								c_graze*100/(c_dodge+c_graze),
--								c_graze )

--output[#output+1] = string.format("[Of available attacks (%d), %2.1f%% (%d) were shield blocked, %2.1f%% (%d) of them partially]\n",
--							 	v2allhit-c_dodge-c_graze,
--								(c_block+c_glances)*100/(v2allhit-c_dodge-c_graze), c_block+c_glances,
--								c_glances*100/(c_block+c_glances), c_glances)

--output[#output+1] = string.format("[Of the remaining %d attacks, %2.1f%% (%d) were riposted, %2.1f%% (%d) of them partially]\n",
--							 	v2allhit-c_dodge-c_graze-c_block-c_glances,
--								v2weapon*100/(v2allhit-c_dodge-c_graze-c_block-c_glances), v2weapon,
--								c_pdeflect*100/(v2weapon), c_pdeflect   )

--output[#output+1] = string.format("[%2.1f%% (%d) partially dodged, %2.1f%% (%d) glanced off shield, %2.1f%% (%d) partially deflected]\n",
--											c_graze*100/c_hit, c_graze,
--											c_glances*100/c_hit, c_glances,
--											c_pdeflect*100/c_hit, c_pdeflect)

--output[#output+1] = string.format("[%2.1f%% (%d) attacks went through all defenses]\n", 
--							(v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances) )

--output[#output+1] = string.format("[The final hit rate is %2.1f%% (%d)]\n",
--											c_hit*100/c_all,	c_hit )

output[#output+1] = string.format("[Defense: Hit %2.1f%% (%d/%d) : %2.1f%% (%d) direct, %2.1f%% (%d) dodge, %2.1f%% (%d) shield, %2.1f%% (%d) weapon]\n",
												c_hit*100/c_all, c_hit, c_all,
												(v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances),
												c_graze*100/c_hit, c_graze,
												c_glances*100/c_hit, c_glances,
												c_pdeflect*100/c_hit, c_pdeflect   )

output[#output+1] = string.format("[+HIT %d +DAM %d : Missed %2.1f%% (%d) Hit %2.1f%% (%d)]\n", 
								NyyLIB.hitroll, NyyLIB.damroll,
								c_attackmiss*100/(c_attackhit+c_attackmiss), c_attackmiss,
								c_attackhit*100/(c_attackhit+c_attackmiss), c_attackhit)


if cntRescueFail + cntRescueSuccess &gt; 0 then
	output[#output+1] = string.format("[%2.2f%% (%d) failed rescues, %2.2f%% (%d) success]\n", 
											cntRescueFail*100 / (cntRescueFail+cntRescueSuccess), cntRescueFail, 
											cntRescueSuccess*100 / (cntRescueFail+cntRescueSuccess), cntRescueSuccess)
end

local nx

if matches[2] == "write" then
	local file = io.open(homepath("stats.dat"), "a")

	io.output(file)

	io.write("\n")

	for nx=1, #output, 1 do
		io.write(output[nx])
	end

	io.close(file)

	return
end

if matches[2] == "read" then
	--local file = io.open(, "r")

	for line in io.lines(homepath("stats.dat")) do
		echo(line .. "\n")
	end


	--io.close(file)
	return
end

if matches[2] == "gcc" then
	for nx=1, #output, 1 do
		mud:send("gcc " .. output[nx])	
	end
	return
end

if matches[2] == "gsay" then
	for nx=1, #output, 1 do
		mud:send("gsay " .. output[nx])	
	end
	return
end

echo("\n")

printStats()

echo("\n")

--for nx=2, #output, 1 do
--	echo(output[nx])
--end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@stats ?(write|read|reset|gcc|gsay|heals)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@gstats</name>
					<script>printStats()</script>
					<command></command>
					<packageName></packageName>
					<regex>^@gstats$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>TorilMapper</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@map</name>
					<script>if matches[2] == nil then
	-- toggle map on/off

	if charData:get("map") == "on" then
		expandAlias("@map off", false)
		cecho("&lt;red&gt;[NyyMap display is OFF.]\n")
	else
		expandAlias("@map on", false)
		cecho("&lt;red&gt;[NyyMap display is ON.]\n")
	end
end

if matches[2] == "score" then
	local list = getAreaTable()
	local fullmap = getRooms()

	local totalmap=0
	local totalfound=0

	local totalarea=0
	local areasfound=0

	local maprooms = {}

	for roomid, roomname in pairs(fullmap) do
		local internalid = getRoomArea(roomid)

		local zone=getRoomUserData(roomid, "zoneid")
		local zoneid=tonumber(zone)

		if zoneid ~= nil then
			-- first appearance of room in area
			if maprooms[NyyLIB.areaTable[zoneid]] == nil then
				maprooms[NyyLIB.areaTable[zoneid]] = {0,0}
			end

			if internalid == -1 then
				-- undiscovered room
				maprooms[NyyLIB.areaTable[zoneid]][2] = maprooms[NyyLIB.areaTable[zoneid]][2] + 1
			else
				-- discovered room
				maprooms[NyyLIB.areaTable[zoneid]][1] = maprooms[NyyLIB.areaTable[zoneid]][1] + 1
			end
		else
			-- echo("nil room " .. roomid .. "\n")
		end
	end

	for k,v in pairs(maprooms) do
		if v[1] ~= 0 then
			echo ( string.format("%45s %4d/%4d  rooms, ( %5.2f%% )\n", k, v[1], v[1]+v[2], v[1]*100/(v[1]+v[2])) )

			totalfound=totalfound+v[1]
			areasfound=areasfound+1
		end
		totalmap=totalmap+v[1]+v[2]
	end

	echo( string.format("\n             found %3d/%-3d included areas      %d/%d rooms  ( %5.2f%% )\n\n", 
		areasfound, table.size(maprooms), totalfound, totalmap, totalfound*100/totalmap) )
end

if matches[2] == "help" then
	cecho("&lt;red&gt;Usage: @map on           - turn on the mapper display\n")
	cecho("&lt;red&gt;       @map off          - turn off the mapper display\n")
	cecho("&lt;red&gt;       @map update       - update the map after a new NyyLIB is installed\n")
	cecho("&lt;red&gt;       @map score        - list size/name of found areas in the map\n")
	cecho("&lt;red&gt;       @map info         - list size/name of all areas in the map\n")
	cecho("&lt;red&gt;       @find             - attempt to locate the currently occupied room on the map\n")
	cecho("&lt;red&gt;       @find roomname    - list of previously located rooms\n")
	cecho("&lt;red&gt;       @fwalk roomnum    - fastwalk from the current room to roomnum\n")
end

if matches[2] == "info" then
	local list = getAreaTable()
	local fullmap = getRooms()

	local totalmap=0
	local totalfound=0

	local totalarea=0
	local areasfound=0

	local maprooms = {}

	for roomid, roomname in pairs(fullmap) do
		local internalid = getRoomArea(roomid)
		local zone=getRoomUserData(roomid, "zoneid")
		local zoneid=tonumber(zone)


		if zoneid ~= nil then
			-- first appearance of room in area
			if maprooms[NyyLIB.areaTable[zoneid]] == nil then
				maprooms[NyyLIB.areaTable[zoneid]] = {0,0}
			end

			if internalid == -1 then
				-- undiscovered room
				maprooms[NyyLIB.areaTable[zoneid]][2] = maprooms[NyyLIB.areaTable[zoneid]][2] + 1
			else
				-- discovered room
				maprooms[NyyLIB.areaTable[zoneid]][1] = maprooms[NyyLIB.areaTable[zoneid]][1] + 1
			end
		else
			-- echo("nil room " .. roomid .. "\n")
		end
	end

	for k,v in pairs(maprooms) do
		echo ( string.format("%45s %4d/%4d  rooms, ( %5.2f%% )\n", k, v[1], v[1]+v[2], v[1]*100/(v[1]+v[2])) )

		totalfound=totalfound+v[1]
		areasfound=areasfound+1

		totalmap=totalmap+v[1]+v[2]
	end

	echo( string.format("\n             found %3d/%-3d included areas      %d/%d rooms  ( %5.2f%% )\n\n", 
		areasfound, table.size(maprooms), totalfound, totalmap, totalfound*100/totalmap) )
end

if matches[2] == "update" then
	cecho("&lt;green&gt;[Running the map update will take 5-10 minutes.]\n")
	cecho("&lt;green&gt;[Mudlet will appear to be frozen while running. Don't close it.]\n")
	cecho("\n&lt;red&gt;[Use the '&lt;green&gt;@backup&lt;red&gt;' command to make a backup of data files before updating!]\n\n")
	cecho("&lt;green&gt;[Type '&lt;red&gt;@map updateok&lt;green&gt;' to start update]\n")
end

if matches[2] == "updateok" then
	local fullmap = getRooms()
	local nx

	local mapdata={}

	-- check existing toril.map file
	for roomid, roomname in pairs(fullmap) do
		local internalid = getRoomArea(roomid)

		if internalid ~= -1 and internalid ~= nil then
			mapdata[#mapdata+1]=roomid
		end
	end

	loadMap(mainpath("toril.map"))

	for nx=1,#mapdata,1 do
		if mapdata[nx] ~= 1 then
			unhideRoom(mapdata[nx])
		end
	end

	expandAlias("@map save", false)

	cecho("&lt;red&gt;[Done]\n")
end

if matches[2] == "reset" then
	loadMap(mainpath("toril.map"))

	expandAlias("@find", false)

	cecho("&lt;red&gt;[Default map loaded]\n")
end

if matches[2] == "on" then
	charData:set("map", "on")

	if map:getRoom() == nil then
		tempTimer(3, [[expandAlias("@find", false)]])
	end
	map:show()

	resizeGroupWindow(true)
elseif matches[2] == "off" then
	charData:set("map", "off")

	map:hide()

	resizeGroupWindow(true)
elseif matches[2] == "save" then
	local mapname = homepath("toril.map")
	local savedok = saveMap(mapname)

	if not savedok then
  		cecho("\n&lt;red&gt;[Failed map save: " .. mapname .. "]\n")
	else
  		cecho("\n&lt;red&gt;[Saved map: " .. mapname .. "]\n")
	end

elseif matches[2] == "init" then
	-- mapfile is also loaded from mudlet saved data by the creation command

	cecho("&lt;red&gt;[Creating mapper window and loading mudlet saved data]\n")

	mudlet = mudlet or {}; mudlet.mapper_script = true

	NyyLIB.mapwindow = Geyser.Mapper:new({name="mapper",x="33%",y=0,width="33%",height="50%"})
	NyyLIB.mapwindow:hide()

	if setDefaultAreaVisible ~= nil then
		setDefaultAreaVisible(false)
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@map ?(help|score|info|on|off|reset|update|updateok|save|init|empty)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@find</name>
					<script>forceFind=nil

-- empty movement queue

map:clearQueue()

-- pattern provided, locate rooms in map
if matches[2] ~= nil and matches[2] ~= "" then
	local fullmap = getRooms()

	cecho("\n&lt;red&gt;[Matching rooms in the known world]\n")

	if tonumber(matches[2]) then
		local roomid=tonumber(matches[2])
		local roomname=getRoomName(roomid)

		if getRoomArea(roomid) ~= -1 then
			local pathlength=0

			if roomLocked(roomid) == false then
				if map:getRoom() ~= nil then
					if getPath( map:getRoom(), roomid) then
						pathlength=#speedWalkPath
					end
				end
			end

			cecho(string.format("&lt;green&gt;%30s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
		end

		return
	end

	for roomid, roomname in pairs(fullmap) do
		if matches[2] == "*" then
			if getRoomArea(roomid) ~= -1 and roomid ~= 1 then
				echo(string.format("%30s Room ID: %6d  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, roomname))
			end
		else
			if string.findPattern(roomname:lower(), matches[2]:lower()) then
				if getRoomArea(roomid) ~= -1 then
					local pathlength=0

					if roomLocked(roomid) == false then
						if map:getRoom() ~= nil then
							if getPath( map:getRoom(), roomid) then
								pathlength=#speedWalkPath
							end
						end
					end

					cecho(string.format("&lt;green&gt;%30s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
				end
			end
		end
	end

	return
end

-------

-- no pattern provided, locate current room
local current=map:getRoom()

cecho("\n&lt;red&gt;[Searching... ")

-- use scanned info if present

if table.size(scanned) &gt; 0 then
	local scanroom = solveScan()
	
	if scanroom ~= nil then
		map:setRoom( scanroom )
	end
else
	if map:getRoomname() ~= nil and map:getExits() ~= nil then
		map:setRoom( map:findRoomID( map:getRoomname(), map:getExits() ) )
	end
end

if map:getRoom() ~= nil then
	--if 	charData:get("map") == "off" then
	--	cecho("&lt;red&gt;Mapper is currently off. Type '@map on' to enable it.\n")
	--end

	unhideRoom( map:getRoom() )
	map:update(nil)
else
	NyyLIB.lastRoomID = nil
	centerview(1) -- blank room number
end
</script>
					<command></command>
					<packageName></packageName>
					<regex>^@find ?(.*)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@afind - find room in current area</name>
					<script>local fullmap = getRooms()

cecho("\n&lt;red&gt;[Matching discovered rooms in current area]\n")

if matches[2] ~= nil and matches[2] ~= "" then
	local fullmap = getRooms()

	local zoneid
	local internalid

	if map:getRoom() ~= nil then
		zoneid=tonumber(getRoomUserData( map:getRoom(), "zoneid") )
		internalid= map:findAreaID(NyyLIB.areaTable[zoneid])
	end

	if internalid == nil then
		return
	end

	for roomid, roomname in pairs(fullmap) do
		if getRoomArea(roomid) == internalid then
			if string.findPattern(roomname:lower(), matches[2]:lower()) then

				local pathlength=0

				if roomLocked(roomid) == false then
					if map:getRoom() ~= nil then
						if getPath( map:getRoom(), roomid) then
							pathlength=#speedWalkPath
						end
					end
				end

				cecho(string.format("&lt;green&gt;%30s Room ID: %6d [%3d]  %s\n", getRoomAreaName(getRoomArea(roomid)), roomid, pathlength, roomname))
			end
		end
	end

	return
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@afind ?(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>setroom</name>
					<script>if map:getRoom() ~= nil then
	if getRoomArea(map:getRoom()) ~= -1 then
		echo("[Room set]\n")
		map:setRoom(matches[2])
		centerview(map:getRoom())
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^setroom ([0-9]+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>emptyroom</name>
					<script>local fullmap = getRooms()

for roomid, roomname in pairs(fullmap) do
	if string.findPattern(roomname:lower(), "unmapped") then
		echo("Empty room already exists: " .. roomid .. "\n")
		setRoomArea(1, map:findAreaID("The Great Unknown"))
		return
	end
end

map:addArea(6)

local newroomid = createRoomID()

addRoom(newroomid)

echo("\nCreated room number: " .. newroomid .. "\n")

setRoomArea(newroomid, map:findAreaID("The Great Unknown"))

setRoomName(newroomid, "Unmapped")


echo("Centering map.\n")
centerview(newroomid)</script>
					<command></command>
					<packageName></packageName>
					<regex>^emptyroom$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>enter</name>
					<script>map:processMovement("ENTER " .. matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(en|ent|ente|enter) (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>recall</name>
					<script>tempTimer(1.5, [[expandAlias("@find", false)]])
mud:send("RECALL", false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^recall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>movement commands</name>
					<script>if pagingmode then
	mud:send("")
	return
end

-- currently moving
spell:setMoving(true)

-- erase spellqueue if any spells present
spell:eraseQueue()


-- erase scanned table
scanned={}

local dir=matches[2]:sub(1,1):lower()

map:processMovement(dir)

toGagLook=nil
gaglook=nil</script>
					<command></command>
					<packageName></packageName>
					<regex>^(n|no|nor|nort|north|s|so|sou|sout|south|e|ea|eas|east|w|we|wes|west|u|up|d|do|dow|down)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>doorbash</name>
					<script>local dir=matches[3]:sub(1,1):lower()

NyyLIB.doorbash = dir

mud:send("DOORBASH " .. dir, false)</script>
					<command></command>
					<packageName></packageName>
					<regex>^(doo|door|doorb|doorba|doorbas|doorbash) ([nsewud])$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>drag</name>
					<script>-- drag corpse in direction

-- set as currently moving
spell:setMoving(true)

if checkMask("caster") then
	-- erase spellqueue if any spells present
	spell:eraseQueue()

	-- disable autocast
	buttons:change("autocast", false, "SpellsButton")
end

-- erase scanned table
scanned={}

local dir=matches[3]:sub(1,1):lower()

echoDebug("Drag: " .. matches[1] .. "\n")

toGagLook=nil
gaglook=nil

map:processMovement("DRAG " .. matches[2] .. " " .. matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^drag (.*) ([ewnsud].*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@zone</name>
					<script>--This alias will list all zones matching a pattern

for id, name in pairs(NyyLIB.areaTable) do
	if string.findPattern(name:lower(), matches[2]:lower()) then
		cecho("&lt;red&gt;(" .. id .. ") " .. name .. "\n")
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@zone (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>movealone</name>
					<script>-- currently moving
spell:setMoving(true)

-- erase spellqueue if any spells present
spell:eraseQueue()


-- erase scanned table
scanned={}

local dir=matches[2]:sub(1,1):lower()

toGagLook=nil
gaglook=nil

map:processMovement("MOVEA " .. dir)</script>
					<command></command>
					<packageName></packageName>
					<regex>^movea (n|e|s|w|u|d)</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>SQL Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@clist</name>
					<script>local nx
local matchchar = matches[2]:title()
local charlist

local tmpchar

if matchchar == nil then
	echo("[clist charname]\n")
	return
end

matchchar = string.lower(matches[2]):title()

cecho("&lt;red&gt;[Matching characters for " .. matchchar .. " as at Katumi: " .. NyyLIB.dbversion .. "]\n\n")

if getProfile(matchchar) ~= nil then
	matchchar=getProfile(matchchar)
end

charlist = sqlclist(matchchar)

for k,v in pairs(charlist) do
	cecho(string.format("&lt;green&gt;[%2d %15s] %20s %-15s (@%s)\n", v[1], v[2], v[3], 
				string.format("(%s)", v[4]), v[5]))
end

cecho("\n&lt;red&gt;[Matching characters from local database]\n\n")

whoclist(matchchar)

mud:send("\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@clist ?([A-Za-z]+)?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@gall</name>
					<script>-- create gags for all of a persons characters
local matchchar=matches[2]

if matchchar ~= nil then
	echo("[Gagging all characters for " .. matchchar:title() .. "]\n")

	matchchar = sqlclist(matchchar)

	for k,v in pairs(matchchar) do
		expandAlias("@gag " .. v[3], false)
	end
else
	echo("usage: @gall charactername - creates a gag for all associated characters\n")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@gall ?([A-za-z]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@id</name>
					<script>local data

cecho("&lt;red&gt;[Attempting to identify " .. matches[2] .. "]\n")

data = sqliditem(matches[2])

for k,v in pairs(data) do
	cecho("\n&lt;green&gt;" .. v .. "\n")
end

cecho ("&lt;red&gt;[" .. #data .. " matches in database]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@id (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@statitems ?(gsay)?$</name>
					<script>local stats

local togsay = matches[2]

if NyyLIB.groupitems == nil then
	cecho("&lt;red&gt;[groupitems is nil]\n")
	return
end

for k,v in pairs(NyyLIB.groupitems) do
	stats = sqliditem(v)

	-- need to distinguish between multiple return values

	if #stats &gt; 1 then
		for nx=1,#stats,1 do
			if string.find(stats[nx], v .. " 1") then
				stats[1] = stats[nx]
			end		
		end
		echo("[multiple return values]\n")
	end

	if togsay == "gsay" then
		if stats[1] ~= nil then
			mud:send("gsay * " .. stats[1])
		else
			mud:send("gsay * " .. v .. " : not found in database. identify and mmail to katumi")
		end
	else
		if stats[1] ~= nil then
			echo(stats[1] .. "\n")
		else
			echo(v .. " : not found in database. identify and mmail to katumi\n")
		end
	end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@statitems ?(gsay)?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>BOTS</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>@stoptrain</name>
					<script>if trainMode == "tank" then
	cecho("&lt;red&gt;[Stopping: Train engine triggers]\n")
	NyyLIB.smtrainposition=nil
	disableTrigger("trainstation")
	expandAlias("@set statname unset", false)

	if checkMask("fighter") then
		buttons:change("rescuetype", "basic", "rescue")
	end

	if checkMask("ran") then
		buttons:change("rescuetype", "off", "rescue")
	end
else
	cecho("&lt;red&gt;[Stopping: Train car triggers]\n")
	disableTrigger("SMTrainCaster")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@stoptrain$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@starttrain</name>
					<script>trainMode=matches[2]

if matches[2] == nil then
	cecho("&lt;red&gt;                   The Adud XP Train\n")
	cecho("&lt;green&gt;@starttrain tank          - start running train as tank\n")
	cecho("&lt;green&gt;@starttrain tank moblist  - run train as tank using an alternate created mob list\n")
	cecho("&lt;green&gt;@starttrain fol           - start running train as a follower\n")       
	return
end

trainList = matches[3]

configureTrain()

if trainMode == "tank" then
	trainEngine()

	cecho("&lt;green&gt;[Sending starting movement]\n")
	NextTrainStop()
else
	trainCar()
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^@starttrain ?(tank|fol)? ?([A-Za-z0-9]+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@inittrain</name>
					<script>if map:getRoom() == nil then
	cecho("&lt;red&gt;[Map is not currently in sync]\n")
	return
end

if map:getCurrentZone() == "Ashstone" then
	cecho("&lt;red&gt;[Unlock path in Ashstone. This starts at Stephan]\n")
	expandAlias("@fwalk 87411", true)
	expandAlias(".w4ns4wseduwn3e2n5w2sw2sw2se4nene3se2wese2wese2wesew2s2en4e4ws2w9n4e5s2e", true)
else
	cecho("&lt;red&gt;[Unlock path in Silverymoon]\n")
	expandAlias("@fwalk 48603", true)
	expandAlias(".neswen12e2n2sw2new2nsen2snesn3w2new2s13w3s3w5neudw2s3wnew4s9e2s2w2e5sesn5esudn11w3nud3s5e7nws", true)
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^@inittrain$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@genseal</name>
					<script>mud:send("get dust " .. charData:get("container") )
mud:send("give dust lavis")
mud:send("put scroll " .. charData:get("container") )</script>
					<command></command>
					<packageName></packageName>
					<regex>^@genseal$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>@resettrain</name>
					<script>-- turn it off in full

NyyLIB.nextroomstop=nil
NyyLIB.castertrain=nil
NyyLIB.smtrainposition=nil

disableTrigger("trainstation")
expandAlias("@set statname unset", false)

disableTrigger("SMTrainCaster")
disableTrigger("SMTrain")

if checkMask("fighter") and not checkMask("ran") then
	buttons:change("rescuetype", "basic", "rescue")
end

if checkMask("ran") then
	buttons:change("rescuetype", "off", "rescue")
end

if checkMask("war") then
	buttons:change("warbh", false, "bash")
	buttons:change("warkc", false, "kick")
end

if checkMask("dir") then
	buttons:change("dirbh", false, "bash")
end

cecho("&lt;red&gt;[All train triggers disabled]\n")</script>
					<command></command>
					<packageName></packageName>
					<regex>^@resettrain$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Utilities</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>CapturePowers</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>genalias</name>
						<script>sortpowerslist={}

for nx=#powerslist,1,-1 do
	mud:send("powers info " .. powerslist[nx][1])
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^genalias$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>showalias</name>
						<script>-- sortpowerslist[#sortpowerslist+1] = {to_snake(powername), matches[2]:trim(), level, "", ""}


for nx=1,#sortpowerslist,1 do
	echo("{ " .. [["]] .. sortpowerslist[nx][1] .. [[", "]] .. sortpowerslist[nx][2] .. [[", ]] .. sortpowerslist[nx][3] .. [[, "", ""},]] .. "\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^showalias$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>classpowers</name>
						<script>powerslist = {}

mud:send("powers list")

tempTimer(5, "genalias")</script>
						<command></command>
						<packageName></packageName>
						<regex>^classpowers$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>ZoneImport</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>readobj</name>
						<script></script>
						<command></command>
						<packageName></packageName>
						<regex>^readobj$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>cMud Map Importer</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>Create map from cmud</name>
						<script>local ok, msg = cmi:importAll()
if ok then
  echo("&lt;green&gt;cMud map successfully imported.  Use 'centerview #' in a script to orient yourself, where # is a room id\n")
else
  echo("&lt;firebrick&gt;Didn't import; "..msg..".\n")
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud importmap$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>purgemap</name>
						<script>--this method is meant for a clean import from cmud
local maxid = table.maxn(getRooms())
local i

for i = 1, maxid  do
	if roomExists(i) then
		deleteRoom(i)
	end
end

--delete labels for all areas
local areatable = getAreaTable()
for i,v in pairs(areatable) do
	local labels = getMapLabels(v)
	if type(labels) == 'table' then
		for j,k in pairs(labels) do
			deleteMapLabel(v,j)
		end
	end
	deleteArea(v)
end
cecho("&lt;red&gt;[Wiped all data from loaded map]\n")</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud purgemap$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Clear sqlite connection</name>
						<script>cmi:getConnection()</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud resetConnection$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Import rooms</name>
						<script>cmi:checkConnection()
cmi:addRooms(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud addRooms$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Color rooms</name>
						<script>cmi:checkConnection()
cmi:colorRooms(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud colorRooms$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Import Favorites</name>
						<script>cmi:checkConnection()
cmi:addFavorites(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud addFavs$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>Label Zones</name>
						<script>cmi:checkConnection()
cmi:labelCmudZones(cmi.con)</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud labelZones$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>List areas</name>
						<script>cmi:listAreas()</script>
						<command></command>
						<packageName></packageName>
						<regex>^cmud listareas$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>import</name>
						<script>local passwords = {
[2371] = "ugracht",
[5678] = "auril",
[14334] = "jasmine",
[16418] = "netheril",
[71573] = "silverwing",
[77932] = "kostchtchie",
[79128] = "glukknukkle",
[41212] = "tug plank",
[47888] = "laduguer",
[48565] = "hanali",
[48806] = "moradin",
[14237] = "hi",
[11687] = "paradox",
[17103] = "wind",
[70373] = "kossuth",
[74115] = "annam",
[74325] = "Athzaganaroul",
[75603] = "sunbat",
[78269] = "jess",
[78562] = "trahern",
[78577] = "vrazgal",
[79003] = "yylirmog",
[84994] = "blood",
[87034] = "bloodstone",
[92742] = "death",
[92882] = "ancients",
[94218] = "dugmaren",
[94219] = "clangeddin",
[94220] = "moradin",
[94221] = "berronar",
[94222] = "marthammor",
[95059] = "kartagan"
}

--GN hall- say 'uthgar'
--door to chief in SS- say 'ugracht'
--fire giant village- say 'annam'
--secret room in Ghore- say 'paradise'
-- citadel
--say 'shalafi'
--say 'black'
--say 'wind'
--Room on MS- say 'enigma'
--Yath Oloth- say 'athzaganaroul'
--bronze door in Demi- say 'nevarlith'
--Waterdeep graveyard- say 'Torm'
--Skerttd-Gul king- say 'Kartagan'
--Skerttd-Gul tower- say 'wine' 'sand' and 'wind' for the next room. 
--Leuthilspar gates- say 'peace'
--Kobold village- tug plank
--mines near GH- say 'glukknukkle'
--Swift Steel Merc company- say 'ssc'
--Demi tower- say 'nevarlith'
--MH mines to beholder area- say 'orlean' (sw from the dwarf corpse)
--Bloodtusk gates- say 'death', 'blood or 'war'
--CP, door to Sheik Akalon- say 'lore'
--Blood Bayou blood pool- says 'yylirmog'
--Kobold mines- say i&gt;|uub
--Longhollow- say 'selune'


echo("[Starting map import]\n")

loadMap("__")

-- read file, import from listed zones
local line

for line in io.lines(mainpath("importlist.txt")) do
--	"{127,277}, --   The Nine Hells - Avernus - Bronze Citadel "
-- {mud , cmud}

	local mudid= string.match(line, "{([0-9]+),")
	local cmudid=string.match(line, "[0-9]+,([0-9 ]+)}")
	local zonename=string.match(line, "-- (.*)")

	if mudid ~= nil then
		if tonumber(cmudid) ~= nil then
			echo ( string.format("%3d %3d &gt;&gt; %s\n\n", tonumber(mudid), tonumber(cmudid), zonename ) )

			cmi:importArea(cmudid, mudid)
		end
	end
end

echo("[Adding exits]\n")
cmi:addExits(cmi.con)

echo("[Colouring rooms]\n")
cmi:colorAreas()

echo("[Labeling zone edges]\n")
cmi:labelCmudZones(cmi.con)

-- set weight on specific exits to exclude from path finding

setExitWeight(48767, "down", 500) -- down entrance to underdark from silverymoon

echo("[Adding room password information]\n")

for k,v in pairs(passwords) do
	if roomExists(k) then
		echo("Room: " .. k .. " PW: " .. v .. "\n")
		setRoomUserData(k, "password", v)
	else
		echo("Room: " .. k .. " does not exist in map\n")
	end
end

expandAlias("emptyroom")

echo("[End import]\n")</script>
						<command></command>
						<packageName></packageName>
						<regex>^import$</regex>
					</Alias>
				</AliasGroup>
				<AliasGroup isActive="yes" isFolder="yes">
					<name>spell powers v2</name>
					<script></script>
					<command></command>
					<packageName></packageName>
					<regex></regex>
					<Alias isActive="yes" isFolder="no">
						<name>generate spell text</name>
						<script>-- elemental_ward={"Elemental|Ward"},

for nx=1, #capSpellList, 1 do
	local spell= capSpellList[nx]
	local formattedSpell=spell
	
	local _, count = string.gsub(spell, " ", "|")

	if count &lt; 2 then
		formattedSpell=string.gsub(spell, " ", "|")
	end
	
	echo( to_snake(spell) .. [[= {"]] .. formattedSpell .. [["},]] .. "\n" )
end</script>
						<command></command>
						<packageName></packageName>
						<regex>^gentext$</regex>
					</Alias>
					<Alias isActive="yes" isFolder="no">
						<name>reset text</name>
						<script>capSpellList=nil</script>
						<command></command>
						<packageName></packageName>
						<regex>^resettext$</regex>
					</Alias>
				</AliasGroup>
			</AliasGroup>
			<Alias isActive="yes" isFolder="no">
				<name>spamcmd</name>
				<script>send("ack " .. matches[2])
send("afk " .. matches[2])
send("agree " .. matches[2])
send("amaze " .. matches[2])
send("apologize " .. matches[2])
send("applaud " .. matches[2])
send("arch " .. matches[2])
send("ayt " .. matches[2])
send("bang " .. matches[2])
send("bark " .. matches[2])
send("bathe " .. matches[2])
send("bbl " .. matches[2])
send("beer " .. matches[2])
send("beg " .. matches[2])
send("bird " .. matches[2])
send("bite " .. matches[2])
send("bleed " .. matches[2])
send("blink " .. matches[2])
send("blow " .. matches[2])
send("blush " .. matches[2])
send("boggle " .. matches[2])
send("bonk " .. matches[2])
send("bored " .. matches[2])
send("bounce " .. matches[2])
send("bow " .. matches[2])
send("brb " .. matches[2])
send("burp " .. matches[2])
send("bye " .. matches[2])
send("cackle " .. matches[2])
send("calm " .. matches[2])
send("caress " .. matches[2])
send("censor " .. matches[2])
send("cheek " .. matches[2])
send("cheer " .. matches[2])
send("choke " .. matches[2])
send("chuckle " .. matches[2])
send("clap " .. matches[2])
send("comb " .. matches[2])
send("comfort " .. matches[2])
send("congratulate " .. matches[2])
send("cough " .. matches[2])
send("cringe " .. matches[2])
send("cry " .. matches[2])
send("cuddle " .. matches[2])
send("curious " .. matches[2])
send("curse " .. matches[2])
send("curtsey " .. matches[2])
send("dance " .. matches[2])
send("doh " .. matches[2])
send("dream " .. matches[2])
send("drool " .. matches[2])
send("dropkick " .. matches[2])
send("duck " .. matches[2])
send("embrace " .. matches[2])
send("envy " .. matches[2])
send("eyebrow " .. matches[2])
send("fart " .. matches[2])
send("fidget " .. matches[2])
send("flame " .. matches[2])
send("flash " .. matches[2])
send("flex " .. matches[2])
send("flip " .. matches[2])
send("flirt " .. matches[2])
send("flutter " .. matches[2])
send("fondle " .. matches[2])
send("fool " .. matches[2])
send("french " .. matches[2])
send("frown " .. matches[2])
send("full " .. matches[2])
send("fume " .. matches[2])
send("fuzzy " .. matches[2])
send("gag " .. matches[2])
send("gape " .. matches[2])
send("gasp " .. matches[2])
send("giggle " .. matches[2])
send("glare " .. matches[2])
send("grin " .. matches[2])
send("groan " .. matches[2])
send("grope " .. matches[2])
send("grovel " .. matches[2])
send("growl " .. matches[2])
send("grumble " .. matches[2])
send("grunt " .. matches[2])
send("hand " .. matches[2])
send("happy " .. matches[2])
send("hero " .. matches[2])
send("hiccup " .. matches[2])
send("hiss " .. matches[2])
send("hi5 " .. matches[2])
send("holdon " .. matches[2])
send("hop " .. matches[2])
send("hug " .. matches[2])
send("hum " .. matches[2])
send("hunger " .. matches[2])
send("imitate " .. matches[2])
send("impale " .. matches[2])
send("insult " .. matches[2])
send("introduce " .. matches[2])
send("jam " .. matches[2])
send("jk " .. matches[2])
send("jump " .. matches[2])
send("kiss " .. matches[2])
send("kneel " .. matches[2])
send("stand")
send("laugh " .. matches[2])
send("lag " .. matches[2])
send("lean " .. matches[2])
send("lick " .. matches[2])
send("love " .. matches[2])
send("lost " .. matches[2])
send("lucky " .. matches[2])
send("massage " .. matches[2])
send("melt " .. matches[2])
send("moan " .. matches[2])
send("moon " .. matches[2])
send("mosh " .. matches[2])
send("mourn " .. matches[2])
send("mutter " .. matches[2])
send("nap " .. matches[2])
send("nibble " .. matches[2])
send("nod " .. matches[2])
send("nog " .. matches[2])
send("noogie " .. matches[2])
send("nose " .. matches[2])
send("nudge " .. matches[2])
send("nuzzle " .. matches[2])
send("ogle " .. matches[2])
send("panic " .. matches[2])
send("pant " .. matches[2])
send("pat " .. matches[2])
send("peer " .. matches[2])
send("pet " .. matches[2])
send("pillow " .. matches[2])
send("pinch " .. matches[2])
send("plonk " .. matches[2])
send("point " .. matches[2])
send("poke " .. matches[2])
send("ponder " .. matches[2])
send("pose " .. matches[2])
send("pounce " .. matches[2])
send("pout " .. matches[2])
send("protect " .. matches[2])
send("pucker " .. matches[2])
send("puke " .. matches[2])
send("pull " .. matches[2])
send("punch " .. matches[2])
send("purr " .. matches[2])
send("push " .. matches[2])
send("puzzle " .. matches[2])
send("raise " .. matches[2])
send("ready " .. matches[2])
send("roar " .. matches[2])
send("rofl " .. matches[2])
send("roll " .. matches[2])
send("rose " .. matches[2])
send("rub " .. matches[2])
send("ruffle " .. matches[2])
send("salute " .. matches[2])
send("scare " .. matches[2])
send("scold " .. matches[2])
send("scratch " .. matches[2])
send("scream " .. matches[2])
send("seduce " .. matches[2])
send("shake " .. matches[2])
send("shiver " .. matches[2])
send("shove " .. matches[2])
send("shrug " .. matches[2])
send("shudder " .. matches[2])
send("shush " .. matches[2])
send("sigh " .. matches[2])
send("sing " .. matches[2])
send("skip " .. matches[2])
send("slap " .. matches[2])
send("slobber " .. matches[2])
send("smell " .. matches[2])
send("smile " .. matches[2])
send("smirk " .. matches[2])
send("smoke " .. matches[2])
send("snap " .. matches[2])
send("snarl " .. matches[2])
send("sneer " .. matches[2])
send("sneeze " .. matches[2])
send("snicker " .. matches[2])
send("sniff " .. matches[2])
send("snoogie " .. matches[2])
send("snore " .. matches[2])
send("snort " .. matches[2])
send("snuggle " .. matches[2])
send("spam " .. matches[2])
send("spank " .. matches[2])
send("spin " .. matches[2])
send("spit " .. matches[2])
send("squeeze " .. matches[2])
send("squirm " .. matches[2])
send("stare " .. matches[2])
send("steam " .. matches[2])
send("stomp " .. matches[2])
send("strangle " .. matches[2])
send("stretch " .. matches[2])
send("strut " .. matches[2])
send("sulk " .. matches[2])
send("swat " .. matches[2])
send("sweat " .. matches[2])
send("sweep " .. matches[2])
send("tackle " .. matches[2])
send("tango " .. matches[2])
send("tap " .. matches[2])
send("tarzan " .. matches[2])
send("taunt " .. matches[2])
send("tease " .. matches[2])
send("thank " .. matches[2])
send("think " .. matches[2])
send("thirst " .. matches[2])
send("throw " .. matches[2])
send("tickle " .. matches[2])
send("tip " .. matches[2])
send("tiptoe " .. matches[2])
send("tongue " .. matches[2])
send("toss " .. matches[2])
send("touch " .. matches[2])
send("trip " .. matches[2])
send("tug " .. matches[2])
send("tweak " .. matches[2])
send("twibble " .. matches[2])
send("twiddle " .. matches[2])
send("twirl " .. matches[2])
send("undress " .. matches[2])
send("veto " .. matches[2])
send("wait " .. matches[2])
send("wave " .. matches[2])
send("welcome " .. matches[2])
send("wet " .. matches[2])
send("whap " .. matches[2])
send("whatever " .. matches[2])
send("wheeze " .. matches[2])
send("whimper " .. matches[2])
send("whine " .. matches[2])
send("whistle " .. matches[2])
send("wiggle " .. matches[2])
send("wince " .. matches[2])
send("wink " .. matches[2])
send("woops " .. matches[2])
send("worship " .. matches[2])
send("yawn " .. matches[2])
send("yodel " .. matches[2])
send("zone " .. matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^spamcmd (.*)</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>NyyLIB</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>changelog</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- 011dev

-- Katumi database update - 9/2/18
-- Map updated: full size 317 areas 45566 rooms
-- @minimap - displays minimap window (and also gags from main display)
-- Command structure change: @map, @map help
-- Fixed roller
-- train fixes
-- bugfixes


-- 011rc2

-- Katumi database update - 4/15/18
-- Map updated: full size 317 areas 45465 rooms
-- bugfixes
-- guard, vigiliant protector use the wuss
-- xp train will disable itself on petition
-- added warrior
-- @set border now accepts colorname, hex value
-- autoroller: status display reformatted, added anti timeout
-- @fol mobname - follows an unfollowable mob
-- @set font - font to use for buttons
-- @set colbuttonoff - use to set the button text colour when off
-- @set colbuttonon  - use to set the button text colour when on
-- @set condensed echosend - enabled displays everything sent to mud (for debug purposes)
-- @set maperror false - disable map room error suppression
-- @cd changes fleemode to 'lich'
-- autoassist is disabled by default after joining a group
-- buttons are now generated realtime from a table
-- url's in the chat window are now clickable
-- name in chat window now shows timestamp on mouseover
-- captures to the chat windows have been reformatted to remove redundant information
-- Added pause to train on low hp/movement, thanks @Afu for idea
-- Ranger, Paladin, and Blackguard refactored
-- added blackguard
-- spellcasting added to paladin
-- direction added to @cd
-- An error message will be displayed if mapper has likely gone out of sync
-- A helpfile entry was submitted! Thanks @Areh

-- 011rc1

-- Katumi database update - 12/23/17
-- Map updated: full size 317 areas 45344 rooms
-- Any players present at a train station will skip the room
-- telling someone '@room' will return location information
-- @set condensed spellout true - supresses local spellout messages
-- Taunts added to paladin
-- Ranger, Paladin: bugfixes
-- cooldown counters added to powers skills (ranger/paladin)
-- spells button replaced with an icon, added to rangers
-- bugfix: special exits recognized if an abbreviated command typed
-- Paladins: old-code spells removed
-- Paladins: 1h, 2h powers added
-- mapper bugfixes
-- added tooltips to lower icons
-- autoroller accelerated
-- buttons were added for autoportal, autoopen
-- imm echoes of format [immname] message now captured
-- rangers: misty path, cloak of protection, cloak of resilience
-- added autohide to ranger, removed kick, mount
-- urls in the main window are now clickable
-- rangers won't rescue rangers, and warriors will rescue rangers 25% of the time
-- added new ranger spells
-- bugfixes
-- Many commands now have '@' at the start of the alias
-- @help index will list all help entries
-- rangers archery powers added
-- buttons will be redrawn when you level
-- (some) helpfile updates
-- some rangers stuff added
-- 'powers prompt' added to prompt regex
-- @find will accept room numbers when searching
-- bash will be switched to powersbash if you bounce off something
-- @set movebuffer # - how many rooms should be sent to the mud before buffering
-- @fwalk buffers path, and sends in 5-10 room bursts
-- Removed @fwalk distance limit
-- changed # command prefix to @

-- 011c (update1)

-- added failed spellcast: You may not cast offensive spells on other players.
-- bugfix: casting ff
-- bugfix: casting: realm
-- Map updated: full size 317 areas 44959 rooms

-- 011c

-- bugfixes
-- poisons will be identified when looking in containers
-- added autohide to rogue
-- .. will walk reverse paths example: ..5ne will walk .w5s
-- katumi database update - 7/11/17
-- looting is disabled when you join a group
-- #room window is now flicker free
-- #fpet - retrieves lost pets
-- ungrouped followers are shown on group display
-- added ancient staff of the ashen soul
-- pet casting scripts
-- pet followers are named/numbered with unique names
-- gui windows redesign
-- spirit wrack added to a-p, fell frost to invoker
-- some text buttons have been replaced with icons
-- generated room, status, group, followers requests are gagged
-- incorrect group classes will be corrected if you type 'who'
-- equipment buttons will update immediatly when you remove/wear the item
-- code for buttons and timers changed
-- starttrain tank moblist : optional, moblist is the name of a variable with a list of mobs to attack
-- improved necro pet (ghost) spellcast
-- more code refactors
-- all generated status requests are now gagged
-- #fwalk area - list fwalks for current area only
-- lich/necro buttons
-- autoassist will work with ungrouped pet followers
-- added outflank
-- refactored train - use 'starttrain tank' to start as engine
-- Added say, auction to tabbed chat windows
-- Map updated: full size 317 areas 44958 rooms

-- 011b

-- the function 'initCustom' will be called on initialization if it exists
-- self in group display if more then 1 person uses cyan colour 
-- file structure and installation updated - mudlet 3.1+ recommended
-- grouped hell hounds are named 'wolf'
-- set poisonbag - name of container containing all poisons
-- buttons refactored
-- set hideequip true/false - left equip bar shows on mouseover
-- clairvoyance will now show the room number viewed and zone name (if available)
-- spell buttons / cast script refactored
-- map window resized
-- changes to casting code
-- xp train starts fights with bodyslam (if ogre)
-- added most spells for all classes
-- pets/undead/mounts added to grouplist / displayed on screen
-- Change from necro to lich in wholist if needed
-- bugfixes
-- Map updated: full size 317 areas 44822 rooms

-- 011a

-- set echodrag true - gsay if a corpse is dragged into your room
-- rot/rain of blood buttons added
-- added tms to vote link
-- cleric: autorealm - keep the entire group realm'd
-- more xp train updates
-- kick enabled kicks mobs after you bash them
-- heal/harm buttons have been redone
-- bash changes to mounted charge after mounting
-- summount mount changes to mount/dismount button after summoning
-- refactored gui buttons
-- type prac, then 'scribeall' to scribe all spells
-- type prac, then 'pracall' to practice all skills
-- scripted: magic missile, earth darts, totem darts, shadow bolt
-- can't cast when paralyzed
-- 'scan' will attempt to solve for unknown map locations
-- half orcs will now use furious assault
-- rogue: assassinate timer
-- illusionist, druid, elementalist, invoker, paladin, anti, ranger, rogue added
-- changed #cd to disable rescue
-- bugfix: casting after gsay of 'moving'
-- Map updated: full size 314 areas 44262 rooms

-- 010

-- refactored and fixed gui sizing
-- set sound on|off|limited - limited plays sounds from tell, petition only
-- #zone command added to list zones example: '#zone swamp'
-- earthquake changed to use non-powers
-- hs being properly distinguished for haste/hamstring
-- fixed mapper not updating properly on dragon autoreturn
-- mapper fixed for passing through magically darkened rooms
-- autotank will not fire if less then 75% hp
-- more sounds!
-- pet rescue button added
-- sounds added for group members getting killed/ressurected 
-- set autohuw - enable/disable casting of holy/unholy word
-- buff:get function changed
-- change bid script to distinguish/display/match capital letters, hyphens
-- icy bash now recognized for success/failure
-- bless button for bard changed to cast harmonious blessing whenever needed
-- set forcerenew - bard will sing renew even at full psp
-- send stand before assist if memorizing
-- stand trigger: In your haste to slam people around, you slip and fall!
-- Get off your knees! added to stand triggers
-- disruption burst added to clerics
-- consent will be provided to anyone that asks
-- Map updated: full size 313 areas 44229 rooms

-- 010rc2

-- another shaman casting groupheal clears blind properly
-- escape working properly for rogues
-- #backup restore updates highlighted buttons
-- Map updated: full size 311 areas 43864 rooms
-- No more split maps - only toril.map used now
-- update map for movement when dragging corpses
-- enchanter will cast prismatic spray
-- clerics will cast holy/unholy word
-- bottom left corner counter changed to show stun
-- set vit nopriest - exclude cleric, shaman, druid from vit
-- fixed inittrain in silverymoon
-- local spell count is updated when casting begins (powerAliases)
-- set wuss charname - this character will be rescued and enchanter spelled regardless of settings
-- groupheal scripted for shaman
-- casting is now autocast on/off
-- set grpfontsize to change font used if &gt; 2 in group
-- 'spells' button changed to cast various spells while enabled (on/off)
-- spellcast/command queue refactored
-- set autores true - res any grouped (consented) corpses present in room
-- cdaura now part of autoheal
-- autoflee is temporarily disabled after 3 failed attempts in the same room
-- set swedish true/false - translate ooc/acc/etc to swedish
-- bugfix: autoflee/mem with caster train
-- set autoquake true - quake certain mobs if seen standing
-- queue cure blind as needed, clear cb from queue on groupheal
-- set autocb true - auto cast cure blind
-- autoenter portal/rift/gate if more people have entered it then grouped warriors
-- special entrances/exits working on map
-- various refactors

-- 010rc1

-- Map updates: full size 289 areas 42082 rooms
-- xp train fixed for an emerald and ruby encrusted dagger
-- xp train fixed for an onyx dagger with a pulsing ruby hilt
-- added bot warning to xp train
-- added hell hound to mounts list
-- shift alias changed to use powers relocate
-- triggers changed from mem autostand
-- casting now echoes the name of the spell being cast
-- autovit - vit after every mem
-- improved #clist
-- display position is now forced true
-- brief mode no longer required to be used with the mapper
-- set style to change css style of buttons
-- fixed autopen door names with newer map format
-- #cd delay changed to 5 sec for casting purposes

-- 010e

-- The script is now running with Mudlet release 30 pr308 of mudlet (compiled)
-- windows: https://github.com/Nyyrazzilyss/NyyLIB/raw/master/mudlet_w32_pr308.zip
-- osx: https://github.com/Nyyrazzilyss/NyyLIB/raw/master/Mudlet.app.zip

-- It should still work with -delta, though attempting to use the full Toril map will be SLOW
-- Map updates are no longer occuring to the individual mapsfiles, only to the toril.map file

-- THE BELOW STEPS SHOULD NOT BE EVEN ATTEMPTED ON MUDLET 3.0-DELTA - ONLY PR308

-- map has been combined into a single mapfile - to switch to using it, type #map toril
-- type #map update after the first time switching to the toril map to update with previously saved map progress

-- Map updates: Full size 254 areas 37958 rooms

-- bugfix: mem'ing darkness won't give illithid messages
-- the script will force restarting now after installation
-- scaleskin button only shown for yuan-ti
-- heal button for clerics will que healing aura on warriors when casting
-- petitions are placed on the 'tells/all' communication tab
-- added labels on map to zone edges

-- 010d

-- Map: Clouds, Ethereal Plane
-- character change after camping fixed
-- Baldurs Gate map fixed (dire raider guildhall)
-- #path command will now provide reverse paths from current room
-- Map: Dragonspear Castle
-- updates to Skullport map
-- Map: Tower of the Elementalist, Keep of Finn McCumhail
-- bidscript won't allow bids with mutiple possible matches
-- set chatfontsize fixed
-- 'starttrain tank' to start as head, regardless of not being warrior class
-- mesh manacle will proc at 70% hp
-- volance will proc at 60% hp
-- warder cloak will proc at 30% hp
-- supple girdle, tiamat sleeves will proc at 25% hp
-- bard singing renew by choice will switch to heal at maxpsp
-- set hideicons true to turn off display of the icon bar
-- maps: Lizard Marsh, Fire Giants Lair
-- centralized debug messages - set condensed debug
-- groupList:whoTanking() - table with how many mobs are on each character
-- #clist list chars now from both katumi database and local cache
-- prompt variables are now located in a prompt:get function
-- fixed condensed duplicate with signs
-- dire raiders
-- starttrain now checks area, and runs different paths for ashstone/silverymoon
-- prime.map split into prime1, prime2. type '#map split'
-- alias: cast - start casting (same as spells button)
-- added maps: Icecrag 2, Hulburg, the Temple of Twisted Flesh, Skerttd-Gul, Mistywood                                      
-- alternate button for check status: group
-- some buttons converted to nesting labels
-- even more cleric stuff
-- more refactors
-- bugfixes

-- 010c

-- set numcolor color to change number colors from the default blue
-- set pokehaste true/false to cast haste when poked
-- set gcmd true/false to use gcmd for gsay
-- some more cleric stuff
-- more refactors
-- bugfixes

-- 010b

-- Map updates: Ashstone, Nightwood, Splitshield
-- aliases: guide, forum, quest open browsers to the newbie guide, torilmud forums, and vb quest website
-- tabs will now be drawn properly (primarily visible in trophy, attributes &lt; level 20)
-- directions bound to keypad: 7=u 8=n 9=d 4=w 5=s 6=e
-- problem with saving map files fixed
-- 'send command' will insert a command into spell queue for immediate execution

-- 010a

-- major refactoring
-- 'resettrain' will disable all train triggers if ended incorrectly
-- added 'starttrain' triggers for casters
-- some cleric icons
-- tweaked valhalla icon
-- #fwalk all - list all fwalks regardless of area
-- the set command rewritten
-- Map updates: Muspelhiem 
-- various changes to add ansi
-- group commands sent by the script itself will be gagged
-- clicking the memorize/pray button will stand if currently mem'ing
-- memorize/pray button now show countdown for remaining spells
-- Updated caster buttons - counters for memorized spells
-- New buttons: bracers of time, warmaul, ocular disc
-- updates to mudlet condensed mode
-- some shaman triggers

-- 009 (final)

-- bugfixes

-- 009rc2

-- misc bugfixes/code cleanup
-- set group true|false - use redesigned group display

-- 009rc1

-- stats tracking added to 'group' command
-- #help astral - zone directions
-- #backup logs - copies contents of profile log files into backup folder
-- map density increased to maximum
-- set border default|none|file - changes the background image used (.png file)
-- added condensed modes - set condensed {dragon|combat|spells|items|arrows|misc|duplicate}
-- various map fixes
-- various bugfixes
-- maps added: The Lurkwood

-- 009d

-- misc bugfixes
-- fwalk/doubleclicking on map room to speedwalk will no longer send a 'stand' command (it breaks hide)
-- path corrected for #backup on osx/linux
-- fwalk will no longer run if path is longer then 100 rooms
-- maps added: Basin Wastes
-- maps fixed: Magma


-- 009c

-- #backup command added: type #backup for more information
-- misc bug fixes
-- permenantly 'locked' rooms flagged in maps - speedwalks will never pass through these rooms
-- #path now provides room path split at 50 rooms
-- #path now works with #fwalk names
-- update map on doorbash
-- maps added: Dark Forest, Orcish Halls of Plunder
-- maps fixed: CPV, Twisted Rune, Roads of the Heartland 1/2, VB Guildhall, UM2


-- 009b

-- map will update properly when tracking
-- Abreviations when loading maps: ud=underdark, em=evermeet
-- enlarge option added to enchanter resize button
-- some (most) buttons recoloured
-- more map updates (Ice, Faerie Realms, Seelie Faerie Court)
-- character profilenames will be updated from more sources
-- #stats - warrior statistics
-- #save - save chardata, loaded map
-- es[dir][b/c/p] - p=powers backstab
-- added room name to #room window
-- prompt won't be echoed to chat/room window if the mud doesn't send newline

-- 009a

-- map density increased 16x
-- Type #room to show/hide room capture window
-- #cd [dir] - countdown script - attacks targetname from #attack command, if none does hitall
-- #fwalk now shows length in rooms to destination, only shows destinations reachable from current location
-- es[dir][b/c] - escape direction, return, and backstab/circle targetname from #attack (example: eswb, esnc) 
-- #at[dir] (example #atn, #ats, etc) - move direction and backstab target
-- #attack targetname - set targetname variable
-- gui has been changed around

-- 008 (final)

-- Faang, Darktree moved to Underdark map
-- Added maps: Various Moonshaes - Added to 'evermeet' map
-- Added maps: Conqured Village, Baphomet
-- Room colours added
-- #fwalk results sorted by area
-- #path command to display path/length to room number

-- 008rc3

-- Added maps: Drulak, Plane of Fire 1&amp;2, Water, Yggdrasil
-- #afind pattern - find discovered rooms matching pattern in current area
-- #map update - update loaded map without resetting unlocked rooms
-- #fwalk shows area rooms are located in

-- 008rc2

-- Katumi database updated 2015/10/10
-- To help with map related slowdowns, it has been split to multiple files: scardale, prime, underdark, evermeet, planes
-- example: type: '#map scardale' to switch to Scardale map (Scardale map also includes Waterdeep)
-- 'set autoopen false' to disable opening doors
-- Doors added to map, and moving/fwalk through them will attempt to open first
-- misc updates to mapper
-- Added Maps: Temple of Dumathoin, Lair of the Deep Dragon, Yath Olath, more!
-- Added maps: Evermeet Bay, Manscorpions, Seer Kings, Ixarkon Prison, Githyanki, Choking Palace, Twisted Rune

-- 008rc1

-- sm xp train - type 'inittrain' in Silverymoon to setup map.
--	  (note this will run several minutes, and look like it's frozen), starttrain, stoptrain
-- #help command

-- 008g

-- #fwalk information now profile specific, not stored by character.
-- set vnum true/false - display room vnum after exits
-- tank rescue will occur at ph/awful, if self &gt; .30 maxhp
-- bash corrected if not warrior
-- Added maps: Imphras Guildhall, Trollbark Forest, Spiderhaunt, Thunderhead Peak, Earth Plane

-- 008f

-- major improvements to keeping map in sync
-- alias: fwalk changed to #fwalk, new command structure
--		#fwalk  - instructions, list of existing fwalks
--	   #fwalk roomnumber - fastwalk to specific room number
--    #fwalk name - fastwalk to room indicated by previously added name
--    #fwalk add name - adds a fastwalk using 'name' to the currently occupied room
--    #fwalk del name - deletes fastwalk 'name'
-- profile names are displayed after character names on 'group'
-- Added maps: The Evermoors, Undermountain 1&amp;2, The Underdark Trade Route, The Underworld, Nizari, Labyrinth of No Return, The Spirit Raven (Pirate Ship), Calimsham Desert, 
-- misc bugfixes

-- 008e

-- 3 choices now on enchanter globe: off, hitters, or all (hitters+warriors)
-- alias: #find - findroom merged with this alias, type #find to locate current position/or #find roomname
--  #find * - list all discovered rooms
-- autoroller: 
--		mighty=1 heroic=2 perfect=3
--		mighty heroic heroic perfect = 1 + 2 + 2 + 3 = 8
--	set autoroll 8    - stop on rolls &gt;= 8
--	alias: #roll - start autoroller
-- alias: map - updated, type 'map' for more information
-- alias: castspells - same as clicking spells button
-- alias: #id itemname - identify matching items
-- alias: dep - deposit all coins held or inside main storage container to the bank
-- disarm button added
-- More maps: New Cavecity, Klauthen Vale, The Shadow Swamp, The Swamps of Meilech, Darklake, Tunnel of Dread
-- size, buffs removed on death
-- more fixes to mapper to locate rooms / keep in sync
-- warrior will auto rescue other warriors if awful/ph/nasty and &gt;400hp
-- alias: #clist charname - list all known characters for that char's profile
-- alias: #gall charname - gag all characters for that char's profile
-- when examining containers, potions, scrolls will be identified on screen
-- alias: #statitems gsay - echo glist stats to gsay
-- alias: #statitems - echo glist stats to screen
-- katumi database incorporated
-- bid script: type 'bid help' for commands
-- rm (rescue me) alias changed to 'rme' not to conflict with righteous might
-- update map on escape

-- 008d

-- #gag/#ungag commands
-- enchanter: swapts alias - switch ds and ts in memorized spells
-- size button for enchanter: reduce halfing/gnome casters, enlarge ogre warriors
-- players added to onscreen group if not present and they gsay
-- set autotank true/false
-- set powersbash true/false
-- set valhalla defend/berserk
-- no more rescuing paladins/antipaladins in basic rescue mode

-- 008c

-- added some more documentation
-- mapper updates
-- 16765 rooms / 91 areas now included

-- 008b

-- All rooms are now hidden on the map until you have discovered it
-- find now checks for matching room name + exits

-- 008a - The mapper!

-- addarea - by itself for available areas, with an area number to add a blank map for the area
-- fwalk roomid - Fastwalk to roomid
-- findroom name - Search entire map for matching rooms
-- find - set your location on the map (Only Silverymoon, Scardale, Vipertounge, Western Realms at this time)
-- map load/save - to save your own map
-- map on/off - turn map display on or off

-- 007

--	Final release of 007 series

--007rc4b, 007rc4c

-- bugfix

-- 007rc4

-- added 'escape direction' for all classes
-- show body size
-- kill people if they're charmed
-- gsay on size change, consent
-- added feeblemind to group display
-- updated fastwalks (mostly wd area)

-- 007rc3

-- fwalk now includes reversed fastwalks
-- skill improvement capture window
-- bugfixes, mostly for warrior - rescue seems to work now

-- 007rc2

-- auto assist and rescue improved
-- bugfixes

-- 007h

-- meditate/stand button for psi
-- generic spells button for all script-less casters
--		set masscast powersname to spell name for it to cast
-- equip procs: bane
-- set automem (start memorizing if the majority of the group does)
-- fly now an option on endspell
-- added para, blind, silent to group display
-- on screen xp counter (until level 50)
-- misc bugfixes

-- 007g

-- song of miscast magic added (commandline only)
-- misc bug fixes

-- 007f

-- shaman now has functioning generic spells button
--   set masscast powersname to spell name for it to cast
-- added 'pwt' to endspell options
-- internal buff lengths update based on powers info / sf enc
-- added 'version' command
-- regen song button in place of heal song for lower level bard
-- mem on bard/battlechanter now handled properly
-- add people to grouplist if they gsay
-- some work done with rescue
-- updated fastwalks
-- disabled spellguard kill trigger
-- bugfix on adding to who database

-- 007e

-- self will be autoadded to wholist on initial login
-- improved autoassist
-- deathfield button for unquested psi
-- updated fastwalks
-- added rescue/bash/kick (such that they are) from War to Pal, A-P, Ran, Dir
-- some basic instructions added (type 'client' to read them)

-- 007d

-- set endspell (vit, dsp) - change the final spell displayed in group window
-- marking dead is now done by the new death message
-- updated buttons (sleeves, sandals, loop, grin)
-- set assocchar (charname) - connect to association chat on login
-- spellout messages are now changeable
-- minimum level now on button creation
-- fwalk alias for fastwalks</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>ImportedCode</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>chef</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- Copyright (C) 2009 Florian Zeitz
-- Copyright (C) 2009 Matthew Wild
--
-- This project is MIT/X11 licensed. Please see the
-- COPYING file in the source package for more information.
--

local chef = {
  { th = "t" },

  { ow = "o"},
  {["([^%w])o"] = "%1oo",
  O = "Oo"},

  {au = "oo",
  u = "oo", U = "Oo"},
  {["([^o])o([^o])"] = "%1u%2"},
  {ir = "ur",

  an = "un", An = "Un", Au = "Oo"},

  {e = "i", E = "I"},

  { i = function () return select(math.random(2), "i", "ee"); end },

  {a = "e", A = "E"},

  {["e([^%w])"] = "e-a%1"},
  {f = "ff"},

  {v = "f", V = "F"},
  {w = "v", W = "V"} };

function swedish(english)
	local eng, url = english:match("(.*)(http://.*)$");
	if eng then english = eng; end

	for _,v in ipairs(chef) do
		for k,v in pairs(v) do
			english = english:gsub(k,v);
		end
	end
	english = english:gsub("the", "zee");
	english = english:gsub("The", "Zee");
	english = english:gsub("tion", "shun");
	--english = english:gsub("[.!?]$", "%1\nBork Bork Bork!");
	return tostring(english..((url and url) or ""));
end

function check_message(data)
	local origin, stanza = data.origin, data.stanza;

	local body, bodyindex;
	for k,v in ipairs(stanza) do
		if v.name == "body" then
			body, bodyindex = v, k;
		end
	end

	if not body then return; end
	body = body:get_text();

	if body and (body:find(trigger_string, 1, true) == 1) then
		module:log("debug", body:find(trigger_string, 1, true));
		stanza[bodyindex][1] = swedish(body:gsub("^" .. trigger_string, "", 1));
	end
end


</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>LuaBit v0.4</name>
					<packageName></packageName>
					<script>------------------------------------------------
--LuaBit v0.4
-------------------
--a bitwise operation lib for lua.

--http://luaforge.net/projects/bit/

--How to use:
-------------------
-- bit.bnot(n) -- bitwise not (~n)
-- bit.band(m, n) -- bitwise and (m &amp; n)
-- bit.bor(m, n) -- bitwise or (m | n)
-- bit.bxor(m, n) -- bitwise xor (m ^ n)
-- bit.brshift(n, bits) -- right shift (n &gt;&gt; bits)
-- bit.blshift(n, bits) -- left shift (n &lt;&lt; bits)
-- bit.blogic_rshift(n, bits) -- logic right shift(zero fill &gt;&gt;&gt;)
 
--Please note that bit.brshift and bit.blshift only support number within
--32 bits.

--2 utility functions are provided too:
-- bit.tobits(n) -- convert n into a bit table(which is a 1/0 sequence)
               -- high bits first
-- bit.tonumb(bit_tbl) -- convert a bit table into a number 
-------------------

--Under the MIT license.

--copyright(c) 2006~2007 hanzhao (abrash_han@hotmail.com)
--]]---------------


------------------------
-- bit lib implementions

function check_int(n)
 -- checking not float
 if(n - math.floor(n) &gt; 0) then
  error("trying to use bitwise operation on non-integer!")
 end
end

local function to_bits(n)
 check_int(n)
 if(n &lt; 0) then
  -- negative
  return to_bits(bit.bnot(math.abs(n)) + 1)
 end
 -- to bits table
 local tbl = {}
 local cnt = 1
 while (n &gt; 0) do
  local last = math.mod(n,2)
  if(last == 1) then
   tbl[cnt] = 1
  else
   tbl[cnt] = 0
  end
  n = (n-last)/2
  cnt = cnt + 1
 end

 return tbl
end

function tbl_to_number(tbl)
 local n = table.getn(tbl)

 local rslt = 0
 local power = 1
 for i = 1, n do
  rslt = rslt + tbl[i]*power
  power = power*2
 end
 
 return rslt
end

function expand(tbl_m, tbl_n)
 local big = {}
 local small = {}
 if(table.getn(tbl_m) &gt; table.getn(tbl_n)) then
  big = tbl_m
  small = tbl_n
 else
  big = tbl_n
  small = tbl_m
 end
 -- expand small
 for i = table.getn(small) + 1, table.getn(big) do
  small[i] = 0
 end

end

function bit_or(m, n)
 local tbl_m = to_bits(m)
 local tbl_n = to_bits(n)
 expand(tbl_m, tbl_n)

 local tbl = {}
 local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))
 for i = 1, rslt do
  if(tbl_m[i]== 0 and tbl_n[i] == 0) then
   tbl[i] = 0
  else
   tbl[i] = 1
  end
 end
 
 return tbl_to_number(tbl)
end

function bit_and(m, n)
 local tbl_m = to_bits(m)
 local tbl_n = to_bits(n)
 expand(tbl_m, tbl_n) 

 local tbl = {}
 local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))
 for i = 1, rslt do
  if(tbl_m[i]== 0 or tbl_n[i] == 0) then
   tbl[i] = 0
  else
   tbl[i] = 1
  end
 end

 return tbl_to_number(tbl)
end

function bit_not(n)
 
 local tbl = to_bits(n)
 local size = math.max(table.getn(tbl), 32)
 for i = 1, size do
  if(tbl[i] == 1) then 
   tbl[i] = 0
  else
   tbl[i] = 1
  end
 end
 return tbl_to_number(tbl)
end

function bit_xor(m, n)
 local tbl_m = to_bits(m)
 local tbl_n = to_bits(n)
 expand(tbl_m, tbl_n) 

 local tbl = {}
 local rslt = math.max(table.getn(tbl_m), table.getn(tbl_n))
 for i = 1, rslt do
  if(tbl_m[i] ~= tbl_n[i]) then
   tbl[i] = 1
  else
   tbl[i] = 0
  end
 end
 
 --table.foreach(tbl, print)

 return tbl_to_number(tbl)
end

function bit_rshift(n, bits)
 check_int(n)
 
 local high_bit = 0
 if(n &lt; 0) then
  -- negative
  n = bit_not(math.abs(n)) + 1
  high_bit = 2147483648 -- 0x80000000
 end

 for i=1, bits do
  n = n/2
  n = bit_or(math.floor(n), high_bit)
 end
 return math.floor(n)
end

-- logic rightshift assures zero filling shift
function bit_logic_rshift(n, bits)
 check_int(n)
 if(n &lt; 0) then
  -- negative
  n = bit_not(math.abs(n)) + 1
 end
 for i=1, bits do
  n = n/2
 end
 return math.floor(n)
end

function bit_lshift(n, bits)
 check_int(n)
 
 if(n &lt; 0) then
  -- negative
  n = bit_not(math.abs(n)) + 1
 end

 for i=1, bits do
  n = n*2
 end
 return bit_and(n, 4294967295) -- 0xFFFFFFFF
end

function bit_xor2(m, n)
 local rhs = bit_or(bit_not(m), bit_not(n))
 local lhs = bit_or(m, n)
 local rslt = bit_and(lhs, rhs)
 return rslt
end

--------------------
-- bit lib interface

bit = {
 -- bit operations
 bnot = bit_not,
 band = bit_and,
 bor  = bit_or,
 bxor = bit_xor,
 brshift = bit_rshift,
 blshift = bit_lshift,
 bxor2 = bit_xor2,
 blogic_rshift = bit_logic_rshift,

 -- utility func
 tobits = to_bits,
 tonumb = tbl_to_number,
}
</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Demonnic</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<ScriptGroup isActive="yes" isFolder="yes">
						<name>Tabbed Chat</name>
						<packageName></packageName>
						<script>--Do not remove the following lines. Or change them.
demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.tabsToBlink = demonnic.chat.tabsToBlink or {}
demonnic.chat.config = demonnic.chat.config or {}
demonnic.chat.tabs = demonnic.chat.tabs or {}
demonnic.chat.windows = demonnic.chat.windows or {}
demonnic.chat.config.activeColors = demonnic.chat.config.activeColors or {}
demonnic.chat.config.inactiveColors = demonnic.chat.config.inactiveColors or {}</script>
						<eventHandlerList />
						<Script isActive="yes" isFolder="no">
							<name>Configuration Options</name>
							<packageName></packageName>
							<script>--[[
This is where all of the configuration options can be set. 
Anything I've put in this script object can be changed, but please do pay attention to what you're doing.
If you change one of the values to something it shouldn't be, you could break it. 
]]

--This is where you tell it to use tabbed chat.
demonnic.chat.use = true

--[[
The timestamp option is set here.
Set to false if you do not want any timestamps displayed for chat.
If you do want it displayed, set to the string for the format you wish. 
see http://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for information
how to format the string
]]
demonnic.chat.config.timestamp = "hh:mm"

--[[ Should we use our own colors for the timestamp?
Set to true if you want to specify foreground and background colors
for the timestamp.
Set to false if you want the timestamps background and foreground
colors to match that of the mud output.
]]
demonnic.chat.config.timestampCustomColor = false
--[[
and what foreground color? You can either use one of the 'named' colors
(see http://wiki.mudlet.org/images/c/c3/ShowColors.png for available colors)
demonnic.chat.config.timestampFG = "slate_grey"

Or you can use a table of R,G,B values. 
demonnic.chat.config.timestampFG = {
  255,
    0,
    0,
}
then the foreground for the timestamp would be 255 read, 100 green, and 0 blue
]]
demonnic.chat.config.timestampFG = "red"

--and background? Same rules as for the foreground above
demonnic.chat.config.timestampBG = "blue"

--[[
This is where you say what corner of the screen you want the tabbed chat on
Valid settings are "topright", "topleft", "bottomright", "bottomleft"
]]--
demonnic.chat.config.location = "topright"

--[[
This is a table of channels you would like.
AKA the place you tell the script what tabs you want.
Each entry must be a string. The defaults should be a pretty effective guide.
]]

demonnic.chat.config.channels = {
  "ALL",
	"SAYS",
	"SKILL",
  "TELLS",
  "GSAY",
  "GCMD",
	"NHC",
  "GCC",
  "OOC",
  "ACC",
  "AUC"
}


--Set this to the name of the channel you want to have everything sent to. 
--Per the default, this would be the "All" channel. If you have a different name for it:
--
--demonnic.chat.config.Alltab = "Bucket"  
--
--And if you don't want it turned on at all:
--
--demonnic.chat.config.Alltab = false

demonnic.chat.config.Alltab = "ALL"



---------------------------------------------------------------------------------
--                                                                             --
--The infamous blinking stuff!!!                                               --
--                                                                             --
---------------------------------------------------------------------------------

--[[
Do you want tabs to blink when you get new messages, until you click on the tab?
True if yes, false if no.
]]
demonnic.chat.config.blink = true

--How long (in seconds) between blinks? For example, 1 would mean a 1 second pause in between blinks.
demonnic.chat.config.blinkTime = 3

--Blink if the bucket tab ("All" by default, but configured above) is in focus?
demonnic.chat.config.blinkFromAll = true




--Font size for the chat messages

demonnic.chat.config.fontSize = 12

--[[
Should we preserve the formatting of the text. 
Or should we set the background of it to match the window color?
Set this to false if you want the background for all chat to match the background of the window.
Useful if you change the background from black, and don't like the way the pasted chat makes blocks in it
]]

demonnic.chat.config.preserveBackground = false

--[[
Gag the chat lines in the main window?
defaults to false, set to true if you want to gag.
]]

demonnic.chat.config.gag = false

--[[
Number of lines of chat visible at once. 
Will determine how tall the window for the chats is.
]]

-- demonnic.chat.config.lines = 19

--[[
Number of characters to wrap the chatlines at.
This will also determine how wide the chat windows are.
]]

demonnic.chat.config.width = 64

--[[
Set the color for the active tab. R,G,B format.
The default here is a brightish green
]]

demonnic.chat.config.activeColors = {
  r = 0,
  g = 180,
  b = 0,
}

--[[
Set the color for the inactive tab. R,G,B format.
The default here is a drab grey
]]

demonnic.chat.config.inactiveColors = {
  r = 60,
  g = 60,
  b = 60,
}

--[[
Set the color for the chat window itself. R,G,B format.
Defaulted to the black of my twisted hardened soul. Or something.
]]

demonnic.chat.config.windowColors = {
  r = 0,
  g = 0,
  b = 0,
}

--[[
Set the color for the text on the active tab. Uses color names.
Set the default to purple. So the tab you're looking at, by default will be purple on bright green. 
Did I mention I'm a bit colorblind?
]]

demonnic.chat.config.activeTabText = "purple"

--[[
Set the color for the text on the inactive tabs. Uses color names.
Defaulted this to white. So the tabs you're not looking at will be white text on boring grey background.
]]

demonnic.chat.config.inactiveTabText = "white"

--[[
have to make sure a currentTab is set... 
so we'll use the one for the bucket, or the first one in the channels table
Or, you know... what it's currently set to, if it's already set.
]]
demonnic.chat.currentTab = demonnic.chat.currentTab or demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>Code</name>
							<packageName></packageName>
							<script>function setChatLabel(xwindow, xtext, xcolor)
--		local fontColour=charData:get("colbuttonoff")
--		fontColour=charData:get("colbuttonon")
	local fontSize=14

	local font = charData:get("font", true)

	if xcolor == nil then
		xcolor="white"
	end

	xwindow:setStyleSheet([[background-color : transparent]])

	if xcolor == charData:get("colbuttonon") then
		-- add bold
		xwindow:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. font .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. xcolor .. [["&gt;]] .. xtext .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
	else
		xwindow:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. font .. [['"&gt;&lt;center&gt;&lt;font color="]] .. xcolor .. [["&gt;]] .. xtext .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
	end
end



--[[
If the label callbacks ever decide to start taking a function which is part of a table, 0then this will change.
Or if it's modified to take actual functions. Anonymouse function clickcallback would be awfully nice.
]]

function demonnicChatSwitch(chat)
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local newr = demonnic.chat.config.activeColors.r
  local newg = demonnic.chat.config.activeColors.g
  local newb = demonnic.chat.config.activeColors.b
  local oldchat = demonnic.chat.currentTab
  if demonnic.chat.currentTab ~= chat then

	 --demonnic.chat.tabs[oldchat]:setStyleSheet([[border-image: url(]] .. iconpath("gui".. oldchat  .. ".png") .. [[)]])
		setChatLabel(demonnic.chat.tabs[oldchat], oldchat, charData:get("colbuttonoff"))
--		fontColour=charData:get("colbuttonon")

    demonnic.chat.windows[oldchat]:show()
    demonnic.chat.windows[oldchat]:hide()
    demonnic.chat.tabs[oldchat]:setColor(r,g,b)
    -- demonnic.chat.tabs[oldchat]:echo(oldchat, demonnic.chat.config.inactiveTabText, "c")
    if demonnic.chat.config.blink and demonnic.chat.tabsToBlink[chat] then
      demonnic.chat.tabsToBlink[chat] = nil
    end
    if demonnic.chat.config.blink and chat == demonnic.chat.config.Alltab then
      demonnic.chat.tabsToBlink = {}
    end
  end
  demonnic.chat.tabs[chat]:setColor(newr,newg,newb)
  -- demonnic.chat.tabs[chat]:echo(chat, demonnic.chat.config.activeTabText, "c")
  demonnic.chat.windows[chat]:show()

	setChatLabel(demonnic.chat.tabs[chat], chat, charData:get("colbuttonon"))

  demonnic.chat.currentTab = chat  
end

function demonnic.chat:resetUI()

	demonnic.chat.container = Geyser.Container:new( {
    fontSize = demonnic.chat.config.fontSize,
--  x=string.format("-%sc",demonnic.chat.config.width + 2),
	 x=0,
    y=0,
    width="100%",
--  width="-15px",
--    height=string.format("%ic", demonnic.chat.config.lines + 2),
	 height="40%"
  }, Geyser.Label:getWindow("RightPanel") )

  demonnic.chat.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "25px",
    name = "DemonChatTabs",
  },demonnic.chat.container)

end

function demonnic.chat:create()
  --reset the UI
  demonnic.chat:resetUI()
  --Set some variables locally to increase readability
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local winr = demonnic.chat.config.windowColors.r
  local wing = demonnic.chat.config.windowColors.g
  local winb = demonnic.chat.config.windowColors.b

  --iterate the table of channels and create some windows and tabs
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.tabs[tab] = Geyser.Label:new({
      name=string.format("tab%s", tab),
    }, demonnic.chat.tabBox)


	-- demonnic.chat.tabs[tab]:setStyleSheet([[border-image: url(]] .. iconpath("gui".. tab  .. ".png") .. [[)]])
	setChatLabel(demonnic.chat.tabs[tab], tab, charData:get("colbuttonoff"))


    -- demonnic.chat.tabs[tab]:echo(tab, demonnic.chat.config.inactiveTabText, "c")
    demonnic.chat.tabs[tab]:setColor(r,g,b)
    demonnic.chat.tabs[tab]:setClickCallback("demonnicChatSwitch", tab)

    demonnic.chat.windows[tab] = Geyser.MiniConsole:new({
--      fontSize = demonnic.chat.config.fontSize,
      x = 0,
      y = 25,
      height = "100%",
      width = "100%",
      name = string.format("win%s", tab),
    }, demonnic.chat.container)
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
    demonnic.chat.windows[tab]:setColor(winr,wing,winb)
    

	local WindowWidth, WindowHeight = getMainWindowSize()
	local wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)

	local tmp = (WindowWidth/3)/ wwidth
 
--	 demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
   demonnic.chat.windows[tab]:setWrap(tmp) 
   demonnic.chat.windows[tab]:show()
   demonnic.chat.windows[tab]:hide()
  end
  local showme = demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
  demonnicChatSwitch(showme)
  --start the blink timers, if enabled
  if demonnic.chat.config.blink and not demonnic.chat.blinkTimerOn then
    demonnic.chat:blink()
  end
end


function demonnic.chat:redo()
	local WindowWidth, WindowHeight = getMainWindowSize()
	local wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)
	
	if charData:get("chatfontsize", true) == "auto" then
		demonnic.chat.config.fontSize= maxfont(60, (WindowWidth/3-15))
	
		if demonnic.chat.config.fontSize &gt; 12 then
			demonnic.chat.config.fontSize = 12
		end	
	else
		demonnic.chat.config.fontSize= tonumber(charData:get("chatfontsize", true))
	end

	wwidth,wheight = calcFontSize(demonnic.chat.config.fontSize)	

  --iterate the table of channels and redo wrap, fontsize
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
 	  demonnic.chat.windows[tab]:setWrap( (WindowWidth/3)/wwidth ) 
  	if tab ~= demonnic.chat.currentTab then
			setChatLabel(demonnic.chat.tabs[tab], tab, charData:get("colbuttonoff") )
		end
	end
end

function demonnic.chat:append(chat, xwho, xbody)
  local r = demonnic.chat.config.windowColors.r
  local g = demonnic.chat.config.windowColors.g
  local b = demonnic.chat.config.windowColors.b

  local ofr,ofg,ofb = getFgColor()
  local obr,obg,obb = getBgColor()
  if demonnic.chat.config.preserveBackground then
    setBgColor(r,g,b)
  end

	-- check if broken packet/line on same line as prompt

	local roomline = getLines(getLineCount(), getLineCount()-1)[1]

	if roomline == nil then
		echo("[ERROR: nil roomline]\n")
	end

	local linecheck = string.find(roomline, "^&lt; .* &gt; ")

	if linecheck ~= nil then
		linecheck = string.find(roomline, "&gt; ")
	end

	if linecheck ~= nil then
		-- include part line without prompt
		selectSection(linecheck+1, string.len(roomline)-linecheck-1)
	else
	-- include full line in capture window
		selectCurrentLine()
	end

  copy()

	-- don't echo gagged text

	if isGagged(captureWho) or isGagged(captureBody) or isGagged(roomline) then
		return
	end

	-- don't echo empty lines

	if getCurrentLine() == nil then
		return
	end

	if getCurrentLine() == "" then
		return
	end

	-- don't capture wormhole requests

	if 	string.find(roomline, ".* tells you 'hole .*") or
			string.find(roomline, ".* tells you 'hol .*") or
			string.find(roomline, ".* tells you 'worm .*") or
			string.find(roomline, ".* tells you 'wormhole .*") or
			string.find(roomline, ".* tells you 'rift .*") then
				return
	end

	-- append to subtab, allTab
	if chat == "GSAY" then
		-- supress adding to alltab
		demonnic.chat.windows[chat]:append(xwho, xbody, "GSAY")
	else
 		demonnic.chat.windows[chat]:append(xwho, xbody)
 	end
 
  if demonnic.chat.config.gag then 
    deleteLine() 
    tempLineTrigger(1,1, [[if isPrompt() then deleteLine() end]])
  end
 
	if demonnic.chat.config.blink and chat ~= demonnic.chat.currentTab then 
    if (demonnic.chat.config.Alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end


function demonnic.chat:blink()
  if demonnic.chat.blinkID then killTimer(demonnic.chat.blinkID) end
  if not demonnic.chat.config.blink then 
    demonnic.chat.blinkTimerOn = false
    return 
  end
  for tab,_ in pairs(demonnic.chat.tabsToBlink) do
    demonnic.chat.tabs[tab]:flash()
  end
  demonnic.chat.blinkID = tempTimer(demonnic.chat.config.blinkTime, function () demonnic.chat:blink() end)
end
</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>demonnicOnStart</name>
							<packageName></packageName>
							<script>function demonnicOnStart()
	cecho("&lt;red&gt;[Initializing chat windows...]\n")

	local WindowWidth, WindowHeight = getMainWindowSize()

	NyyLIB = NyyLIB or {}

	setBorderRight(math.ceil(WindowWidth/3)+15)	

	createRightsideContainers()
	createLeftsideContainers()

	-- if demonnic.chat.use then
	demonnic.chat:create()
  	-- end

	cecho("&lt;red&gt;[Chat containers created]\n")
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>echo functions</name>
							<packageName></packageName>
							<script>
function demonnic.chat:cecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  cecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    cecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:decho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  decho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    decho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:hecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  hecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    hecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:echo(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  echo(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    echo(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end</script>
							<eventHandlerList />
						</Script>
						<Script isActive="yes" isFolder="no">
							<name>geyser additions</name>
							<packageName></packageName>
							<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function Geyser.MiniConsole:clear()
   clearWindow(self.name)
end

function Geyser.MiniConsole:append(xwho, xbody, windowName)
  
	local allTab=false
	
	if demonnic.chat.config.Alltab then 
		allTab=string.format("win%s", demonnic.chat.config.Alltab)
	end

	if xwho ~= nil then
		hechoLink(self.name, xwho, [[nilFunction()]], getTime(true, "ddd hh:mm AP"), true)
		
		if allTab then
			hechoLink(allTab, xwho, [[nilFunction()]], getTime(true, "ddd hh:mm AP"), true)
		end
		
		-- duplicate echo to gcmd if gsay and group leader
		if windowName == "GSAY" and string.find(xwho, NyyLIB.leader) then
			hechoLink("winGCMD", xwho, [[nilFunction()]], getTime(true, "ddd hh:mm AP"), true)
		end
		
		
		-- show xbody if passed
		if xbody ~= nil then
			-- display body with url link if present
		
			local checkUrl = getUrl(xbody)
		
			if checkUrl then
				hechoLink(self.name, xbody, [[openUrl("]] .. checkUrl .. [[")]], checkUrl, true)

				if allTab then
					hechoLink(allTab, xbody, [[openUrl("]] .. checkUrl .. [[")]], checkUrl, true)
				end
			else
				-- replace single with double backslash
				xbody=string.gsub(xbody, "\\", "\\")	

				hecho(self.name, xbody)
			
				if allTab then
					hecho(allTab, xbody)
				end
			
				-- duplicate echo to gcmd if gsay and group leader
				if windowName == "GSAY" and string.find(xwho, NyyLIB.leader) then
					hecho("winGCMD", xbody)
				end
			end
		end

		-- terminate line
		deselect()
		copy()
		appendBuffer(self.name)
	
		if allTab then
			appendBuffer(allTab)
		end
	
		if windowName == "GSAY" and string.find(xwho, NyyLIB.leader) then
			-- line termination required for gcmd window also
			appendBuffer("winGCMD")
		end
	end
end

function Geyser.MiniConsole:setStyleSheet(style)
  appendBuffer(self.name)
end

-- rLabel:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])</script>
							<eventHandlerList />
						</Script>
						<Script isActive="no" isFolder="no">
							<name>copyString</name>
							<packageName></packageName>
							<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function clearScratchPad()
	if scratchPad ~= nil then
		clearWindow("scratchPad")
	end
end

function copyStringToScratchpad(xstring)
	local currentLine = getLines(getLineCount(), getLineCount()-1)[1]

	if scratchPad == nil then
		scratchPad=createBuffer("scratchPad")
	end

	display(currentLine)
	-- body of tell
	--moveCursorEnd()
	--selectSection(string.len(whotell)+11, string.len(matches[1])-string.len(whotell)-11)
	--copy()

	--moveCursor("scratchPad", 0, 0)
	--paste("scratchPad")

	-- who sent tell

	--selectSection(0, string.len(whotell)+1)
	--copy()

	--moveCursor("scratchPad", 0, 0)
	--paste("scratchPad")


	-- place built line on winALL

	--selectCurrentLine("scratchPad")
	--copy("scratchPad")

	--moveCursorEnd()

	--appendBuffer("winALL")
end</script>
							<eventHandlerList />
						</Script>
					</ScriptGroup>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>extract url</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- all characters allowed to be inside URL according to RFC 3986 but without
-- comma, semicolon, apostrophe, equal, brackets and parentheses
-- (as they are used frequently as URL separators)
local text_with_URLs = [[
   &lt;a href="http://www.lua.org:80/manual/5.2/contents.html"&gt;L.ua 5.2&lt;/a&gt;
   [url=127.0.0.1:8080]forum link[/url]
   intranet links: http://test, http://retracker.local/announce
   [markdown link](https://74.125.143.101/search?q=Who+are+the+Lua+People%3F)
   long subdomain chain: very.long.name.of.my.site.co.uk
   auth link: ftp://user:pwd@site.com/path - not recognized yet :(
]]

local domains = [[.ac.ad.ae.aero.af.ag.ai.al.am.an.ao.aq.ar.arpa.as.asia.at.au
   .aw.ax.az.ba.bb.bd.be.bf.bg.bh.bi.biz.bj.bm.bn.bo.br.bs.bt.bv.bw.by.bz.ca
   .cat.cc.cd.cf.cg.ch.ci.ck.cl.cm.cn.co.com.coop.cr.cs.cu.cv.cx.cy.cz.dd.de
   .dj.dk.dm.do.dz.ec.edu.ee.eg.eh.er.es.et.eu.fi.firm.fj.fk.fm.fo.fr.fx.ga
   .gb.gd.ge.gf.gh.gi.gl.gm.gn.gov.gp.gq.gr.gs.gt.gu.gw.gy.hk.hm.hn.hr.ht.hu
   .id.ie.il.im.in.info.int.io.iq.ir.is.it.je.jm.jo.jobs.jp.ke.kg.kh.ki.km.kn
   .kp.kr.kw.ky.kz.la.lb.lc.li.lk.lr.ls.lt.lu.lv.ly.ma.mc.md.me.mg.mh.mil.mk
   .ml.mm.mn.mo.mobi.mp.mq.mr.ms.mt.mu.museum.mv.mw.mx.my.mz.na.name.nato.nc
   .ne.net.nf.ng.ni.nl.no.nom.np.nr.nt.nu.nz.om.org.pa.pe.pf.pg.ph.pk.pl.pm
   .pn.post.pr.pro.ps.pt.pw.py.qa.re.ro.ru.rw.sa.sb.sc.sd.se.sg.sh.si.sj.sk
   .sl.sm.sn.so.sr.ss.st.store.su.sv.sy.sz.tc.td.tel.tf.tg.th.tj.tk.tl.tm.tn
   .to.tp.tr.travel.tt.tv.tw.tz.ua.ug.uk.um.us.uy.va.vc.ve.vg.vi.vn.vu.web.wf
   .ws.xxx.ye.yt.yu.za.zm.zr.zw]]
local tlds = {}
for tld in domains:gmatch'%w+' do
   tlds[tld] = true
end
local function max4(a,b,c,d) return math.max(a+0, b+0, c+0, d+0) end
local protocols = {[''] = 0, ['http://'] = 0, ['https://'] = 0, ['ftp://'] = 0}
local finished = {}

function getUrl(xstring)
	
	-- remove any colour codes in string
	xstring = string.gsub(xstring, "|c%d%d%d%d%d%d", "")
	
	for pos_start, url, prot, subd, tld, colon, port, slash, path in
  	xstring:gmatch'()(([%w_.~!*:@&amp;+$/?%%#-]-)(%w[-.%w]*%.)(%w+)(:?)(%d*)(/?)([%w_.~!*:@&amp;+$/?%%#=-]*))'
	do
   	if protocols[prot:lower()] == (1 - #slash) * #path and not subd:find'%W%W'
      and (colon == '' or port ~= '' and port + 0 &lt; 65536)
      and (tlds[tld:lower()] or tld:find'^%d+$' and subd:find'^%d+%.%d+%.%d+%.$'
      and max4(tld, subd:match'^(%d+)%.(%d+)%.(%d+)%.$') &lt; 256)
   	then
      finished[pos_start] = true
      return(url)
   	end
	end

	for pos_start, url, prot, dom, colon, port, slash, path in
  	 xstring:gmatch'()((%f[%w]%a+://)(%w[-.%w]*)(:?)(%d*)(/?)([%w_.~!*:@&amp;+$/?%%#=-]*))'
	do
   if not finished[pos_start] and not (dom..'.'):find'%W%W'
      and protocols[prot:lower()] == (1 - #slash) * #path
      and (colon == '' or port ~= '' and port + 0 &lt; 65536)
   then
      return(url)
   end
	end
	
	return(false)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>ClassScripts</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>SingerScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initCtr()
	initBar()
end

function initBar()
	setSpellCount("harmonious_blessing", 3)

	charData:init("song", "")
	charData:init("_song", "")
	charData:init("effect", "")
	charData:init("_wield", 0)

	charData:init("instrument", "")

	NyyLIB.songtimer = ""
	NyyLIB.accompany = 0

	addbutton("barBless", 0, 1, 41)
	addbutton("StopMusic", 0, 2, 0)

	if charData:get("level") &gt;= 31 then
		addbutton("HealSong", 0, 3, 31)
	else
		addbutton("RegenSong", 0, 3, 1)
	end

	addbutton("HasteSong", 0, 4, 11)
	addbutton("SlowSong", 0, 5, 11)
	addbutton("HarmSong", 0, 6, 41)
	addbutton("RenewSong",0, 7, 11)
	addbutton("ProtectSong", 0, 8, 1)
	addbutton("TravelSong", 0, 9, 31)
	addbutton("Accompany", 0, 10, 20)
end

function resetSongs()

	if charData:get("level") &gt;= 31 then
		HealSong("HealSong", buttons.INIT)
	else
		RegenSong("RegenSong", buttons.INIT)
	end

	HasteSong("HasteSong", buttons.INIT)
	SlowSong("SlowSong", buttons.INIT)
	HarmSong("HarmSong", buttons.INIT)
	RenewSong("RenewSong", buttons.INIT)
	ProtectSong("ProtectSong", buttons.INIT)
	TravelSong("TravelSong", buttons.INIT)
end

function barBless(xcommand)
	shiftSkillButton("barBless", "autobless", xcommand)
end

function StopMusic(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "stopmusic.png")
	else
		mud:send("stopmusic")
	end
end

function HealSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barHeal-off.png")
	else
		mud:send("heal")
	end
end

function RegenSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barRegen-off.png")
	else
		mud:send("regen")
	end
end

function HasteSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barHaste-off.png")
	else
		mud:send("haste")
	end
end

function RenewSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barRenew-off.png")
	else
		mud:send("renew")
	end
end

function HarmSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barHarm-off.png")
	else
		mud:send("harm")
	end
end

function SlowSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barSlow-off.png")
	else
		mud:send("slow")
	end
end

function TravelSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barTravel-off.png")
	else
		mud:send("travel")
	end
end

function ProtectSong(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barProtect-off.png")
	else
		mud:send("prot")
	end
end

function Accompany(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "barAccompany-off.png")
	else
		mud:send("accompany")
	end
end

function music(xinstrument, xsong, xtarget)
	if checkMask("singer") == false then
		return
	end

	charData:set("_switch", 1)
	charData:set("new_i", xinstrument)
	switch()
	charData:set("song", xsong)
	charData:set("effect", xtarget)
	playsong()
	charData:set("_switch", 0)
end

function playsong()
 local song=charData:get("song")
 local effect=charData:get("effect")

 if song ~= "" then
   if effect == "" then
     mud:send("sing '" .. song .. "'")
   else
     mud:send("sing '" .. song .. "' " .. effect )
   end
 end
end

function switch()
 local gigbag=charData:get("gigbag")

 if charData:get("song") ~= "" then
	mud:send("play")
 end

 if charData:get("_wield") ~= 1 then
  if charData:get("instrument") ~= charData:get("new_i") then
	if charData:get("instrument") ~= '""' then
	 mud:send("rem " .. charData:get("instrument"))

	 if gigbag ~= '""' then
	 	mud:send("put " .. charData:get("instrument") .. " " .. gigbag )
    end
	 charData:set("instrument", "")
   end
 
	if charData:get("new_i") ~= '""' then
		if gigbag ~= '""' then
			mud:send("get " .. charData:get("new_i") .. " " .. gigbag )
   		end
	end

	charData:set("instrument", charData:get("new_i") )

	if charData:get("new_i") ~= '""' then
	   mud:send("hold " .. charData:get("new_i") )
	end
  end
 end
end

function tr_renew()
	music(charData:get("piccolo"), "song of renewal", "")
end

-- this function will be called on all mud prompts
function SingerScript(event)
	if checkMask("singer") then

		-- cast harmonious blessing if down and not moving
		if charData:get("autobless") then
			if not buff:get("harmonious_blessing") then
				if getSpellCount("harmonious_blessing") &gt; 0 then
					if not spell:getMoving() then
						spell:cast("hbl")
					end
				end
			end
		end

		if prompt:get("psp") == prompt:get("maxpsp") and charData:get("_switch") == 0 and not charData:get("forcerenew") then
			if charData:get("_song") ~= charData:get("song") then
				if charData:get("_song") ~= ""  and charData:get("song") ~= "" then
					cecho("&lt;red&gt;\n[Max mana : switching songs]\n")
					if charData:get("_song") == "song of harming" or charData:get("_song") == "song of offensive disruption" then
						music(charData:get("_instrument"), charData:get("_song"), charData:get("effect") )
					else
						music(charData:get("_instrument"), charData:get("_song"), "")
					end
				elseif charData:get("_song") == "" and charData:get("song") == "song of renewal" then
					--	if max psp and singing renew switch to heal (or regen)

					if charData:get("level") &gt;= 31 then
						cecho("&lt;red&gt;\n[Max mana : switching songs to heal]\n")
						music(charData:get("lute"), "song of healing", "")
					else
						cecho("&lt;red&gt;\n[Max mana : switching songs to regen]\n")
						music(charData:get("lute"), "song of regeneration", "")
					end
				end
			end
		end
	end
end</script>
					<eventHandlerList>
						<string>promptEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PsiScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initPsi()
	charData:init("autohide", false)

	spell:setMem(false)

	addbutton("MemButton", 0, 1, 0)

	if charData:get("ultraquested") ~= nil then
		addbutton("ultrablast", 0, 2, 47)
	else
		addbutton("deathfield", 0, 2, 20)
	end

	addbutton("battletrance", 0, 3, 45)
	addbutton("tower", 0, 4, 37)
	addbutton("combatmind", 0, 5, 0)
	addbutton("psidarkness", 0, 6, 35)
	addbutton("wormhole", 0, 7, 46)
end

function wormhole(fname, xcommand)
	shiftSkillButton("wormhole", "wormhole", xcommand)
end

function psidarkness(fname, xcommand)
	if xcommand ~= buttons.INIT then
		if charData:get("autohide") then
			charData:set("autohide", false)
			cecho("\n&lt;red&gt;Some illithids choose not to hide.\n")
		else
			charData:set("autohide", true)
			cecho("\n&lt;green&gt;A cautious illithid brings up darkness to hide after fleeing.\n")
		end
	end

	if charData:get("autohide") then
		setLabelImage(fname, "darkness-on.png")
	else
		setLabelImage(fname, "darkness-off.png")
	end
end

function tower(fname, xcommand)
	if xcommand ~= buttons.INIT then
		if charData:get("autotower") then
			charData:set("autotower", false)
		else
			charData:set("autotower", true)
			mud:send("tower me")
			NyyLIB.psilag="tower"
		end
	end

	if charData:get("autotower") then
		setLabelImage(fname, fname .. "-on.png")
	else
		setLabelImage(fname, fname .. "-off.png")
	end
end

function combatmind(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, fname .. "-off.png")
	else
		local cmblist = {}

		for k,char in pairs(groupList:pc("hitterSinger")) do
			if not buff:get("combatmind", char) then
				-- verify in room
				if groupList:getHP(char) ~= 0 and not table.contains(NyyLIB.deadpeople, char) then
					mud:send("combatm " .. char)
					NyyLIB.psilag="combatmb"
					break
				end
			end
		end
	end
end

function dropcombatmind()
	setLabelImage("combatmind", "combatmind-off.png")
end

function battletrance(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, fname .. "-off.png")
	else
		mud:send("battletr")
	end
end

function ultrablast(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, fname .. "-off.png")
	else
		if NyyLIB.psilag == "none" then
			setLabelImage(fname, fname .. "-on.png")
			mud:send("ultra")
			NyyLIB.psilag="ultra"
		end
	end
end

function deathfield(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, fname .. "-off.png")
	else
		if NyyLIB.psilag == "none" then
			setLabelImage(fname, fname .. "-on.png")
			mud:send("deathfield")
			NyyLIB.psilag="death"
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EncScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- note: globe blocks 1-6, needs to be 7+

function initEnc()
	addbutton("stoneskin", 0, 7, 21)
	addbutton("dragonscales", 0, 8, 46)
	addbutton("blur", 0, 9, 26)
--	addbutton("haste",10, 16)
	addbutton("globe_of_invulnerability", 0, 10, 36)

	addbutton("time_stop", 0, 11, 46)

--	addbutton("encBard",11, 0)

	addbutton("encSelf", 0, 12, 0)
	addbutton("encResize", 0, 13, 0)

	powerAliases:addButtons()
	
	--mud:send("powers info time stop")
	--mud:send("powers info blur")
	--mud:send("powers info globe")
end

function SpellsEnc()

	-- if blind, no casting
	-- will need to be altered for area offensives
	if 	buff:get("blind") or buff:get("blindness") then
		return
	end

	-- bring up timestop if not fighting

	if charData:get("autots") then
		if not inCombat() and assistSent == nil then
			if not buff:get("time_stop") then
				if getSpellCount("time_stop") &gt; 0 then
					spell:cast("ts")
					return
				end
			end
		end
	end

	-- check tank for needed spells

	if scr_tank() then
		return
	end

	if 	scr_globe() then
		return
	end

	if 	scr_scale() then
		return
	end

	-- blur group members

	if 	scr_blur() then
		return
	end

	if 	scr_stoneskin() then
		return
	end

	-- stoneskin

	if 	scr_stoneskin() then
		return
	end

	-- enlarge or reduce group members

	if 	scr_resize() then
		return
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end

	-- if fighting and no other spells - fire bolt
	if charData:get("automissile") then
		if inCombat() and spell:count() == 0 then
			spell:cast("fb")
		end
	end
end	

function time_stop(fname, xcommand)
	local current=buff:get("time_stop")

	if xcommand == buttons.UPDATE then
		if not current then
			updateButton(fname)
		end

		return
	end

	if xcommand ~= buttons.INIT then
		if charData:get("autots") then
			charData:set("autots", false)
			cecho("\n&lt;green&gt;[Time Stop will not be used.]\n")
		else
			charData:set("autots", true)
			mud:send("\n")
			cecho("\n&lt;green&gt;[Time Stop will be used.]\n")
		end
	end

	if charData:get("autots") then
		if current then
			setLabelImage(fname, "time_stop-active.png")
		else
			setLabelImage(fname, "time_stop-on.png")
		end
	else
		setLabelImage(fname, "time_stop-off.png")
	end

	if current then
		PopulateTimestop()
	else
		time_stop("time_stop", buttons.UPDATE)
	end
end

function PopulateTimestop()
	local var = buff:get("time_stop")
	local label=findlabel("time_stop")

	if var then
		label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. timedisplay(var) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])		
	else
		label:echo([[&lt;p style="font-size:14px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;   &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
	end
end

function encBard(fname, xcommand)
	shiftSkillButton("encBard", "bard", xcommand)
end

function encSelf(fname, xcommand)
	shiftSkillButton("encSelf", "self", xcommand)
end

function encResize(fname, xcommand)
	shiftSkillButton("encResize", "resize", xcommand)
end

function scr_tank()
	local tank=prompt:get("tank")

	if tank == nil or tank == "" then
		return
	end

	if charData:get("level") &gt;= 26 then
		if spell:attempt(tank, "blur", "bl") then
			return(true)
		end
	end

	if charData:get("level") &gt;= 46 then
		if spell:attempt(tank, "dragonscales", "ds") then
			return(true)
		end
	end
end

function scr_resize()
	local tmpvar = charData:get("resize")

	if tmpvar == "small" or tmpvar == "all" then
		for k,char in pairs(groupList:pc("casterSinger")) do
			if table.contains( {"Halfling", "Gnome"}, whorace(char) ) then
				if consent:get(char) then
					if spell:attempt(char, "reduce", "red") then
						return(true)
					end
				end
			end
		end
	end

	if tmpvar == "large" then
		for k,char in pairs(groupList:pc("casterSinger")) do
			if consent:get(char) then
				if spell:attempt(char, "enlarge", "enl") then
					return(true)
				end
			end
		end
	end
	
	if tmpvar == "all" then
		for k,char in pairs(groupList:pc("war")) do
			if whorace(char) == "Ogre" then
				if consent:get(char) then
					if spell:attempt(char, "enlarge", "enl") then
						return(true)
					end
				end
			end
		end
	end	
end

function scr_globe()
	if charData:get("autoglobe") == true then
		for k,char in pairs(groupList:pc()) do
			if checkMask("hitter", char ) then
				if spell:attempt(char, "globe_of_invulnerability", "gi") then
					return(true)
				end
			end

			if charData:get("bard") and checkMask("singer", char ) then
				if spell:attempt(char, "globe_of_invulnerability", "gi") then
					return(true)
				end
			end
		end

		for k,char in pairs(groupList:pc("war")) do
			if spell:attempt(char, "globe_of_invulnerability", "gi") then
				return(true)
			end
		end
	elseif charData:get("autoglobe") == "hitters" then
		for k,char in pairs(groupList:pc()) do
			if checkMask("hitter", char ) then
				if spell:attempt(char, "globe_of_invulnerability", "gi") then
					return(true)
				end
			end
		
			if whoclass(char) == "War" and whorace(char) == "Ogre" then
				if spell:attempt(char, "globe_of_invulnerability", "gi") then
					return(true)
				end
			end

			if charData:get("bard") and checkMask("singer", char ) then
				if spell:attempt(char, "globe_of_invulnerability", "gi") then
					return(true)
				end
			end
		end
	end
end

function scr_blur()
	if charData:get("autoblur") then
		for k,char in pairs(groupList:pc("casterPsiSinger")) do
			if char ~= whoami() then
				if spell:attempt(char, "blur", "bl") then
					return(true)
				end
			end
		end
	end

	for k,char in pairs(groupList:pc("warrior")) do
		if spell:attempt(char, "blur", "bl") then
			return(true)
		end
	end

	if charData:get("self") then
		if spell:attempt(whoami(), "blur", "bl") then
			return(true)
		end
	end

	
	local wuss=charData:get("wuss")

	if groupList:ingroup( wuss ) then
		if spell:attempt(wuss, "blur", "bl") then
			return(true)
		end
	end
end

function scr_scale()
	local wuss=charData:get("wuss")

	if groupList:ingroup( wuss ) then
		if spell:attempt(wuss, "dragonscales", "ds") then
			return(true)
		end
	end

	if charData:get("self") then
		if spell:attempt(whoami(), "dragonscales", "ds") then
			return(true)
		end
	end

	for k,char in pairs(groupList:pc("warrior")) do
		if spell:attempt(char, "dragonscales", "ds") then
			return(true)
		end
	end

	if charData:get("autoscale") then
		for k,char in pairs(groupList:pc("casterPsiSinger")) do
			if char ~= whoami() then
				if spell:attempt(char, "dragonscales", "ds") then
					return(true)
				end
			end
		end
	end
end

function scr_haste()
	-- placeholder
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>WarScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initWar()
	addbutton("vigilant_protector", 0, 11, 25)

	meleePowers:addButtons()
end

function procPromptWar()
	if getBashing() then
		return
	end

	-- can't cast or use powers if stunned, parad, in fugue, etc
	if not spell:castOK() then
		return
	end

	-- blinded. venom (heroic defiance to heal)

	if buff:get("blind") or buff:get("blindness") or buff:get("venom") then
		useMeleePower("hd", true)
		return
	end

	-- melee powers

	-- taunts : need to change usage - should be after spells, not before

	if meleePowers:use("cc") then return end -- combat challenge

	-- 1h/shield melee powers
	if equip:getWeapon() == "Shield" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("sb") then return end -- shield bash
			end
		end

		if meleePowers:use("ds") then return end -- defensive strike
		if meleePowers:use("bs") then return end -- brutal strike
		if meleePowers:use("ra") then return end -- relentless assault
		if meleePowers:use("cs") then return end -- comeback strike
	end

	-- 2h powers
	if equip:getWeapon() == "TwoHand" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("ss") then return end -- spinning sweep
			end
		end

		if meleePowers:use("sk") then return end -- skullcrusher
		if meleePowers:use("cv") then return end -- cleave
		if meleePowers:use("ua") then return end -- unyielding avalanche
		if meleePowers:use("ros") then return end -- rain of steel
	end
end

-- 'SpellsWar' is the special effect warrior skills

function SpellsWar()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp

	-- blind, venom : heroic defiance
	if (buff:get("blind") or buff:get("blindness") or buff:get("venom") ) then
			useMeleePower("hd", true)
	end

	-- The following skills are only used in combat

	if not inCombat() then
		return
	end
	
	-- iron warrior
	
	if percent &lt; .7 then
		if charData:get("wariw") then
			if timer:get("iron_warrior") == nil then
				useMeleePower("iw", true)
			end
		end
	end
	
	-- warrior heal - unstoppable (ut)
	if percent &lt; .5 then
		if charData:get("warut") then
			if timer:get("unstoppable") == nil then
				useMeleePower("ut", true)
			end
		end
	end

	-- unbreakable
	
	if percent &lt; .8 then
		if charData:get("warub") then
			if timer:get("unbreakable") == nil then
				useMeleePower("ub", true)
			end
		end
	end

	-- diamond shield defense
	
	if charData:get("wardsd") then
		if timer:get("diamond_shield_defense") == nil then
			useMeleePower("dsd", true)
		end
	end

	-- storm of destruction
	
	if charData:get("warsod") then
		if timer:get("storm_of_destruction") == nil then
			useMeleePower("sod") -- added cooldown to sod
		end
	end
end

function vigilant_protector(fname, xcommand)
	if xcommand == buttons.INIT then
		if charData:get("warvip") then
			setLabelImage(fname, fname .. "-on.png")
		else
			setLabelImage(fname, fname .. "-off.png")
		end
		return
	end
		
	if xcommand == buttons.CLICK then
		shiftSkillButton(fname, "warvip", xcommand)
	
		if charData:get("warvip") then
			if groupList:ingroup( charData:get("wuss") ) then
				mud:send("VIP " .. charData:get("wuss"))
			end
		else
			mud:send("VIP off")
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ShaScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initSha()
	addbutton("group_heal", 0, 4, 41)
	addbutton("ancestral_shield", 0, 11, 46)
	addbutton("stoneskin", 0, 10, 26)

	addbutton("encSelf", 0, 12, 0)

	powerAliases:addButtons()

	--mud:send("powers info vit")
end

-- this function will be called when shaman should cast
function SpellsSha()
	-- i'm blind: gheal, or cast heal on me if none left
	if buff:get("blind") or buff:get("blindness") then
		--display("X")
		if getSpellCount("group_heal") &gt; 0 then
			spell:cast("gh")
		else
			if getSpellCount("heal") &gt; 0 then
				spell:cast("HL")
			end
		end

		return
	end

	-- check if anyone blind
	for k,char in pairs(groupList:pc()) do
		if buff:get("blind", char) or buff:get("blindness", char) then
			--display("Y")
			if charData:get("autogh") then
				if getSpellCount("group_heal") &gt; 0 then
					spell:cast("gh")
					return
				end
			end
		end
	end

	-- earthquakes
	if castQuake() then
		return
	end

	-- stone if not stoned/scaled
	if scr_stoneskin(true) then
		return
	end

	-- group heal if multiple characters damaged
	local damaged=0
	for k,char in pairs(groupList:pc()) do
		local hp=tonumber(groupList:getHP(char))
		local maxhp= tonumber(groupList:getMaxHP(char))
		local percent = hp/maxhp

		if hp &lt; .9 * maxhp then
			damaged = damaged + 1
		end
	end
	
	if damaged &gt;= 3 and getSpellCount("group_heal") &gt; 0 and charData:get("autogh") then
		spell:cast("gh")
		return
	end

	-- stone remaining characters
	if scr_stoneskin() then
		return
	end

	-- vit self if needed / autovit enabled

	if charData:get("autovit") and charData:get("level") &gt;= 21 then
		if spell:attempt(whoami(), "vitality", "vt") then
			return
		end
	end
	
	-- cast heal on self?

	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp

	if percent &lt; .8 then
		if getSpellCount("group_heal") &gt; 0 and charData:get("autogh") then
			spell:cast("gh")
			return
		end

		if getSpellCount("hl") &gt; 0 then
			spell:cast("hl me")
			return
		end
	end


-- heal spirit - this will happen regardless of in or out of combat
	if charData:get("autoheal") and pet:status("spirit") then
		local petname=pet:getTable("spirit")[1]
		
		if pet:getHP(petname) &lt; .8 * pet:getMaxHP(petname) and pet:getInRoom(petname) then
				if getSpellCount("hl") &gt; 0 then
					spell:cast("hl " .. petname)
					return
				end
		end
	end

	-- ancestral shield
	if charData:get("autoashield") then
		if not buff:get("ancestral_shield") then
			if getSpellCount("ancestral_shield") &gt; 0 then
				spell:cast("ash")
				return
			end
		end
	end

	-- queue vitality
	if charData:get("autovit") and charData:get("level") &gt;= 21 then
		if scr_vitality() then
			return
		end
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end
end

function hex(fname, xcommand)
	if xcommand == buttons.UPDATE then
		updateButton(fname)
		return
	end

	if xcommand == buttons.INIT then
		setLabelImage(fname, "hex-off.png")
		hex("hex", buttons.UPDATE)
	else
		spell:cast("hex")
	end
end

function silence_person(fname, xcommand)
	if xcommand == buttons.UPDATE then
		updateButton(fname)
		return
	end

	if xcommand == buttons.INIT then
		setLabelImage(fname, "silence_person-off.png")
		silence_person(fname, buttons.UPDATE)
	else
		spell:cast("sp")
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>CleScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initCle()

	addbutton("greater_realm_of_protection", 0, 3, 46)

	--	addbutton("silence_person",9, 26)

	addbutton("resurrect", 0, 4, 46)

	powerAliases:addButtons()

--	if whoami() ~= nil then
--		if whorace(whoami()) ~= nil then
--			if whorace(whoami()) == "Yuan-Ti" then
--				addbutton("scale_skin", 13, 1)
--			end
--		end
--	end

	--mud:send("powers info vit")
end

function SpellsCle()
	-- this script will only be called if autocast enabled

	if buff:get("blind") or buff:get("blindness") then
		--display("i'm blind")
		if prompt:get("hp") &lt; .9 * prompt:get("maxhp") then
			if getSpellCount("full_heal") &gt; 0 then
				--display("fh")
				spell:cast("fh")
				return
			end
		end

		if getSpellCount("cure_blind") &gt; 0 then
			--display("cb")
			spell:cast("cb")
			return
		end

		if getSpellCount("full_heal") &gt; 0 then
			--display("fh2")
			spell:cast("fh")
			return
		end
	end

	-- queue purify/etc
	if procClericPurify() then
		return
	end

	-- earthquakes
	if castQuake() then
		return
	end

	-- healing aura main tank if injured
	if charData:get("autoheal") then
		if NyyLIB.mtank ~= nil then
			local char=NyyLIB.mtank
			local hp=tonumber(groupList:getHP(char))
			local maxhp= tonumber(groupList:getMaxHP(char))
			local percent = hp/maxhp

			if getSpellCount("healing_aura") &gt; 0 and percent &lt; .7 and not buff:get("healing_aura", char) then
				spell:cast("ha " .. char)
				return
			end
		end
	end

	-- queue vitality
	if charData:get("autovit") and charData:get("level") &gt;= 21 then
		if 	scr_vitality() then
			return
		end
	end

	-- queue any needed heals
	if charData:get("autoheal") then
		if procClericHeal() then
			return
		end
	end

	-- scaleskin
	procYuanInnates()

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end

	if procClericRealm() then
		return
	end

	-- process cast/send queue if not currently casting
	--if spell:getCurrent() == nil then
	--	spell:cast()
	--end
end

function procYuanInnates()
	if charData:get("yuan") then
		if not charData:get("scaleskin") then
			mud:send("innate scaleskin")
		end
	end
end

function procClericHeal()
	-- Cleric heal event

	-- healing aura needs to be manually added to buffs
	-- otherwise, ha already present on self and damaged cleric (self) will stop moving further on script

	local ha_count=getSpellCount("healing_aura")
	local fh_count=getSpellCount("full_heal")

	if prompt:get("hp") &lt; .8 * prompt:get("maxhp") then
		-- first choice = healing aura if &lt; .8 hp
		if ha_count &gt; 0 then
			if not buff:get("healing_aura") then
				echoDebug("\n&lt;red&gt;[que ha on self]\n")
				spell:cast("ha " .. whoami())
				return(true)
			end
		end

		-- alternate choice = full heal if no aura and &lt; .65 hp
		if fh_count &gt; 0 and (prompt:get("hp") &lt; .65 * prompt:get("maxhp")) then
			echoDebug("\n&lt;red&gt;[que fh on self]\n")
			spell:cast("fh")
			return(true)
		end
	end

	for k,char in pairs(groupList:pc()) do
		local hp=tonumber(groupList:getHP(char))
		local maxhp= tonumber(groupList:getMaxHP(char))
		local percent = hp/maxhp

		if spell:getCurrent() ~= ("fh " .. char) then
			if getSpellCount("full_heal") &gt; 0 then
				if hp &lt; .75 * maxhp then
					echoDebug("\n&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting fh on " .. char .. "]")
					spell:cast("fh " .. char)
					return(true)

				elseif percent &lt; .8 and whoclass(char) == "War" then
					echoDebug("\n&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting ha on " .. char .. "]")

					if getSpellCount("healing_aura") &gt; 0 then
						spell:cast("ha " .. char)
						return(true)
					end
				end
			end
		end
	end

	-- healing aura tank at few wounds
	if prompt:get("tankcondition") == "few wounds" then
		if getSpellCount("healing_aura") &gt; 0 then
			spell:cast("ha " .. prompt:get("tank"))
			return(true)
		end
	end

	-- full heal anyone at &lt; .6 maxhp

	for k,char in pairs(groupList:pc()) do
		local hp=tonumber(groupList:getHP(char))
		local maxhp= tonumber(groupList:getMaxHP(char))

		if spell:getCurrent() ~= ("fh " .. char) then
			if getSpellCount("full_heal") &gt; 0 then
				if hp &lt; .6 * maxhp then
					echoDebug("&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting fh on " .. char .. "]")
					spell:cast("fh " .. char)
					return(true)
				end
			end
		end
	end

	return(false)
end

function procClericRealm()
	-- Greater Realm Of Protecti ( 43:59)   

	if charData:get("autorealm") then
		for k,char in pairs(groupList:pc()) do
			if getSpellCount("greater_realm_of_protection") &gt; 0 then
				if char ~= "wolf" and char ~= "drider" then
					if not buff:get("greater_realm_of_protecti", char) and groupList:getHP(char) ~= 0 then
						spell:cast("realm " .. char)
						return(true)
					end
				end
			end
		end
	end

	return(false)
end

function procClericPurify()
	-- check for anyone paralyzed
	for k,char in pairs(groupList:pc()) do
		if buff:get("minor_paralysis", char) or buff:get("major_paralysis", char) then
			if charData:get("autopurify") then
				if getSpellCount("divine_purification") &gt; 0 then
					spell:cast("dpu " .. char)
					return(true)
				end
			end
		end
	end

	-- check for anyone blinded
	for k,char in pairs(groupList:pc()) do
		local hp=tonumber(groupList:getHP(char))
		local maxhp= tonumber(groupList:getMaxHP(char))
		local percent = hp/maxhp

		if buff:get("blind", char) or buff:get("blindness", char) then
			if charData:get("autocb") then
				if char == whoami() then
					if percent &lt; .9 then
						if getSpellCount("heal") &gt; 0 then
							spell:cast("hl")
							return(true)
						end
					end

					spell:cast("cb")
					return(true)
				else

					if percent &lt; .9 then
						if getSpellCount("hl") &gt; 0 then
							spell:cast("hl " .. char)
							return(true)
						end
					end

					spell:cast("cb " .. char)
					return(true)
				end
				return(false)
			end
		end
	end
end

function scr_vitality()
	local var=buff:get("vitality") or 0

	if getSpellCount("vitality") == 0 then
		return
	end

	if var == 0 then
		spell:cast("vt " .. whoami())
		return(true)
	end

	if charData:get("autovit") then
		local vit=charData:get("vit")

		--echoDebug("&lt;red&gt;[Queuing vitality for: " .. vit .. "]\n")

		for k,char in pairs(groupList:pc(vit)) do
			-- don't vit dead people
			if table.contains(NyyLIB.deadpeople, char) == false then
				if groupList:getHP(char) ~= 0 then
					var=buff:get("vitality", char) or 0

					if var == 0 then
						spell:cast("vt " .. char)
						return(true)
					end
				end
			end
		end
	end
end

function scale_skin(fname, xcommand)
	-- innate vipermind, scaleskin

	if xcommand == buttons.UPDATE then
--		updateButton(fname)
		return
	end

	if xcommand ~= buttons.INIT then
		if charData:get("yuan") then
			charData:set("yuan", false)
		else
			charData:set("yuan", true)
		end
	end

	if charData:get("yuan") then
		setLabelImage(fname, "scale_skin-on.png")
	else
		setLabelImage(fname, "scale_skin-off.png")
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MiscButtons</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function baseButtons()
	addbutton("ticktimer", 0, 0.2, 0, "4c", "2c")
	addbutton("mysizeDisplay", 0, 0.6, 0, "3c", "2c")

	-- non-class specific buttons at far right

	if checkMask("fighter") and not checkMask("ran") then
		addbutton("autotank", 0, 16, 0, "2.4%")
	end


	addbutton("chkstat", 0, 17, 0, "2.4%")
	addbutton("flee", 0, 17.5, 0, "2.4%")
	addbutton("autoassist", 0, 18, 0, "2.4%")
	addbutton("autoloot", 0, 18.5, 0, "2.4%")	
	addbutton("autoopen", 0, 19, 0, "2.4%")	
	addbutton("autoportal", 0, 19.5, 0, "2.4%")	
	
	if checkMask("petrescue") then
		addbutton("pet_rescue", 0, 15, 1)
	end

	-- buttons at the bottom

	if checkMask("fighter") and not checkMask("ran") then
		addbutton("rescue", 0, 4, 1)
	end
 
	if checkMask("ran") or checkMask("pal") or checkMask("war") then
		addbutton("SpellsButton", 0, 16.5, 0, "2.4%")
	end
	
	if checkMask("caster") or checkMask("nonPriestCaster") then 
		addbutton("SpellsButton", 0, 16.5, 0, "2.4%")
		addbutton("MemButton", 0, 1, 0)
	end

	if whoclass() == "Rog" then
		-- removed disarm button
		--addbutton("DisarmButton", 0, 11, 10)	
	end

	if checkMask("summonmount") then
		addbutton("SummonMount", 0, 10, 15)
	end


	-- faerie fire

	if checkMask("ffire") then
		addbutton("faerie_fire", 0, 14, 6)
	end



	-- xp display window

	if NyyLIB.xpwindow == nil then
		NyyLIB.xpwindow = Geyser.Label:new({name="xpwin", x=0, y=0, width="160px", height="32px"})
	end

	if charData:get("level") == 50 then
		NyyLIB.xpwindow:show()
		NyyLIB.xpwindow:hide()
	else
		NyyLIB.xpwindow:show()
	end

	-- vote button

	charData:init("vote", 0, true)
	charData:set("vote", charData:get("vote", true)+1, true)

	if charData:get("vote", true) &gt; 10 then
		NyyLIB.votewindow = Geyser.Label:new({name="vote", x=0, y=0, width="225px", height="125px"})
		NyyLIB.votewindow:setClickCallback("mudvote")
		NyyLIB.votewindow:setStyleSheet([[border-image: url(]] .. iconpath("vote.png") .. [[)]])

		checkVoteButton()
	end
end

function pet_rescue(fname, xcommand)
	shiftSkillButton("pet_rescue", "petrescue", xcommand)
end

function ticktimer()
	return
end

function checkVoteButton()
	local val=getTime()

	if NyyLIB.votewindow ~= nil then
		if charData:get("lastvote", true) ~= nil	then
			if val.day == charData:get("lastvote", true) then
				NyyLIB.votewindow:show()
				NyyLIB.votewindow:hide()
			else
				NyyLIB.votewindow:show()
			end
		end
	end
end

function SummonMount(fname, xcommand)
	local label=findlabel(fname)

	if xcommand ~= buttons.INIT then
		mud:send("summon mount")
	end

	setLabelImage(fname, "summon_mount.png")
end

function MountDismount(fname, xcommand)
	local label=findlabel(fname)

	if xcommand ~= buttons.INIT then
		if mount:getMounted() then
			mud:send("dismount")
		else
			mud:send("mount")
		end
	end

	if mount:getMounted() then
		setLabelImage(fname, "dismount.png")
	else
		setLabelImage(fname, "mount.png")
	end
end

function MemButton(fname, xcommand)
	local label=findlabel(fname)

	if xcommand == buttons.UPDATE then
		if label ~= nil then
			charData:init("memcount", 0)

			if spell:getMem() then
				if charData:get("memcount") ~= 0 then
					label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. charData:get("memcount") .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
				else
					label:clear()
					spell:setMem(false)
				end
			else
				MemButton(fname, buttons.INIT)
			end
		end
		return
	end

	if xcommand == buttons.INIT then
		echoDebug("&lt;red&gt;[Setting membutton to mem/med/pray]")

		if label ~= nil then
			label:clear()
		end

		if checkMask("psi") then
			setLabelImage(fname, "psiMeditate.png")
		elseif checkMask("priest") or checkMask("pray") then
			setLabelImage(fname, "pray.png")
		else
			setLabelImage(fname, "encMem.png")
		end
	else
		if checkMask("psi") then
			if spell:getMem() then
				setLabelImage(fname, "psiMeditate.png")
				mud:send("ST")			
			else
				setLabelImage(fname, "stand.png")
				mud:send("mem")
			end
		else
			if not spell:getMem() then
				mud:send("mem")
			else
				spell:setMem(false)
				mud:send("ST")
			end
		end
	end
end

function SpellsButton(fname, xcommand)
	if xcommand ~= buttons.INIT then
		if charData:get("autocast") then
			charData:set("autocast", false)
			cecho("&lt;red&gt;[Autocasting and Automem are disabled.]\n")
			spell:clear()
		else
			charData:set("autocast", true)
			cecho("&lt;green&gt;[Autocasting and Automem are enabled.]\n")
			spell:setMoving(false)
			mud:send("\n")
		end
	end

	if charData:get("autocast") then
		setLabelImage(fname, "SpellsButton-on.png")
	else
		setLabelImage(fname, "SpellsButton-off.png")
	end
end

function mudvote()
	local val=getTime()

	openUrl("http://www.topmudsites.com/vote-shev.html")
	openUrl("http://www.mudconnect.com/cgi-bin/vote_rank.cgi?mud=TorilMud,+the+Sojourner%27s+Home")
	charData:set("lastvote", val.day, true)
	NyyLIB.votewindow:show()
	NyyLIB.votewindow:hide()
end

function mysizeDisplay(fname, xcommand)
	local fname="mysizeDisplay"
	local mysize = whosize()

	if mysize ~= nil then
		charData:init("bodysize", mysize)
	else
		charData:init("bodysize", "M")
	end

	local tmpvar=charData:get("bodysize")

	if tmpvar == "T" then
		setLabelImage(fname, "sizet.png")
	elseif tmpvar == "S" then
		setLabelImage(fname, "sizes.png")
	elseif tmpvar == "M" then
		setLabelImage(fname, "sizem.png")
	elseif tmpvar == "L" then
		setLabelImage(fname, "sizel.png")
	elseif tmpvar == "H" then
		setLabelImage(fname, "sizeh.png")
	end
end

function autoportal(fname, xcommand)
	shiftSkillButton("autoportal", "autoportal", xcommand)
end

function autoopen(fname, xcommand)
	shiftSkillButton("autoopen", "autoopen", xcommand)
end

function autoassist(fname, xcommand)
	shiftSkillButton("autoassist", "autoassist", xcommand)
end

function autotank(fname, xcommand)
	shiftSkillButton("autotank", "autotank", xcommand)
end

function flee(fname, xcommand)
	shiftSkillButton("flee", "flee", xcommand)
end

function chkstat(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "chkstat.png")
	else
		mud:send("@chkstat")
	end
end

function autoloot(fname, xcommand)
	shiftSkillButton("autoloot", "autoloot", xcommand)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>RogScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initRog()
	addbutton("assassinate", 0, 1, 40)
	addbutton("trip", 0, 2, 25)
	addbutton("circle", 0, 3, 5)
	addbutton("autohide", 0, 6, 1)
	addbutton("poisonRogue", 0,	11, 20)

end

function setTripping(xval)
	tripping = xval
end

function getTripping()
	if tripping == nil then
		tripping=false
	end

	return(tripping)
end

function sendTrip()
	if timer:get("wraithform") or timer:get("notrip") then
		return
	end
	
	
	-- can only trip if standing

	if not prompt:get("position") == "std" then
		return
	end

	-- can't trip if stunned

	if buff:get("stun") then
		return
	end

	if not getTripping() then
		cecho("&lt;green&gt;\n[trip]\n")

		mud:send("trip")

		setTripping(true)
	end
end

function sendAssassinate(xtarget)
	if charData:get("autoassassinate") then
		if timer:get("assassinatetimer") == nil and charData:get("level") &gt; 39 then
			timer:set("assassinatetimer", 25*60)

			if xtarget == nil then
				cecho("&lt;red&gt;[Assassinate target is nil]\n")
				return(false)
			end

			mud:send("ASSASSINATE " .. xtarget)
			look:send()
			return(true)
		end
	end

	return(false)
end

function sendPoison()
	if charData:get("autopoison") then
		local primaryp=charData:get("primaryp")
		local secondaryp=charData:get("secondaryp")
		local poisonbag = charData:get("poisonbag")

		if primaryp ~= "" then
			
			--  apply &lt;poison&gt; &lt;weapon_name&gt; &lt;container&gt;

			mud:send("apply " .. primaryp .. " primaryweapon " .. poisonbag)
		end

		if secondaryp ~= "" then
			mud:send("apply " .. secondaryp .. " secondaryweapon " .. poisonbag)
		end
	end
end

function assassinate(fname, xcommand)
	shiftSkillButton("assassinate", "autoassassinate", xcommand)
end

function trip(fname, xcommand)
	shiftSkillButton("trip", "autotrip", xcommand)
end

function autohide(fname, xcommand)
	shiftSkillButton("autohide", "autohide", xcommand)
end

function circle(fname, xcommand)
	shiftSkillButton("circle", "autocircle", xcommand)
end

function poisonRogue(fname, xcommand)
	shiftSkillButton("poisonRogue", "autopoison", xcommand)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EleScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initEle()
	addbutton("stoneskin", 0, 7, 26)
	addbutton("elemental_ward", 0, 8, 46)
	addbutton("glitterdust", 0, 9, 21)
	addbutton("haste", 0, 10, 31)

	powerAliases:addButtons()
end

function SpellsEle()
	if scr_stoneskin(true) then
		return
	end

	local wuss=charData:get("wuss")

	if groupList:ingroup( wuss ) then
		if spell:attempt(wuss, "elemental_earth_embodiment", "eee") then
			return(true)
		end
	end

	if scr_ward() then
		return
	end

	if charData:get("autoblind") then
		if inCombat() and spell:count() == 0 then
			if getSpellCount("glitterdust") &gt; 0 then
				spell:cast("gl")
				return
			end
		end
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end
end

function scr_ward()
	if charData:get("autoward") == true then
		for k,char in pairs(groupList:pc()) do
			if checkMask("hitter", char ) then
				if spell:attempt(char, "elemental_ward", "ew") then
					return(true)
				end
			end
		
			if whoclass(char) == "War" then
				if spell:attempt(char, "elemental_ward", "ew") then
					return(true)
				end
			end

			if whoclass(char) == "Bar" then
				if spell:attempt(char, "elemental_ward", "ew") then
					return(true)
				end
			end
		end
	end
end


function scr_stoneskin(xfirsttime)

	if charData:get("self") then
		-- stone self if not stoned/scaled
		if not buff:get("stoneskin") and not buff:get("dragonscales") then
			if getSpellCount("stoneskin") &gt; 0 then
				spell:cast("ss")
				return
			end
		end
	end

	if charData:get("autostone") == "off" then
		return
	end

	--local wuss=charData:get("wuss")

	--if groupList:ingroup( wuss ) then
	--	if spell:attempt(wuss, "stoneskin", "ss") then
	--		return(true)
	--	end
	--end

	-- in combat, no other spells queued
	if charData:get("autostone") == "tanks" then
		if inCombat() and spell:count() == 0 then
			local tank=prompt:get("tank")

			if not (tank == nil or tank == "") then
				if charData:get("level") &gt;= 31 then
					if spell:attempt(tank, "stoneskin", "ss") then
						return(true)
					end
				end
			end
		end
	end

	if charData:get("autostone") == "rogues" then
		for k,char in pairs(groupList:pc("hitterToRescue")) do
			if spell:attempt(char, "stoneskin", "ss") then
				return(true)
			end
		end
	end

	if charData:get("autostone") == "all" then
		for k,char in pairs(groupList:pc("all")) do
			if spell:attempt(char, "stoneskin", "ss") then
				return(true)
			end
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>NecScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initNec()
	addbutton("protection_from_undead", 0, 7, 6)
	addbutton("globe_of_invulnerability", 0, 10, 41)
	addbutton("haste", 0, 11, 31)

	addbutton("banshee_wail", 0, 13, 46)
	addbutton("SoulShackleButton", 0, 14, 36)

	powerAliases:addButtons()
end

function SpellsNec()
	if charData:get("autopfu") then
		if scr_pfu() then
			return
		end
	end

	-- powers pfu spectre whether enabled or not
	if pet:status("spectre") then
		local petname= pet:getTable("spectre")[1]

		if not buff:get("protection_from_undead", petname) and pet:getInRoom(petname) then
			if getSpellCount("protection_from_undead") &gt; 0 then
				spell:cast("pfu " .. petname)
				buff:set(petname, "protection_from_undead", 15)
				return
			end
		end
	end

	if 	scr_globe() then
		return
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>LicScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initLic()
	addbutton("protection_from_undead", 0, 7, 6)
	addbutton("death_pact", 0, 9, 46)
	addbutton("globe_of_invulnerability", 0, 10, 41)
	addbutton("haste", 0, 11, 31)

	addbutton("banshee_wail", 0, 13, 46)
	addbutton("SoulShackleButton", 0, 14, 36)

	powerAliases:addButtons()
end

function SpellsLic()

	-- healing - this will happen regardless of in or out of combat
	if charData:get("autoheal") then
		-- if in combat and less then .75hp heal self
		if inCombat() and prompt:get("hp") &lt; .75 * prompt:get("maxhp") then
			if getSpellCount("heal_undead") &gt; 0 then
				spell:cast("hu " .. whoami())
				return
			end

			-- use lifedrain if no heal undead left
			if charData:get("autohlmissile") then
				if getSpellCount("life_drain") &gt; 0 then
					spell:cast("ld")
					return
				end
			end
		end

		-- if not in combat and less then .95hp heal self
		if not inCombat() and prompt:get("hp") &lt; .95 * prompt:get("maxhp") then
			if getSpellCount("heal_undead") &gt; 0 then
				spell:cast("hu " .. whoami())
				return
			end
		end
	end

	if charData:get("autopfu") then
		if scr_pfu() then
			return
		end
	end

	-- powers pfu spectre whether enabled or not
	if pet:status("spectre") then
		local petname= pet:getTable("spectre")[1]

		if not buff:get("protection_from_undead", petname) and pet:getInRoom(petname) then
			if getSpellCount("protection_from_undead") &gt; 0 then
				spell:cast("pfu " .. petname)
				buff:set(petname, "protection_from_undead", 15)
				return
			end
		end
	end

	if charData:get("autopact") then
		if spell:attempt(whoami(), "death_pact", "dp") then
			return(true)
		end
	end

	if 	scr_globe() then
		return
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end
end

-- loop through all casters and over them to cast

function undeadPetCast()
	if timer:get("petcast") or nomagic then
		return
	end

	for k, petname in pairs( pet:getCasterTable() ) do
		ghost_globe(petname)
		undeadSpell(petname)
	end
end

function undeadSpell(xcaster)
	-- spells to cast in or outside combat
	for k,v in pairs(pet:getTable()) do
		if pet:getMaxHP(v) ~= nil and pet:getHP(v) ~= nil and pet:getInRoom(v) and pet:isUndead(v) then
			if pet:getMaxHP(v) - pet:getHP(v)  &gt; 100 then
				mud:send("ORDER " .. xcaster .. " cast 'heal undead' " .. v)
				timer:set("petcast", 6)
				pet:setHP(v, pet:getHP(v)+100)
				return
			end
		end
	end

	-- self-buffing undead pets

	-- haste spectre
	if pet:status("spectre") then
		local petname= pet:getTable("spectre")[1]

		if not buff:get("haste", petname) and pet:getInRoom(petname) then
			mud:send("ORDER " .. xcaster .. " cast 'haste' " .. petname )
			timer:set("petcast", 6)
			buff:set(petname, "haste", 15)
			return
		end
	end

	-- caster undead - keep globed
	if pet:status("wraith") or pet:status("ghost") then
		if not buff:get("globe_of_invulnerability", xcaster) then
			mud:send("ORDER " .. xcaster .. " cast 'globe of invulnerability' " .. xcaster)
			timer:set("petcast", 6)
			buff:set(xcaster, "globe_of_invulnerability", 60)
			return
		end
	end

	-- these spells should only be cast in combat
	if inCombat() then
		if pet:status("ghost") then
			if charData:get("autowail") then
				if not (spell:getCast())["bw"] then
					mud:send("ORDER " .. xcaster .. " cast 'banshee wail'")
					spell:setCast("bw")
					timer:set("petcast", 6)
					return
				end
			end

			if charData:get("autohlarea") then
				mud:send("ORDER " .. xcaster .. " cast 'rain of blood'")
				timer:set("petcast", 6)
				return
			end

			mud:send("ORDER " .. xcaster .. " cast 'boneshatter' " .. prompt:get("enemy") )
			timer:set("petcast", 6)
		end	

		if pet:status("wraith") then
			mud:send("ORDER " .. xcaster .. " cast 'abi dalzims'")
			timer:set("petcast", 6)
		end
	
		if pet:status("shadow") then
			mud:send("ORDER " .. xcaster .. " cast 'magic missile'")
			timer:set("petcast", 6)
		end
	else
		-- These spells are cast if not in combat

		-- vampiric touch (shadow can't cast)
		if pet:status("wraith") or pet:status("ghost") then
			if not buff:get("vampiric_touch", xcaster) then
				mud:send("ORDER " .. xcaster .. " cast 'vampiric touch'")
				timer:set("petcast", 6)
				buff:set(xcaster, "vampiric_touch", 60)
				return
			end
		end

		-- coldshield (shadow can't cast)
		if pet:status("wraith") or pet:status("ghost") then
			if not buff:get("coldshield", xcaster) then
				mud:send("ORDER " .. xcaster .. " cast 'coldshield'")
				timer:set("petcast", 6)
				buff:set(xcaster, "coldshield", 60)
				return
			end
		end
	end
end


function SoulShackleButton(fname, xcommand)
	if xcommand == buttons.INIT then
		setLabelImage(fname, "soul_shackles-off.png")
	else
		spell:setNext("ssh")
	end
end

function ghost_globe(xcaster)
	-- spells will be set to short times when order submited to cast. This will prevent multiple casting attempts
	if charData:get("autoglobe") then
		-- can only have 1 spectre + caster undead
		if pet:status("spectre") then
			local petname= pet:getTable("spectre")[1]

			if not buff:get("globe_of_invulnerability", petname) and pet:getInRoom(petname) then
				mud:send("ORDER " .. xcaster .. " cast 'globe of invulnerability' " .. petname )
				timer:set("petcast", 6)
				buff:set(petname, "globe_of_invulnerability", 15)
				return
			end
		end


		for k,char in pairs(groupList:pc("hitter")) do
			local hp=tonumber(groupList:getHP(char))

			if not buff:get("globe_of_invulnerability", char) and hp ~= 0 then
				mud:send("ORDER " .. xcaster .. " cast 'globe of invulnerability' " .. char )
				timer:set("petcast", 6)
				buff:set(char, "globe_of_invulnerability", 15)
				return
			end
		end
	end
end

function scr_pfu()
	for k,char in pairs(groupList:pc("all")) do
		if spell:attempt(char, "protection_from_undead", "pfu") then
			return(true)
		end
	end

	return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>InvScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initInv()
	powerAliases:addButtons()
end

function SpellsInv()

	-- if fighting - sandstorm
	if charData:get("autostorm") and not timer:get("sandstorm") then
		if getSpellCount("sandstorm") &gt; 0 then
			if inCombat() and spell:count() == 0 then
				spell:cast("ss")
			end
		end
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end

	-- if fighting and no other spells - ray of frost
	if charData:get("automissile") then
		if inCombat() and spell:count() == 0 then
			spell:cast("rf")
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>IllScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initIll()
	powerAliases:addButtons()

	addbutton("displacement", 0, 7, 26)
	addbutton("doppleganger", 0, 9, 31)
	-- addbutton("massmorph", 0, 10, 41)
end

function massmorph(fname, xcommand)
	if xcommand == buttons.UPDATE then
--		updateButton(fname)
		return
	end

	if xcommand ~= buttons.INIT then
		spell:cast("massmorph")
	end

	setLabelImage(fname, "massmorph-on.png")

end

function SpellsIll()

	-- phantom heal main tank if injured
	if charData:get("autoheal") then

		if scr_phantomheal() then
			return
		end
	end

	-- cast mirror image on self if needed and possible
	if getSpellCount("mirror_image") &gt; 0 then
		if not buff:get("mirror_image") then
			spell:cast("mi")
			return
		end
	end

	if charData:get("autodisplace") then
		if scr_displace() then
			return
		end
	end

	if charData:get("autodoppel") then
		if scr_doppelganger() then
			return
		end
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end

end

function scr_doppelganger()
	for k,char in pairs(groupList:pc("all")) do
		if spell:attempt(char, "doppleganger", "dopple") then
			return(true)
		end
	end

	return(false)
end

function scr_displace()
--	if inCombat() and spell:count() == 0 then
--		if spell:attempt(prompt:get("tank"), "displacement", "ds") then
--			return(true)
--		end
--	end

	for k,char in pairs(groupList:pc("displace")) do
--	for k,char in pairs(groupList:pc("all")) do
		if spell:attempt(char, "displacement", "ds") then
			return(true)
		end
	end

	--local wuss=charData:get("wuss")

	--if groupList:ingroup( wuss ) then
	--	if spell:attempt(wuss, "blur", "blur") then
	--		return(true)
	--	end
	--end
end

function scr_phantomheal()
	-- phantom heal anyone at &lt; .5 maxhp

	for k,char in pairs(groupList:pc()) do
		local hp=tonumber(groupList:getHP(char))
		local maxhp= tonumber(groupList:getMaxHP(char))

		if spell:getCurrent() ~= ("pheal " .. char) then
			if getSpellCount("phantom_heal") &gt; 0 then
				if hp &lt; .5 * maxhp then
					echoDebug("&lt;red&gt;[" .. hp .. "/" .. maxhp .. " casting pheal on " .. char .. "]")
					spell:cast("pheal " .. char)
					return(true)
				end
			end
		end
	end

	return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>DruScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initDru()
	powerAliases:addButtons()

	--mud:send("powers info vit")
end

function SpellsDru()
	-- earthquakes
	if castQuake() then
		return
	end

	-- cure critic main tank if injured
	if charData:get("autoheal") then
		local tank=prompt:get("tank")

		if tank ~= "" then
			local char=tank
			local hp=tonumber(groupList:getHP(char))
			local maxhp= tonumber(groupList:getMaxHP(char))
			local percent = hp/maxhp

			if getSpellCount("cure_critic") &gt; 0 and percent &lt; .85 then
				spell:cast("ccr " .. char)
				return
			end
		end
	end

	-- queue vitality
	if charData:get("autovit") and charData:get("level") &gt;= 26 then
		if 	scr_vitality() then
			return
		end
	end

	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end

	if charData:get("automissile") then
		if inCombat() and spell:count() == 0 then
			spell:cast("tw")
			return
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>RanScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initRan()
	addbutton("autohide", 0, 2, 1)
	addbutton("auto_heal", 0, 1, 10)
	
	meleePowers:addButtons()
		
	-- disable rescue if it's enabled
	if charData:get("rescuetype") ~= "off" then
		buttons:change("rescuetype", "off", "rescue")
	end
end
function auto_heal(fname, xcommand)
	shiftSkillButton("auto_heal", "auto_heal", xcommand)
end

function procPromptRan()
	-- Dual Weapon powers
	if equip:getWeapon() == "Dual" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("ss") then return end -- sweeping strike
			end
		end

		if meleePowers:use("bs") then return end -- bladestorm
		
		if not timer:get("wraithform") then
			if meleePowers:use("ap") then return end -- armor splinter
		end
		
		if meleePowers:use("ev") then return end -- eviscerate
		if meleePowers:use("ts") then return end -- twin strike
	end

	-- Archery powers
	if equip:getWeapon() == "Bow" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("ks") then return end -- knockdown shot
			end
			
			if meleePowers:use("cn") then return end -- concussive shot
		end

		if meleePowers:use("ha") then return end -- hail of arrows
		
		if not timer:get("wraithform") then
			if meleePowers:use("sp") then return end -- splintering shot
		end
		
		if meleePowers:use("cn") then return end -- concussive shot
		if meleePowers:use("tr") then return end -- triple shot
	end
end

function SpellsRan()
	local healSlot = 0

	-- can't cast if stunned, parad, in fugue, etc
	if not spell:castOK() then
		return
	end

	
	if charData:get("auto_heal") then
		healSlot=1
	end

	-- misty path
	if charData:get("ranmsp") then
		if not buff:get("misty_path") and spell:getSlot(5) &gt; 0 then
			spell:cast("MSP")
			return
		end
	end

	-- Only use cloaks if in combat
	
	if inCombat() then
		if charData:get("ranclr") then
			if not buff:get("cloak_of_resilience") and spell:getSlot(4) &gt; 0 then
				spell:cast("CLR")
				return
			end
		end

		if charData:get("ranclp") then
			if not buff:get("cloak_of_protection") and spell:getSlot(3) &gt; 0 then
				spell:cast("CLP")
				return
			end
		end
	end

	-- offensive spells

	if inCombat() then
		
		-- hunters mark
		if charData:get("ranhm") then
			if not (spell:getCast())["hm"] and spell:getSlot(1) &gt; 0 then
				spell:setCast("hm")
				spell:cast("HM")
				return
			end
		end
		
		if charData:get("ranclw") then
			if not buff:get("cloak_of_the_winds") and spell:getSlot(2) &gt; healSlot then
				spell:cast("CLW")
				return
			end
		end

		-- Dual wield spell powers
		if equip:getWeapon() == "Dual" then
			-- Electric Discharge: don't cast if you want cloak of resilience (same circle)
			if charData:get("raneld") and not charData:get("ranclr") then
				if not buff:get("electric_discharge") and spell:getSlot(4) &gt; healSlot then
					spell:cast("ELD")
					return
				end
			end

			-- Greenfire
			if charData:get("rangrf") then
				if not buff:get("greenfire") and not buff:get("blades_of_fire") and spell:getSlot(5) &gt; healSlot then
					spell:cast("GRF")
					return
				end
			end

			-- Blades of Fire: don't cast if you want cloak of protection (same circle)
			if charData:get("ranbof") and not charData:get("ranclp") then
				if not buff:get("blades_of_fire") and not buff:get("greenfire") and spell:getSlot(3) &gt; healSlot then
					spell:cast("BOF")
					return
				end
			end
		end
		
		-- bow spell powers
	
		if equip:getWeapon() == "Bow" then
			-- Hail of Thorns: don't cast if you want cloak of resilience (same circle)
			if charData:get("ranhot") and not charData:get("ranclr") then
				if not buff:get("hail_of_thorns") and spell:getSlot(4) &gt; healSlot then
					spell:cast("HOT")
					return
				end
			end

			-- Arctic Barrage
			if charData:get("ranab") then
				if not buff:get("arctic_barrage") and spell:getSlot(5) &gt; healSlot then
					spell:cast("AB")
					return
				end
			end

			-- Lightning Arrow: don't cast if you want cloak of protection (same circle)
			if charData:get("ranlita") and not charData:get("ranclp") then
				if not buff:get("lightning_arrow") and spell:getSlot(3) &gt; healSlot then
					spell:cast("LITA")
					return
				end
			end
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PalScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initPal()
	addbutton("damage_spells", 0, 6, 30)
	addbutton("guard", 0, 11, 30)
	
	meleePowers:addButtons()
end

function procPromptPal()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp
	
	if getBashing() then
		return
	end

	-- blind needs to be checked here
	if (buff:get("blind") or buff:get("blindness")) and spell:getSlot(3) &gt; 0 then
		if spell:castOK() then
			spell:cast("CS")
		end
		return
	end
	
	-- melee powers

	-- taunts : need to change usage

	if meleePowers:use("dc") then return end -- divine challenge

	if prompt:get("tank") ~= "" and prompt:get("tank") ~= whoami() then
		if meleePowers:use("tn") then return end -- true nemesis
	end

	-- divine smite
	if meleePowers:use("ds") then return end 

	-- 1h/shield melee powers
	if equip:getWeapon() == "Shield" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("rc") then return end -- radiant charge
			end
		end

		if meleePowers:use("ss") then return end -- shielding smite

		if maxhp-hp &gt; 50 then
			if meleePowers:use("bs") then return end --bolstering strike
		end
		
		if meleePowers:use("ws") then return end -- wrathful smite
		if meleePowers:use("es") then return end --enervating smite
		if meleePowers:use("bs") then return end --bolstering strike
	end
	
	-- 2h powers
	if equip:getWeapon() == "TwoHand" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("ts") then return end -- thunderous smite
			end
		end

		if meleePowers:use("trs") then return end --terrifying smite
		if meleePowers:use("vs") then return end --valiant strike
		if meleePowers:use("brs") then return end --brilliant smite
		if meleePowers:use("wws") then return end --whirlwind smite
	end
end

function SpellsPal()
	local healSlot = 0

	-- can't cast if stunned, parad, in fugue, etc
	if not spell:castOK() then
		return
	end

	if charData:get("pallh") then
		healSlot=1
	end

	-- blinded

	if (buff:get("blind") or buff:get("blindness")) and spell:getSlot(3) &gt; 0 then
		if spell:getSlot(3) &gt; 0 then
			spell:cast("CS")
			return
		else

		end
	end

	if inCombat() then
		-- shield of faith
		if charData:get("palsf") and charData:get("level") &lt; 30 then
			if not buff:get("shield_of_faith") and spell:getSlot(1) &gt; 0 then
				spell:cast("SF")
				return
			end
		end
		
		-- shield of warding
		if charData:get("palsw") then
			if not buff:get("shield_of_warding") and spell:getSlot(4) &gt; 0 then
				spell:cast("SW")
				return
			end
		end

		-- aura of life
		if charData:get("palal") then
			if not buff:get("aura_of_life") and spell:getSlot(5) &gt; 0 then
				spell:cast("AL")
				return
			end
		end
	
		-- brand of judgement
		if charData:get("palboj") then
			if not (spell:getCast())["boj"] and spell:getSlot(3) &gt; healSlot then
				spell:setCast("boj")
				spell:cast("BOJ")
				return
			end
		end
	
			-- damage spells
		
		if charData:get("autodspells") then
			-- sunburst
			if spell:getSlot(5) &gt; healSlot then
				spell:cast("SB")
				return
			end	

			-- corrupt weapon
			if not buff:get("holy_sword") and spell:getSlot(3) &gt; healSlot then
				spell:cast("hs")
				return
			end
	
			-- divine bolt
			if spell:getSlot(4) &gt; healSlot then
				spell:cast("db")
				return
			end
		end
	end
	
	return
end

function guard(fname, xcommand)
	if xcommand == buttons.INIT then
		if charData:get("palguard") then
			setLabelImage(fname, fname .. "-on.png")
		else
			setLabelImage(fname, fname .. "-off.png")
		end
		return
	end
		
	if xcommand == buttons.CLICK then
		shiftSkillButton(fname, "palguard", xcommand)
	
		if charData:get("palguard") then
			if groupList:ingroup( charData:get("wuss") ) then
				mud:send("guard " .. charData:get("wuss"))
			end
		else
			mud:send("guard me")
		end
	end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>BlkScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initBlk()
	addbutton("poisonRogue", 0, 11, 30)
	addbutton("damage_spells", 0, 6, 30)

	meleePowers:addButtons()
end

function procPromptBlk()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp
	
	if getBashing() then
		return
	end

	-- blind needs to be checked here
	if buff:get("blind") or buff:get("blindness") and spell:getSlot(3) &gt; 0 then
		if spell:castOK() then
			spell:cast("CS")
		end
		return
	end
	
	-- melee powers

	-- taunts : need to change usage - should be after spells, not before
	-- minimum 85% health to use

	if percent &gt; .85 then
		if meleePowers:use("bc") then return end -- baleful challenge

		if charData:get("blktn") then
			if timer:get("true_nemesis") == nil and not timer:get("cooldown") then
				if prompt:get("tank") ~= "" and prompt:get("tank") ~= whoami() then
					useMeleePower("tn")
					return
				end
			end
		end
	end

	if meleePowers:use("drs") then return end -- dread smite

	-- soul touch : use if blksot is enabled, full heal spells available

	if charData:get("blksot") then
		if not timer:get("soul_touch") and percent &lt; .5 then
			if meleePowers:use("sot") then return	end	
		end
	end

	-- 1h/shield melee powers
	if equip:getWeapon() == "Shield" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("ds") then return end -- dominating smite
			end
		end

		if meleePowers:use("dm") then return end -- dark majesty

		-- plundering smite is 120% max
		if percent &lt; 120 then
			if meleePowers:use("ps") then return end -- plundering smite
		end

		if meleePowers:use("fs") then return end -- frenzying smite
		if meleePowers:use("rs") then return end -- ruinous smite
	end

	-- 2h powers
	if equip:getWeapon() == "TwoHand" then
		if prompt:get("enemyposition") == "std" then
			if not timer:get("noground") and not timer:get("wraithform") and not timer:get("nobash") then
				if meleePowers:use("ss") then return end -- shattering smite
			end
		end

		if meleePowers:use("md") then return end -- mortal dread
		if meleePowers:use("vs") then return end -- vengeance strike
		if meleePowers:use("sph") then return end -- spirit harrow
		if meleePowers:use("uf") then return end -- uncontrolled fury
	end
end

function SpellsBlk()
	local healSlot = 0

	-- can't cast if stunned, parad, in fugue, etc
	if not spell:castOK() then
		return
	end

	if charData:get("blksot") then
		healSlot=1
	end

	-- blinded (consumption to heal)

	if buff:get("blind") or buff:get("blindness") and spell:getSlot(3) &gt; 0 then
		-- display("blind, casting CS")
		spell:cast("CS")
		return
	end
		
	if inCombat() then
		-- shroud of shadow
		if charData:get("blksos") then
			if not buff:get("shroud_of_shadow") and spell:getSlot(4) &gt; 0 then
				spell:cast("SOS")
				return
			end
		end

		-- aura of death
		if charData:get("blkad") then
			if not buff:get("aura_of_death") and spell:getSlot(5) &gt; 0 then
				spell:cast("AD")
				return
			end
		end

		-- if baleful challenege is active, use aspect of domination
		
		if charData:get("blkbc") then
			if not buff:get("aspect_of_domination") and spell:getSlot(2) &gt; healSlot then
				spell:cast("AOD")
				return
			end
		end
		
		-- sigil of pain
		if charData:get("blksp") then
			if not (spell:getCast())["sp"] and spell:getSlot(3) &gt; healSlot then
				spell:setCast("sp")
				spell:cast("SP")
				return
			end
		end
	
		-- damage spells
		
		if charData:get("autodspells") then
			-- ravenous shadows
			if spell:getSlot(5) &gt; healSlot then
				spell:cast("RAV")
				return
			end	

			-- corrupt weapon
			if not buff:get("corrupt_weapon") and spell:getSlot(3) &gt; healSlot then
				spell:cast("CW")
				return
			end
	
			-- scourge of agony
			if spell:getSlot(4) &gt; healSlot then
				spell:cast("SOA")
				return
			end
		end
	end
	
	return
end


function damage_spells(fname, xcommand)
	if xcommand == buttons.INIT then
		if charData:get("autodspells") then
			setLabelImage(fname, fname .. "-on.png")
		else
			setLabelImage(fname, fname .. "-off.png")
		end
		return
	end
	
	if xcommand == buttons.CLICK then
		shiftSkillButton(fname, "autodspells", xcommand)
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>DirScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function initDir()
	powerAliases:addButtons()

	addbutton("outflank", 0, 13, 30)
	addbutton("howl", 0, 14, 15)

	meleePowers:addButtons()
end

function mounted_charge(fname, xcommand)
	shiftSkillButton("mounted_charge", "dirbh", xcommand)
end

-- this function will be called when dire could cast
function SpellsDir()
	-- if fighting and no other spells cast damage spells
	if powerAliases:castDamage() then
		return
	end
end

function howl(fname, xcommand)
	shiftSkillButton("howl", "autohowl", xcommand)
end

function outflank(fname, xcommand)
	shiftSkillButton("outflank", "outflank", xcommand)
end

function procPromptDir()
	-- dire: howl - howl if in combat and enabled
	if mount:getMounted() then
		if charData:get("autohowl") and inCombat() then
			if not timer:get("howlcd") then
				timer:set("howlcd", 7)
				mud:send("howl")	
			end
		end
	end

	-- dire: outflank - outflank if in combat and enabled
	if mount:getMounted() then
		if charData:get("outflank") and inCombat() then
			if not timer:get("outflankcd") then
				timer:set("outflankcd", 6)
				mud:send("outflank")	
			end
		end
	end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>EquipProcs</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Equipment Buttons</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

	equipment = equipment or {}

	equipment = {
		{"TiaScale", "a silvered scale of deepest blue hue", 5, "SAY deeply defend"},
		{"TiaOcular", "an ocular disc of mighty sight", 9, "SAY mine eyes divine"},
		{"TiaWarmaul", "the warmaul of celestial glory", 2},
		{"TiaSandals", "a pair of leathern sandals of Mystra's holy high order", 3, "SAY my heavenly home"},
		{"baatorian", "a smoking bracer forged from Baatorian steel", 1, "SAY demonic conjuration"},
--		{"WornBoots", "worn boots with mithril inlays"},
		{"TiaMask", "a set of gem studded tentacle rings", 5, "project schism"},
		{"TiaSleeves", "a set of gossamer sleeves of the mystic", 4, "SAY flesh mends"},
		{"TiaBracers", "the quickly pulsing bracers of time", 4, "SAY let minds quicken"},
		{"TiaClaws", "the wickedly sharp claws of a gelugon devil", 6, "SAY freezing flesh"},
		{"TiaStaff", "an ancient staff of the arch", 2},
		{"TiaBane", "the infernal stiletto of bane", 2},
		{"TiaLoop", "a fighter's loop of sorcerous ability", 2, "SAY aid of mage"},
		{"TiaManacle", "an unfettered manacle of thickly woven metallic mesh", 5, "SAY no focus"},
		{"FrenziedGrin", "a frenzied bloodthirsty grin", 7, "GRIN"},
		{"VermSleeves", "vermillion chainmail sleeves", 8, "SAY accelerate"},
		{"TiaValhalla", "the mighty scepter of valhalla", 4},
		{"SuppleGirdle", "a supple leather girdle with golden studs", 3, "SAY strength of stone"},
		{"TiaCincture", "a luminous cincture of nightfallen stars", 3, "SAY fell stars"},
		{"TiaStability", "the mystical boots of stability", 5, "SAY whirlwind"},
		{"TiaVolance", "a thick titanium band of volance", 1, "SAY mirrors"},
		{"TiaWarder", "a dark gray cloak with a rune embroidered hem", 0, "SAY blend"},
		{"DragonCult", "the ceremonial robes of the Dragon Cult", 0, "SAY draconian protection"},
		{"AshenStaff", "an ancient staff of the ashen soul", 2, "SAY rot"}
				}


-- equipButton is a generic button script for single keyword proc'able equipment 
-- it uses information from the 'equipment' table

--{
--  "TiaClaws",
--  "the wickedly sharp claws of a gelugon devil",
--  6,
--  "say freezing flesh"
--}

function equipButton(fname, xcommand)
	local equipinfo = equipment:getByShortName(fname)

	if xcommand &gt;= buttons.TIMEREXPIRE and not isIconActive(fname) then
		return
	end

	if xcommand == buttons.INIT or xcommand == buttons.TIMEREXPIRE then
		if timer:get(fname) == nil then
			setLabelImage(fname, fname .. "-on.png")
		else
			setLabelImage(fname, fname .. "-off.png")
		end
	end

	if xcommand == buttons.CLICK then
		if timer:get(fname) == nil then
			timer:set(fname, 10)
			setLabelImage(fname, fname .. "-off.png")

			if equipinfo[2] == nil then
				display("error")
				display(fname)
				display(equipinfo)
			end

			cecho("&lt;cyan&gt;[Equipment proc: " .. equipinfo[2] .. "]\n")
			mud:send( equipinfo[4] )
		end
	end
end

function equipment:getByLongName(xname)
	for nx=1, #equipment, 1 do
		if equipment[nx][2] == xname then
			return(equipment[nx])
		end
	end

	return(nil)
end

-- This function returns the entire table entry that passed value matches shortname ( "TiaScale" )

function equipment:getByShortName(xname)
	for nx=1, #equipment, 1 do
		if equipment[nx][1] == xname then
			return(equipment[nx])
		end
	end

	return(nil)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Baatorian</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function baatorian(fname, xcommand)
	local label=findlabel(fname)

	local var= timer:get("baatorian")

	if xcommand &gt;= buttons.TIMEREXPIRE then
		if not isIconActive(fname) then
			return
		end
	end

	if xcommand &gt;= buttons.TIMEREXPIRE then
		if pet:status() then
			if xcommand ~= buttons.TIMEREXPIRE then
				if var &gt; (12*60) then
					var = var - (12*60)
				end
			end
		end

		if label ~= nil then
			if timer:get("baatorian") == nil then
				label:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;     &lt;br&gt;     &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
				setLabelImage(fname, "baatorian.png")
			else
				label:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] ..
													charData:get("petrescue"):upper() .. "&lt;br&gt;" .. timedisplay(var) ..
													"&lt;/center&gt;&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;")
			end
		end

		return
	end

	if xcommand == buttons.INIT then
		if timer:get("baatorian") == nil then
			setLabelImage(fname, "baatorian.png")
		else
			setLabelImage(fname, "baatorian-timer.png")
		end

		label:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;     &lt;br&gt;     &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
	end

	if xcommand == buttons.CLICK then
		mud:send("slaad")
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Misc equipment</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


function FrenziedGrin(fname, xcommand)
	equipButton(fname, xcommand)
end

function DragonCult(fname, xcommand)
	equipButton(fname, xcommand)
end

function VermSleeves(fname, xcommand)
	equipButton(fname, xcommand)
end

function SuppleGirdle(fname, xcommand)
	equipButton(fname, xcommand)
end

function AshenStaff(fname, xcommand)
	equipButton(fname, xcommand)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Tiamat</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function TiaSleeves(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaWarder(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaLoop(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaClaws(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaScale(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaCincture(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaManacle(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaStability(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaBracers(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaSandals(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaOcular(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaVolance(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaMask(fname, xcommand)
	equipButton(fname, xcommand)
end

function TiaValhalla(fname, xcommand)
	charData:init("valhalla", "defend")

	if xcommand &gt;= buttons.TIMEREXPIRE then
		return
	end

	if xcommand == buttons.CLICK then	
		if charData:get("valhalla") == "defend" then
			charData:set("valhalla", "berserk")
			mud:send("say berserker fury")
		else
			charData:set("valhalla", "defend")
			mud:send("say defender of asgard")
		end
	end

	if charData:get("valhalla") == "berserk" then
		setLabelImage(fname, "TiaValhalla-berserk.png")
	else
		setLabelImage(fname, "TiaValhalla-defend.png")
	end
end

function TiaStaff(fname, xcommand)
	if xcommand &gt;= buttons.TIMEREXPIRE and not isIconActive(fname) then
		return
	end

	if xcommand == buttons.INIT or xcommand == buttons.TIMEREXPIRE then
		setLabelImage(fname, "TiaStaff-off.png")
	end

	if xcommand == buttons.CLICK then
		if charData:get("TiaStaff") == nil or charData:get("TiaStaff") == "" then
			mud:send("protect")
		else
			mud:send("release")
		end
	end
end

function TiaWarmaul(fname, xcommand)
	local label=findlabel(fname)

	charData:init("warmaul", "off")

	if xcommand &gt;= buttons.TIMEREXPIRE then
		return
	end

	if xcommand == buttons.INIT then
		setLabelImage(fname, "TiaWarmaul-off.png")

		NyyLIB.warmaul = NyyLIB.warmaul or 0

		TiaWarmaul("TiaWarmaul", buttons.UPDATE )
	elseif xcommand == buttons.UPDATE then
		label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. NyyLIB.warmaul .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
	elseif xcommand == buttons.CLICK then
		local tmpvar=charData:get("warmaul")

		cecho("&lt;red&gt;[Warmaul: " .. tmpvar .. " type 'set warmaul off|aid|restore', or type 'aid' or 'restore' to proc accordingly]\n")

		if tmpvar == "aid" then
			mud:send("aid")
		elseif tmpvar == "restore" then
			mud:send("restore")
		end
	end
end

function TiaBane(fname, xcommand)
	local label=findlabel(fname)

	if xcommand == buttons.INIT then
		setLabelImage(fname, "TiaBane-off.png")

		charData:init("bane", "blind")
		charData:init("banecharges", 0)

		label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. charData:get("banecharges") .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
	elseif xcommand == buttons.UPDATE then
		--label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. charData:get("banecharges") .. [[z&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
		label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. charData:get("banecharges") .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
	elseif xcommand == buttons.CLICK then
		local tmpvar=charData:get("bane")

		if tmpvar == "blind" then
			mud:send("say Dragonblind")
		elseif tmpvar == "poison" then
			mud:send("say Dragonpoison")
		elseif tmpvar == "slow" then
			mud:send("say Dragonslow")
		elseif tmpvar == "strike" then
			mud:send("say Dragonstrike")
		end
	end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>BOTS</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>WaterXP</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>waterscripts</name>
						<packageName></packageName>
						<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


-- first level: .5ne5ne5ne5ne5ne
-- 2nd level: .5ne5ne5ne5ne5ne



function initwater()
	NyyLIB.bots= NyyLIB.bots or {}

	NyyLIB.bots.advfound=0
	
	NyyLIB.bots.advposition=0

	NyyLIB.bots.xval=0
	NyyLIB.bots.yval=0
	NyyLIB.bots.zval=0

	expandAlias(".6n")
	mud:send("snap")

	-- dirs to start room .nwnwndn

	--chklevel

	--#IF (@NyyLIB/WaterPlane/advfound = 0) {
   --NyyLIB/Waterplane/zval = 2
   -- .2d
   -- chklevel
end

function checklevel()
--#LOOP 1,5 {
--  chkrow
--  #IF (@NyyLIB/WaterPlane/advfound=1) {
--    #ABORT 1
--  }
--  {
--    NyyLIB/WaterPlane/xval = @NyyLIB/WaterPlane/xval+1
--    #IF (@NyyLIB/WaterPlane/xval &gt; 4) {
--      NyyLIB/WaterPlane/xval=0
--    }
    
--    w
--  }
--}
end

function checkrow()
--#LOOP 1,5 {
--  #IF (@NyyLIB/WaterPlane/advfound != 1) {
--    #wait 500
--    scan
--    #WAIT 750
--  }
--  #IF (@NyyLIB/WaterPlane/advfound=1) {
--    #ABORT 1
--  }
--  {
--    n
--    NyyLib/WaterPlane/yval=@NyyLib/WaterPlane/yval+1
--    #IF (@NyyLib/WaterPlane/yval&gt;4) {
--      NyyLib/WaterPlane/yval=0
--    }
--  }
--}
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>TrainScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- various functions used with the xp trains

function NextTrainStop()
	local currentroom = map:getRoom()
	local hpPercent = prompt:get("hp") / prompt:get("maxhp")
	local mvPercent = prompt:get("mv") / prompt:get("maxmv")

	callNextTrain=nil

	-- if currently tanking anything, don't move
	if inCombat() then
		cecho("&lt;red&gt;[Still in combat - not leaving room]\n")
		return
	end	

 	-- Delay 60 seconds if less then 50% hp or movement
 	if hpPercent &lt; .5 or mvPercent &lt; .5 then
  	tempTimer(45, [[NextTrainStop()]])
  	
		mud:send("gcmd [Train paused 45 seconds: Low movement or hp]")

		mud:send("bandage me")
		mud:send("bandage me")
		mud:send("bandage me")
		mud:send("bandage me")
		mud:send("bandage me")
		
  	return
 	end

	-- look has been sent but not received - recall function after 1 second if grouped player fighting
	if type(groupList:whoTanking()) == "table" and not look:get() then
		for k,v in pairs( groupList:whoTanking() ) do
			if groupList:ingroup(k) and v ~= 0 then
				echoDebug("&lt;red&gt;[look sent and not received]\n")
				tempTimer(1, [[NextTrainStop()]])
				return
			end
		end
	end

	if NyyLIB.smtrainposition == nil then
		assert(currentroom, "[Error: room id is nil]")

		if map:getCurrentZone() == "Ashstone" then
			getPath(currentroom, 87415)
			mud:send("gcmd [Stopping train and returning to bank (87415)" .. " &lt;." .. compressSpeedwalk() .. "&gt;]")
			expandAlias("@fwalk 87415", false)
		else
			getPath(currentroom, 48603)
			mud:send("gcmd [Stopping train and returning to inn (48603)" .. " &lt;." .. compressSpeedwalk() .. "&gt;]")
			expandAlias("@fwalk 48603", false)
		end

		expandAlias("@resettrain", false)
	else
		-- increment train position
		
		NyyLIB.smtrainposition = NyyLIB.smtrainposition + 1

		if NyyLIB.smtrainposition &gt; #NyyLIB.smtrainstops then
			NyyLIB.smtrainposition = 1

			printStats(3)

			expandAlias("@stats write", false)

			--mud:send("gcmd [Resetting Stats]")
			--resetStats()
		end

		NyyLIB.nextstop = NyyLIB.smtrainstops[NyyLIB.smtrainposition][1]
		enableTrigger("trainstation")

		assert(currentroom, "[Error: room id is nil]")
		if getPath(currentroom, NyyLIB.nextstop) then

			local str = NyyLIB.smtrainstops[NyyLIB.smtrainposition][2]
			local nextmob = string.gsub(" "..str, "%W%l", string.upper):sub(2)

			mud:send("gcmd [Moving to: " .. nextmob ..
							" (" .. NyyLIB.smtrainstops[NyyLIB.smtrainposition][1] .. ") " ..
 							" &lt;." .. compressSpeedwalk() .. "&gt;]")
		end
		NyyLIB.traintarget=false
	
		if currentroom ~= NyyLIB.nextstop then
			-- maybe needed? map:countMovement() == 0
			if not fwalkQue then
				fwalkQue=true
				echoDebug("&lt;red&gt;[NextTrainStop() : Queueing fwalk in 3 seconds]\n")
				tempTimer(3, [[expandAlias("@fwalk " .. NyyLIB.nextstop)]])
			else
				echoDebug("&lt;red&gt;fwalk already queued]\n")
			end
		end
	end
end

function StartFight()
	if prompt:get("tank") ~= "" then
		return
	end
	
	-- train was just stopped
	if NyyLIB.smtrainposition == nil then
		return
	end
		
	local mobtarget = string.split(NyyLIB.smtrainstops[NyyLIB.smtrainposition][2], " ")[1]

	if NyyLIB.traintarget then
		setEnemy(mobtarget)

		if groupList:size() == 1 then
			cecho("&lt;cyan&gt;\n[Attacking: " ..  string.title(mobtarget) .. "]\n")
		else
			mud:send("gcmd [Attacking: " ..  string.title(mobtarget) .. "]")
		end
		
		-- rogue, blackguard - apply poison
		if checkMask("venomer") then
			sendPoison()
		end	

		-- rogue: start with assassinate
		if checkMask("rog") then
			if not sendAssassinate(mobtarget) then
				mud:send("bs " .. mobtarget)
			end

			return
		end

		if checkMask("ran") then
			meleePowerUsed=false
				
			if equip:getWeapon() == "Dual" then
				useMeleePower("SS " .. mobtarget)
			end
				
			if equip:getWeapon() == "Bow" then
				useMeleePower("KS " .. mobtarget)
			end
				
			-- recall in case power is in cooldown
			tempTimer(2, [[StartFight()]])
			return
		end

		if checkMask("pal") then
			-- ss is 2h, ds is 1h : TODO: need to check weapon
			if equip:getWeapon() == "TwoHand" then
				useMeleePower("ts " .. mobtarget)
			else
				useMeleePower("rc " .. mobtarget)
			end
				
			-- recall in case power is in cooldown
			tempTimer(2, [[StartFight()]])

			return
		end

		if checkMask("blk") then
			-- ss is 2h, ds is 1h : TODO: need to check weapon
			if equip:getWeapon() == "TwoHand" then
				useMeleePower("ss " .. mobtarget)
			else
				useMeleePower("ds " .. mobtarget)
			end

			-- recall in case power is in cooldown
			tempTimer(2, [[StartFight()]])

			return
		end

		if checkMask("war") then
			if table.contains( { "Ogre", "Barbarian", "Troll" }, whorace() ) then
				useMeleePower("BDS " .. mobtarget) -- bodyslam
			else
				if equip:getWeapon() == "TwoHand" then
					useMeleePower("ss " .. mobtarget) -- spinning sweep
				else
					useMeleePower("sb " .. mobtarget) -- shield block
				end

			end

			-- recall in case power is in cooldown
			tempTimer(2, [[StartFight()]])

			return
		end

		--spell:setMoving(false)
		mud:send("kill " .. mobtarget)
	else
		-- [Players in room - Moving to next station]
		cecho("\n&lt;red&gt;[Target is damaged or already dead -  Moving to next station]\n")
		NextTrainStop()
	end
end

function bankDeposit()
	expandAlias("dep", false)

	if groupList:size() &gt; 1 then
		botWarning()
	end
end

-- fightreturn false: send flee
-- fightreturn true: send assist

function fleeMem()
	-- ignore trigger if in fugue
	if map:getRoom() == 93848 then
		return
	end

	if charData:get("memcount") == nil or charData:get("memcount") == 0 and not checkMask("psi") then
		fightreturn=true
		return
	end

	if not NyyLIB.castertrain then
		-- mud:send("status " .. matches[2])
		mud:send("flee")
	end

	fightreturn=true
	NyyLIB.castertrain=true
end

function botWarning()
	mud:send("gsay * [       Warning! Use at own risk!       ]")
	mud:send("gsay * Toril discourages use of robots. Use may be")
	mud:send("gsay * permitted if at or near keys, but not for")
	mud:send("gsay * long periods of time. This may result in")
	mud:send("gsay * arbitrary punishment, including aggressive")
	mud:send("gsay * mob loads, caging, freezing or deletion.")
	mud:send("gsay * [       Warning! Use at own risk!       ]")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setupTrain config</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- TODO: update inittrain path in Silverymoon

	testtrain = {
		{48518, "Shalyssa Lurialar"},
		{48850, "Forell Luckaun"},
		{48721, "Seipora Rein"}
	}


	smtrain = {
		{84203, "bankDeposit"},
		{48882, "Willa O'Greensleeves"},
		{48873, "Aratha Sul"},
		{48524, "Lavis Ryl"},
		{48525, "Elaith Waterstill"},
		{48518, "Shalyssa Lurialar"},
		{48850, "Forell Luckaun"},
		{48721, "Seipora Rein"},
		{48681, "Corland Deepforge"},
		{48586, "Ersenas"},
		{49135, "Ultrumm"},
--		{49054, "Tathshandra Tyrar"},
--		{94648, "Otasit"},
		{49117, "devout priest"},
		{49036, "Dragor Keenblade"}
	}

	ashtrain = {
		{87415, "bankDeposit"},
--		{87411, "Stephan"},
--		{87402, "lich"},
		{87263, "gambler"},
		{87270, "bouncer"},
--		{87271, "naked man"},
		{87272, "prostitute"},
		{87275, "aging prostitute"},
		{87276, "naked woman"},
		{87254, "Ashstone noble"},
		{87251, "Ashstone noble"},
		{87255, "Ashstone noble"},
		{87249, "Ashstone noble"},
--		{87314, "kindly priest"},
		{87253, "Ashstone noble"},
		{87258, "Ashstone noble"},
		{87257, "Ashstone noble"}
	}

	wdtrain = {
		{13402, "elite"},
		{13359, "elite"},
		{13343, "elite"},
		{13354, "master"},
		{13397, "master"}
--		{85354, "elite guard"},
--		{85358, "elite guard"},
--		{85356, "elite guard"},
--		{85410, "elite guard"},
--		{85421, "elite guard"},
--		{85349, "elite guard"}
	}


function configureTrain()
	fwalkQue=false

	-- disable any active triggers prior to enabling
	expandAlias("@resettrain", false)

	cecho("&lt;green&gt;[Laying train tracks...]\n")

	if trainList ~= nil then
		if _G[trainList] ~= nil then
			NyyLIB.smtrainstops = _G[trainList]
			trainList=nil
			return
		end
	end

	if map:getCurrentZone() == "Ashstone" then
		NyyLIB.smtrainstops = ashtrain
	elseif map:getCurrentZone() == "Silverymoon, Gem of the North" then
		NyyLIB.smtrainstops = smtrain
	elseif map:getCurrentZone() == "Northern Waterdeep Main City" then
		NyyLIB.smtrainstops = wdtrain
	elseif map:getCurrentZone() == "The Great Harbor of Waterdeep" then
		NyyLIB.smtrainstops = wdtrain
	end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setupTrain mode</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function trainEngine()

	buttons:change("autoloot", "coins", "autoloot")
	buttons:change("flee", "off", "flee")
	mud:send("tog wimp 0")
	mud:send("tog rescue-assist")

	if checkMask("rog") then
		buttons:change("autotrip", true, "trip")
	end

	-- enable spellcasting
	buttons:change("autocast", true, "SpellsButton")

	if checkMask("blk") then
		buttons:change("rescuetype", "all", "rescue")
	
		buttons:change("blkbc", true, "blkbc", 45)
		buttons:change("blksot", true, "blksot", 1)
		buttons:change("blkdrs", true, "blkdrs", 1)
		buttons:change("blkps", true, "blkps", 1)
		buttons:change("blkds", true, "blkds", 5)
		buttons:change("blkdm", true, "blkdm", 15)
		buttons:change("blkrs", true, "blkrs", 25)
		buttons:change("blkfs", true, "blkfs", 30)
		buttons:change("blkvs", true, "blkvs", 1)
		buttons:change("blkss", true, "blkss", 5)
		buttons:change("blkmd", true, "blkmd", 15)
		buttons:change("blksph", true, "blksph", 25)
		buttons:change("blkuf", true, "blkuf", 30)
	
		buttons:change("blksp", true, "blksp", 11)
		buttons:change("blkad", true, "blkad", 6)

		buttons:change("autodspells", true, "damage_spells")
	end

	if checkMask("war") then
		buttons:change("rescuetype", "all", "rescue")
	
		buttons:change("warcs", true, "warcs", 1)
		buttons:change("warsb", true, "warsb", 5)
		buttons:change("wards", true, "wards", 15)
		buttons:change("warbs", true, "warbs", 25)
		buttons:change("warra", true, "warra", 30)
		
		buttons:change("warcv", true, "warcv", 1)
		buttons:change("warss", true, "warss", 5)
		buttons:change("warsk", true, "warsk", 15)
		buttons:change("warua", true, "warua", 25)
		buttons:change("warros", true, "warros", 30)
	
		buttons:change("warub", true, "warub", 5)
		buttons:change("warut", true, "warut", 10)
		buttons:change("wardsd", true, "wardsd", 30)
		buttons:change("warsod", true, "warsod", 35)
		buttons:change("wariw", true, "wariw", 40)
	end

	if checkMask("pal") then
		buttons:change("rescuetype", "all", "rescue")
	
		buttons:change("palds", true, "palds", 1)
		
		buttons:change("paldc", true, "paldc", 1)
		buttons:change("pallh", true, "pallh", 1)

		buttons:change("palbs", true, "palbs", 1)
		buttons:change("palrc", true, "palrc", 5)
		buttons:change("palss", true, "palss", 15)
		buttons:change("pales", true, "pales", 25)
		buttons:change("palws", true, "palws", 30)
		buttons:change("palvs", true, "palvs", 1)
		buttons:change("palts", true, "palts", 5)
		buttons:change("palbrs", true, "palbrs", 15)
		buttons:change("paltrs", true, "paltrs", 25)
		buttons:change("palwws", true, "palwws", 30)
	
		buttons:change("palboj", true, "palboj", 20)
		buttons:change("palal", true, "palal", 40)

		buttons:change("autodspells", true, "damage_spells")
	end


	if checkMask("ran") then
		buttons:change("rescuetype", "all", "rescue")
		buttons:change("auto_heal", true, "auto_heal")
		
		buttons:change("rantr", true, "rantr", 1)
		buttons:change("ranks", true, "ranks", 5)
		buttons:change("ransp", true, "ransp", 15)
		buttons:change("rancn", true, "rancn", 25)
		buttons:change("ranha", true, "ranha", 30)
		buttons:change("rants", true, "rants", 1)
		buttons:change("ranss", true, "ranss", 5)
		buttons:change("ranap", true, "ranap", 15)
		buttons:change("ranev", true, "ranev", 25)
		buttons:change("ranbs", true, "ranbs", 30)
		
		buttons:change("ranhm", true, "ranhm", 1)
		buttons:change("ranlita", true, "ranlita", 20)
		buttons:change("ranbof", true, "ranbof", 20)
		buttons:change("ranhot", true, "ranhot", 30)
		buttons:change("raneld", true, "raneld", 30)
		buttons:change("rangrf", true, "rangrf", 40)
		buttons:change("ranab", true, "ranab", 40)
		buttons:change("ranclw", true, "ranclw", 10)
	end

	charData:set("statname", "train")

	mud:send("gcmd [Resetting Stats]")
	resetStats()

	NyyLIB.smtrainposition=0
	enableTrigger("SMTrain")
end

function trainCar()
	cecho("&lt;green&gt;[Starting train car...]\n")

	-- disable loot / enable flee, autoassist
	buttons:change("autoloot", "off", "autoloot")
	buttons:change("flee", "on", "flee")
	buttons:change("autoassist", true, "autoassist")

	-- set wimpy to maximum
	mud:send("tog wimp " .. prompt:get("maxhp") )

	if checkMask("missile") or checkMask("cle") then
		cecho("&lt;red&gt;[Starting: Caster train triggers]\n")
		enableTrigger("SMTrainCaster")

		-- enable spellcasting
		buttons:change("autocast", true, "SpellsButton")
		
		-- enable missile spells
		if checkMask("missile") then
			buttons:change("automissile", true)
		end
		
		-- enable autoharm (cleric only)
		if checkMask("cle") then
			buttons:change("autoharm", true)
		end
	end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Scripts</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>MapperScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
	map = map or {}

	map.movement = map.movement or {}
	map.movementIndex = 0

	exitMap = { n = 1, north = 1, e = 4, east = 4, w = 5, west = 5, s = 6, south = 6,
		  u = 9, up = 9, d = 10, down = 10, ["in"] = 11, out = 12, [1] = "north", [4] = "east", [5] = "west",
		  [6] = "south",  [9] = "up",  [10] = "down",  [11] = "in",  [12] = "out"}

	doorMap = { n = 1, north = 1, e = 4, east = 4, w = 5, west = 5, s = 6, south = 6,
		  u = 9, up = 9, d = 10, down = 10, ["in"] = 11, out = 12, [1] = "n", [4] = "e", [5] = "w",
		  [6] = "s",  [9] = "up",  [10] = "down",  [11] = "in",  [12] = "out"}


function map:addArea(xarea)
	if xarea == nil then
		local count=0
		local line=""

		for areaid, areaname in pairs(NyyLIB.areaTable) do
			line = line .. string.format("%3d %-33s ", areaid, areaname)
			count=count+1

			if count == 3 then
				echo(line .. "\n")
				line="" 
				count=0
			end
		end

		if line ~= "" then
			echo(line .. "\n")
		end

		echo("\n")
	end

	if xarea ~= nil then
		local areaid = tonumber(xarea)
		local internalid = map:findAreaID( NyyLIB.areaTable[areaid] )

		if internalid ~= nil then
			echo("Map for " .. NyyLIB.areaTable[areaid] .. " already exists.\n")
		else
			cecho("\n&lt;green&gt;[Added area: (" .. areaid .. ") " .. NyyLIB.areaTable[areaid] .. "]\n")

			addAreaName(NyyLIB.areaTable[areaid])
		end
	end
end

-- pop and return last movement (if there was one)

function map:popMovement()
	if map:countMovement() &gt; 0 then
		local retval=self.movement[1]
		
		map:removeMovement()

		echoDebug("&lt;blue&gt;\n[map:popMovement " .. retval .. "] ")
				
		return(retval)
	end
	
	return(false)
end

-- peek and return next movement (if there is one)

function map:peekFutureMovement()
	if map:countMovement() &gt; 0 then
		local movement = self.movement[self.movementIndex+1]
				
		return(movement)
	end
	
	return(nil)
end

-- self.movement: List of all upcoming movements
-- self.movementIndex: Everything prior to this value has been sent/not receieved


function map:countMovement()
	return(#self.movement)
end

-- add a desired movement to the end of the queue

function map:addMovement(xdir)
	echoDebug("&lt;blue&gt;[map:addMovement queueing: " .. xdir .. "]")
	
	self.movement[#self.movement+1] = xdir
end

-- insert movement into queue at 1 before end

function map:insertMovement(xmove)
	local index=map:countMovement()
	
	if index == 0 then
		index=1
	end
	
	echoDebug("&lt;green&gt;[map:insertMovement at " .. index .. " " .. xmove .. "]\n")
	
	table.insert(self.movement, index, xmove)
end

-- return the next movement to send (and increment the index)
-- self.movementIndex : index of last movement sent

function map:nextMovement()
	--if self.movementIndex == 1 then
	--	echo("setting to 0")
	--	self.movementIndex=0
	--end
	
	
	if self.movement[self.movementIndex+1] == nil then
		echoDebug("&lt;green&gt;[map:nextMovement() all queued movements already sent]\n")
		display(self.movementIndex)
		display(self.movement)
		return(nil)
	end

	return( self.movement[self.movementIndex+1] )
end

-- send next queued movement

function map:sendNextMovement()
	-- Don't send any movements if more then "movebuffer" have been sent/not yet recieved. TODO: make variable
	
	if self.movementIndex &gt; tonumber( charData:get("movebuffer", true) ) then
			return(nil)
	end

	local movement = map:nextMovement()
	
	if movement ~= nil then
		echoDebug("&lt;blue&gt;[map:sendNextMovement() self.movementIndex+1 " .. self.movementIndex+1 .. "]\n")
		
		self.movementIndex=self.movementIndex+1


		-- mud:send deletes duplicates
		send(movement, false)
	end
end

-- remove first movement from queue (exits: line has arrived)

function map:removeMovement()
	table.remove(self.movement, 1)
	
	self.movementIndex = self.movementIndex - 1
	
	if self.movementIndex &lt; 0 then
		self.movementIndex = 0
	end
end

-- remove all unsent movements from queue

function map:trimMovement()
	while map:countMovement() &gt; self.movementIndex do
		table.remove(self.movement, self.movementIndex+1)
	end
end

-- erase entire movement queue

function map:clearQueue()
	--display(self.movement)
	--display(self.movementIndex)
	--display(map:getFutureRoom())
	
	
	
	self.movement = {}

	self.movementIndex = 0

	map:setFutureRoom(nil)
end

-- before sending/queuing, need to check for doors in need of being opened

-- start from current room, and iterate queue with expectation of success

function map:processMovement(xdir)

	echoDebug("&lt;blue&gt;[map:processMovement : " .. tostring(xdir) .. "]")

	-- illithid - break hide

	if checkMask("psi") then
		setHide(false)
	end

	-- buffer movements if needed
	map:addMovement(xdir)

	-- send movement  mud:send eats duplicate commands
	
 	-- queueMovement returns true a special exit was inserted
	if queueMovement(xdir) then
		map:sendNextMovement()
	end
	
	map:sendNextMovement()
end

function sendBufferedMovements()
	if map.movementIndex &gt; 5 then
		return
	end
		
	local sendCount = map:countMovement() - map.movementIndex
	local nx
	
	if sendCount &gt; 5 then
		sendCount=5
	end
	
	for nx=1,sendCount,1 do
		local movement= map:nextMovement()
		
		if movement ~= nil then
			-- if queueMovement returns true a special exit was inserted
			if queueMovement(movement) then
				--display("X")
				map:sendNextMovement()
			end
			
			map:sendNextMovement()
		end
	end
end

function queueMovement(xmove)
	-- display(map:countMovement())
	
	if map:getFutureRoom() == nil or map:countMovement() == 0 then
		map:setFutureRoom( map:getRoom() )
	end

	if map:getFutureRoom() ~= nil then
		exits = getRoomExits( map:getFutureRoom() )

		if exits == nil then
			cecho("&lt;red&gt;[nil exits from " .. map:getFutureRoom() .. "]")
		end

		-- If this room has a special exit to pass, use it

		local specialexit = getSpecialExitsSwap( map:getFutureRoom() )

		if specialexit then
			for k,v in pairs(specialexit) do
				if v == exits[NyyLIB.fulldirs[xmove]] then
					echoDebug("MapperScripts: map:getRoom(): " .. map:getRoom() .. "\n")
					echoDebug("MapperScripts: map:getFutureRoom(): " .. map:getFutureRoom() .. "\n")
					--echoDebug("MapperScripts: sending specialexit: " .. k .. "\n")
					
					-- insert special exit command - TODO: this is looping?
					map:insertMovement(k)
					return(true)
				end
			end
		end

		-- if there's a door in the way, open it
		local retval = map:autoOpen(xmove)

		if retval then
			--display(map:getFutureRoom())
		end

		if xmove == "n" then
			map:setFutureRoom( exits["north"] )
		elseif xmove == "s" then
			map:setFutureRoom( exits["south"] )
		elseif xmove == "e" then
			map:setFutureRoom( exits["east"] )
		elseif xmove == "w" then
			map:setFutureRoom( exits["west"] )
		elseif xmove == "u" then
			map:setFutureRoom( exits["up"] )
		elseif xmove == "d" then
			map:setFutureRoom( exits["down"] )
		end
	
		-- a command to open a door was inserted
		if retval then
			--display(map:getFutureRoom())
			return(true)
		end
	end
end

--open door (if there is one)

function map:autoOpen(xdir)
	if charData:get("autoopen") then
		local doors = getDoors( map:getFutureRoom() )

		if xdir == "n" and doors["n"] then
			map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "n") .. " north")
			return(true)
		elseif xdir == "s" and doors["s"] then
			map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "s") .. " south")
			return(true)
		elseif xdir == "e" and doors["e"] then
			map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "e") .. " east")
			return(true)
		elseif xdir == "w" and doors["w"] then
			map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "w") .. " west")
			return(true)
		elseif xdir == "u" and doors["up"] then
			map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "up") .. " up")
			return(true)
		elseif xdir == "d" and doors["down"] then
			map:insertMovement("open " .. map:getDoorName(map:getFutureRoom(), "down") .. " down")
			return(true)
		end
	end
end

function compressSpeedwalk()
	local t=speedWalkDir
	local ret = {}
	local nx

	for k,v in pairs(t) do
		if v == "down" then
			t[k] = "d"
		end
		if v == "up" then
			t[k] = "u"
		end
	end

   for i, v in ipairs(t) do
		if #v &gt; 4 then
			ret[#ret+1] = ";" .. string.split(v, "|")[1] .. ";"
		else
	   		if t[i-1] and v == t[i-1] then
  		   		ret[#ret - 1] = ret[#ret - 1] + 1
	    	else
	      		ret[#ret + 1] = 1
 	      		ret[#ret + 1] = v
 	    	end
		end
   end

	for nx=1, #ret, 1 do
		if ret[nx] == 1 then
			ret[nx] = ""
		end
	end

   return table.concat(ret)
end

function doSpeedWalk()
	if #speedWalkDir &gt; 0 then
		cecho("&lt;green&gt;[Path: ." .. compressSpeedwalk() .. "]\n")
		
		if #speedWalkPath &gt; 1000 then
			cecho("&lt;red&gt;[Path in excess of 1000 rooms: " .. #speedWalkPath .. "]\n")
			cecho("&lt;red&gt;[1000th room: &lt;green&gt;" .. speedWalkPath[1000] .. "&lt;red&gt; ]\n")
			return
		end

		for k,v in pairs(speedWalkDir) do
			if v == "down" then
				speedWalkDir[k] = "d"
			end
			if v == "up" then
				speedWalkDir[k] = "u"
			end
		end
		
		--display(speedWalkDir)
		
		for k,v in ipairs(speedWalkDir) do
			if not string.find(v, "^[nwesud]$") then
				-- special entrance
				
				local testRoom = map:getFutureRoom()
				
				if testRoom == nil then
					testRoom = map:getRoom()
				end
				
				if testRoom == nil then
					-- first room in path, futureroom hasn't been set yet
					-- first room is using a special exit
					echo("Error: testRoom is nil\n")
				end
				
				local specialexit = getSpecialExitsSwap( testRoom )[v]
				v = string.split(v, "|")[1]
				
				testRoom = map:getFutureRoom()
				map:setFutureRoom(specialexit)
			
				echoDebug("speedwalk: adding movement " .. v .. "\n")
				map:addMovement(v)
				
				if testRoom == nil then
					-- first room in path
					expandAlias(v)
				end
			else
				expandAlias(v)
			end
		end
	
		echo("\n")
	end
end

function unhideRoom(xroomid)
	local zone=getRoomUserData(xroomid, "zoneid")
	local zoneid=tonumber(zone)

	local edgelabel=getRoomUserData(xroomid, "edge")

	local 	internalid= map:findAreaID(NyyLIB.areaTable[zoneid])

	if xroomid == 1 then
		return
	end

	-- zone doesn't exist in arealist - add it
	if zoneid ~= nil and internalid == nil then
		map:addArea(zoneid)
		
		internalid= map:findAreaID(NyyLIB.areaTable[zoneid])

		if internalid == nil then
			cecho("[internalid error in room: " .. xroomid .. "]\n")
			display(zoneid)
			display( NyyLIB.areaTable[zoneid] )
			display( map:findAreaID(NyyLIB.areaTable[zoneid]) )
			display("X")
		end
	end

	-- echo("\n[Room: " .. xroomid .. " " .. NyyLIB.areaTable[zoneid] .. "]\n")

	if map:getDoNotEnter(xroomid) == false then
		lockRoom( xroomid, false) -- unlocks the room, adding it back to possible rooms that can be walked through.
	end

	if roomExists(xroomid) == false then
		cecho("&lt;red&gt;[&lt;green&gt;" .. xroomid .. " &lt;red&gt;does not exist]\n")
		return
	end

	if internalid == nil then
		-- will crash this run room has been removed
		display("Likely to crash")
		display(xroomid)
		display(zoneid)
		display(getRoomUserData(xroomid, "zoneid"))
		display(NyyLIB.areaTable[zoneid])
		display( map:findAreaID(NyyLIB.areaTable[zoneid]) )
	end

	setRoomArea( xroomid, internalid)

	-- add label indicating zone edges
	if edgelabel ~= "" and edgelabel ~= nil then
		cmi:roomLabel(edgelabel)
	end

	-- add label indicating password
	local pw=getRoomUserData(xroomid, "password")

	if pw ~= "" and pw ~= nil then
		cmi:passwordLabel(xroomid, pw)
	end
end

function map:update(xdir)
	local roomid
	local exits

	if xdir ~= nil then
		echoDebug("&lt;blue&gt;[map:update : " .. xdir .. "] ")
	
		-- command was movealone
		if string.match(xdir, "^MOVEA ([neswud]).*") then
			xdir=string.match(xdir, "^MOVEA ([neswud]).*")
		end
	else
		echoDebug("&lt;blue&gt;[map:update : nil] ")
	end

	if map:getRoom() ~= nil then
		NyyLIB.lastRoomID = map:getRoom()

		local specialexit = getSpecialExitsSwap( map:getRoom() )

		local exitlist={}

		-- build list of special exits
		for k,v in pairs(specialexit) do
			for k2,v2 in pairs(string.split(k, "|")) do
				echoDebug("&lt;green&gt;[Previous room has special exit: " .. k .. "]\n")
				exitlist[v2]=v
			end
		end

		if exitlist[xdir] ~= nil then
			roomid = exitlist[xdir]
		else
			exits = getRoomExits( map:getRoom() )

			if exits == nil and xdir ~= nil then
				echo("\n[No recorded exits: Room " .. map:getRoom() .. "]\n")
				map:setRoom(nil)
				return
			end

			if xdir == "n" then
				roomid	= exits["north"]
			elseif xdir == "s" then
				roomid	= exits["south"]
			elseif xdir == "e" then
				roomid	= exits["east"]
			elseif xdir == "w" then
				roomid	= exits["west"]
			elseif xdir == "u" then
				roomid	= exits["up"]
			elseif xdir == "d" then
				roomid	= exits["down"]
			else
				roomid=map:getRoom()
			end
		
			-- attempt to move a direction with no know exit
		
			if roomid == nil then
				roomid=map:getRoom()
			end
		end

		if roomid ~= nil then
			if getRoomArea(roomid) == -1 then
				unhideRoom(roomid)
			else
				-- already found
			end

			centerview(roomid)
		else
			centerview(1)
		end
		
		map:setRoom(roomid)
	else
		centerview(1) -- blank room number
	end
end

-- return a table built from mud exit string

function getExitTable(xmudstr)
	local exitsarray = {0,0,0,0,0,0}
	
	if string.find(xmudstr, "-N") ~= nil or string.find(xmudstr, "- N") ~= nil then
		exitsarray[1] = 1
	end

	if string.find(xmudstr, "-S") ~= nil or string.find(xmudstr, "- S") ~= nil then
		exitsarray[2] = 1
	end

	if string.find(xmudstr, "-E") ~= nil or string.find(xmudstr, "- E") ~= nil then
		exitsarray[3] = 1
	end

	if string.find(xmudstr, "-W") ~= nil or string.find(xmudstr, "- W") ~= nil then
		exitsarray[4] = 1
	end

	if string.find(xmudstr, "-U") ~= nil or string.find(xmudstr, "- U") ~= nil then
		exitsarray[5] = 1
	end

	if string.find(xmudstr, "-D") ~= nil or string.find(xmudstr, "- D") ~= nil then
		exitsarray[6] = 1	
	end

	return( exitsarray )
end

-- [Searching... Match found: Silverymoon, Gem of the North : At the End of Bowshot Ride : 48908]

function solveScan(xsuppress)
	scanned = scanned or {}

	if table.size(scanned) == 0 then
		--if xsuppress == nil then
		--	echo("&lt;red&gt;No scan results to attempt solving]\n")
		--end
		return(nil)
	end

	local scanresults = {}

	for k,v in pairs(scanned) do
		if type(v) == "table" and k ~= "currentroomexits" then
			if #scanresults == 0 then
				scanresults= v.filtered
			end
			
			scanresults = table.n_intersection(scanresults, v.filtered)

			-- no intersect
			if scanresults == false then
				scanresults = {}
			end
		end
	end

	if #scanresults == 1 then
		local match= scanresults[1]

		if xsuppress == nil then
			cecho("&lt;red&gt;Match found: &lt;blue&gt;" .. getRoomAreaName(getRoomArea(match)) .. " : " .. getRoomName(match) .. " : " .. match .. "&lt;red&gt;]\n")
		end

		return( match )
	end

	if xsuppress == nil then
		display(scanresults)
		cecho("&lt;red&gt;Solve scan failed. &lt;green&gt;Multiple (&lt;red&gt;" .. #scanresults .. "&lt;green&gt;) matches found]\n")
	end

	map:setRoom(nil)
	centerview(1)

	return(nil)
end

function filterScan(xkey)
	-- remove roomids from table if reversematch to current location is false

	if scanned[xkey].roomids ~= nil then
		scanned[xkey].filtered = {}

		for k,v in pairs(scanned[xkey].roomids) do
			local match= getRoomExits(v)[NyyLIB.reversedirs[xkey]]

			if match ~= nil then
				-- need to verify match identical to current room

				table.insert(scanned[xkey].filtered, match)
			end
		end

		scanned[xkey].roomids = nil
	end
end

-- map:setFutureRoom is the room number that will be occupied when the current movement queue is completed

function map:getFutureRoom()
	return ( self.futureRoom )
end

function map:setFutureRoom(xroom)
	self.futureRoom = xroom
end

function map:getExits()
	return ( self.exits )
end

function map:setExits(xexits)
	self.exits=xexits
end

function map:getRoomname()
	return ( self.roomname )
end

function map:setRoomname(xname)
	self.roomname = xname
end

function map:getRoom()
	return ( self.roomid )
end

function map:setRoom(xid)
	if xid ~= nil then
		if getRoomArea(xid) == -1 then
			unhideRoom(xid)
		end
	end

	self.roomid = xid

	if map:getFutureRoom() == nil or map:countMovement() == 0 then
		if xid ~= nil then
			echoDebug("&lt;blue&gt;[map:setRoom (setFutureRoom) : " .. xid .. "]\n")
			map:setFutureRoom( xid )
		end
	end

	raiseEvent("newRoomEvent", map:getRoom() )
end

function map:getZone(roomid)
	local areaID
	local areaname

	if roomid == nil then
		return( "" )
	end

	areaID = getRoomArea( roomid )

	if areaID ~= nil then
		if areaID == -1 then
			local zone=getRoomUserData(roomid, "zoneid")
			local zoneid=tonumber(zone)

			areaname = NyyLIB.areaTable[zoneid]
		else
			areaname=getRoomAreaName(areaID)
		end
	end

	return (areaname)
end

function map:hide()
	if NyyLIB.mapwindow ~= nil then
		NyyLIB.mapwindow:show()
		NyyLIB.mapwindow:hide()
	end
end

function map:show()
	if NyyLIB.mapwindow ~= nil then
		NyyLIB.mapwindow:hide()
		NyyLIB.mapwindow:show()
	end
end

function map:countRooms()
	if self.roomcount == nil then
		self.roomcount=0

		for k,v in pairs(getRooms()) do
			self.roomcount=self.roomcount+1
		end
	end

	return(self.roomcount)
end

function map:loadMap()
	-- create mapper window if not yet present

	mudlet = mudlet or {}; mudlet.mapper_script = true

	if NyyLIB.mapwindow == nil then
		NyyLIB.mapwindow = Geyser.Mapper:new({name="mapper",x="66%",y=0,width="33%",height="50%"})
	end

	if setDefaultAreaVisible ~= nil then
		setDefaultAreaVisible(false)
	end

	-- top level map will be loaded if exists, otherwise the default
	local is_file = io.open(homepath("toril.map"))
	local loadok	

	if is_file ~= nil then
		loadok = loadMap(homepath("toril.map"))

		if loadok then
			cecho("&lt;red&gt;[Loaded map: " .. homepath("toril.map") .. "]\n")
		end
	else
		loadok = loadMap(mainpath("toril.map"))

		if not loadok then
  			cecho("&lt;red&gt;[Failed map load: " .. mainpath("toril.map") .. "]\n")
		else
  			cecho("&lt;red&gt;[Loaded map: " .. mainpath("toril.map") .. "]\n")

			-- initial map load - save file
			saveMap( "" )
		end
	end

	expandAlias("@find", false)
end

function map:setDoNotEnter(xroomid)

	if roomExists(xroomid) then
		setRoomUserData(xroomid, "DoNotEnter", "X")
	else
		echo("[Error: Attempt to set DNE in non-existent room: " .. xroomid .. "]\n")
	end
end

function map:getDoNotEnter(xroomid)
	local str=getRoomUserData(xroomid, "DoNotEnter")

	if str == "X" then
		return(true)
	end

	return(false)
end

-- iterate over the list of areas, matching them with substring match. 
-- if we get match a single area, then return it's ID, otherwise return
-- 'false' and a message that there are more than one area matches

function map:findAreaID(areaname)
	local nx
	local list = getAreaTable()
 
  local returnid, fullareaname

	if areaname == nil then
		cecho("&lt;red&gt;[Warning: map:findAreaId(areaname) - nil areaname]\n")
		return nil
	end

  for area, id in pairs(list) do
		if area == areaname then
      if returnid then 
			echo("[more then one area matches]\n")
			return nil
		end
      returnid = id; 
    end
  end

  return returnid
end

function map:findRoomArea(xname, xexits)
	local partmap = searchRoom(xname)
	local match = {}
	local filteredmatch = {}

	local matchedarea=nil

	for roomid, roomname in pairs(partmap) do
		if roomname == xname then
			table.insert(match, roomid)
		end
	end

	if #match == 0 then
		return(nil)
	end

	if #match == 1 then
		matchedarea= map:getZone( match[1] )
		return(matchedarea)
	end

	for k, v in pairs(match) do
		local roomexits = getRoomExits(v)
		local matchtable = {0,0,0,0,0,0}

		if roomexits["north"] then
			matchtable[1] = 1
		end

		if roomexits["south"] then
			matchtable[2] = 1
		end
	
		if roomexits["east"] then
			matchtable[3] = 1
		end

		if roomexits["west"] then
			matchtable[4] = 1
		end
	
		if roomexits["up"] then
			matchtable[5] = 1
		end
	
		if roomexits["down"] then
			matchtable[6] = 1
		end
	
		if table.concat(xexits) == table.concat(matchtable) then
			table.insert(filteredmatch, v)
		end
	end

	matchedarea= map:getZone( filteredmatch[1] )

	-- multiple rooms matches, but all in the same area

	for k,v in pairs(filteredmatch) do
		if map:getZone(v) ~= matchedarea then
			matchedarea=nil
		end
	end

	return(matchedarea)
end

function map:findRoomID(xname, xexits, xsuppress)
	local partmap = searchRoom(xname)
	local match = {}
	local filteredmatch = {}

	for roomid, roomname in pairs(partmap) do
		if roomname == xname then
			table.insert(match, roomid)
		end
	end

	if #match == 0 then
		map:setRoom(nil)
		
		if xsuppress == nil then
			cecho("&lt;red&gt;No matches found: &lt;blue&gt;" .. xname .. "&lt;red&gt;]\n")
		end
		return(nil)
	end

	if #match == 1 then
		if xsuppress == nil then
			cecho("&lt;red&gt;Match found: &lt;forest_green&gt;" .. getRoomAreaName(getRoomArea(match[1])) .. " : ".. xname .. " : " .. match[1] .. "&lt;red&gt;]\n")
		end

		return(match[1])
	end

	for k, v in pairs(match) do
		local roomexits = getRoomExits(v)
		local matchtable = {0,0,0,0,0,0}

		if roomexits["north"] then
			matchtable[1] = 1
		end

		if roomexits["south"] then
			matchtable[2] = 1
		end
	
		if roomexits["east"] then
			matchtable[3] = 1
		end

		if roomexits["west"] then
			matchtable[4] = 1
		end
	
		if roomexits["up"] then
			matchtable[5] = 1
		end
	
		if roomexits["down"] then
			matchtable[6] = 1
		end
	
		if table.concat(xexits) == table.concat(matchtable) then
			table.insert(filteredmatch, v)
		end
	end

	if #filteredmatch == 0 then
		if xsuppress == nil then
			cecho("&lt;red&gt;No matching exits found]\n")
		end
		return(nil)
	end

	if #filteredmatch == 1 then
		if xsuppress == nil then
			cecho("&lt;green&gt;Exits matched room#: " .. filteredmatch[1] .. " : " .. xname .. "&lt;red&gt;]\n")
		end
		return(filteredmatch[1])
	end

	if xsuppress == nil then
		cecho("&lt;green&gt;Multiple (&lt;red&gt;" .. #filteredmatch .. "&lt;green&gt;) matches found: &lt;blue&gt;" .. xname .. "]\n")

		-- send scan if multiple matches/scan has not been already sent
		if table.size(scanned) == 0 then
			mud:send("SCAN")
		end
	end

	return(nil)
end

function map:findRoomIDTable(xname, xexits, xsuppress)
	local partmap = searchRoom(xname)
	local match = {}
	local filteredmatch = {}

	for roomid, roomname in pairs(partmap) do
		if roomname == xname then
			table.insert(match, roomid)
		end
	end

	if #match == 0 then
		if xsuppress == nil then
			echo("No matches found: " .. xname .. "]\n")
		end
		return(nil)
	end

	if #match == 1 then
		if xsuppress == nil then
			cecho("&lt;red&gt;Match found: &lt;blue&gt;" .. xname .. " : " .. match[1] .. "&lt;red&gt;]\n")
		end
		return(match)
	end

	for k, v in pairs(match) do
		local roomexits = getRoomExits(v)
		local matchtable = {0,0,0,0,0,0}

		if roomexits["north"] then
			matchtable[1] = 1
		end

		if roomexits["south"] then
			matchtable[2] = 1
		end
	
		if roomexits["east"] then
			matchtable[3] = 1
		end

		if roomexits["west"] then
			matchtable[4] = 1
		end
	
		if roomexits["up"] then
			matchtable[5] = 1
		end
	
		if roomexits["down"] then
			matchtable[6] = 1
		end
	
		if table.concat(xexits) == table.concat(matchtable) then
			table.insert(filteredmatch, v)
		end
	end

	if #filteredmatch == 0 then
		if xsuppress == nil then
			cecho("&lt;red&gt;No matching exits found]\n")
		end
		return(nil)
	end

	return(filteredmatch)
end

function map:getCurrentZone()
	local areaID
	local areaname

	if map:getRoom() ~= nil then
		areaID = getRoomArea( map:getRoom() )
	end

	if areaID ~= nil then
		areaname=getRoomAreaName(areaID)
	end

	return (areaname)
end

function map:isRoomName(teststring)
	if teststring == nil then
		return
	end

	-- if first character not a capital letter can't be room name	

	if not string.find(teststring, "^[A-Z]") then
		return(false)
	end

	-- if final character is period, !, or ' can't be room name
	-- final character must be [a-z]

	-- if string.find(teststring, "[!.']$") then
	-- for now, allow for whitespace character at end
	if not string.find(teststring, "[a-z \)]$") then
		return(false)
	end

	-- if (x2) can't be room
	if string.find(teststring, "(x2)") then
		return(false)
	end
	
	-- Your rage subsides considerably as the blade on your a black longsword of destruction
	if string.find(teststring, "Your rage subsides") then
		return(false)
	end
	
	
	-- As the magic of Vomicopol's bracers overwhelm his body, they
	if string.find(teststring, "bracers overwhelm") then
		return(false)
	end


	-- 'All of a sudden, your a set of frozen ice shard greaves explode'

	if string.find(teststring, "All of a sudden") then
		return(false)
	end

	-- The mighty scepter of valhalla growls angrily, 'This is no time to be cautious! Press this weak

	if string.find(teststring, "The mighty scepter of") then
		return(false)
	end

	-- Bard song isn't roomname
	
	-- As your voice lifts in a sweet rendition of an ancient bardic verse, the nearby air
	-- erupts with myriad echoes.  A beautiful voice rises above the din, singing along

	if string.find(teststring, "As your voice") then
		return(false)
	end
	
	if string.find(teststring, "erupts with myriad") then
		return(false)
	end

	if string.find(teststring, "Usage:") then
		return(false)
	end

	if map:getRoom() ~= nil then
		if string.find(teststring, " $") then
			if not charData:get("maperror", true) then
				cecho(" &lt;red&gt;[Error: trailing whitespace: (&lt;green&gt;" .. teststring .. "&lt;red&gt;)]")
			end
		end
	end

	return(true)
end

function map:getDoorName(xroomid, xdir)
	local dirname={  ["n"]="north",
						 ["s"]="south",
						 ["u"]="up",
						 ["d"]="down",
						 ["e"]="east",
						 ["w"]="west" }
	local exitNames
	local checkdir=xdir

	exitNames = getDoors(xroomid)

	if exitNames[xdir] then
		exitNames = getRoomUserData(xroomid, "exitNames")

		if exitNames ~= "" and exitNames ~= nil then
			exitNames = yajl.to_value(exitNames)
		else
			exitNames = {}
		end

		if dirname[xdir] ~= nil then
			checkdir=dirname[xdir]
		end

		if exitNames[checkdir] then
			return(exitNames[checkdir])
		end

		return("door")
	end

	return(nil)
end


function map:setDoorName(xroomid, xdir, xdoorname)

	if roomExists(xroomid) then
		local exitNames = getRoomUserData(xroomid, "exitNames")

		if exitNames == "" or exitNames == nil then
			exitNames = {}
		else
			exitNames = yajl.to_value(exitNames)
		end
			
		if xdir == nil then
			cecho("&lt;RED&gt;Import Error:\n")
			display(xroomid)
			display(xdir)
			display(xdoorname)
			return
		end

		exitNames[exitMap[xdir]] = xdoorname

		setRoomUserData(xroomid, "exitNames", yajl.to_string(exitNames))
	else
		echo("[Error: Attempt to set door in non-existent room: " .. xroomid .. " : " .. xdir .. " : " .. xdoorname .. "]\n")
	end
end

function map:lockMap()
local fullmap = getRooms()
local areatable = getAreaTable()

	-- unassign all rooms
	for roomid, roomname in pairs(fullmap) do
		if getRoomArea(roomid) ~= -1 then
			resetRoomArea(roomid)
			echo("Unassigning " .. roomid .. "\n")
		end
		
		if roomLocked(roomid) == false then
			lockRoom( roomid, true)
			echo("Locking " .. roomid .. "\n")
		end
	end

	-- delete all areas
	for i,v in pairs(areatable) do
		deleteArea(v)
	end

	-- create great unknown
	map:addArea(6)
	
	-- need to check if already exists
	expandAlias("emptyroom", false)

	echo("Map locked\n")
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>geyser replacements</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

--- Returns the Geyser object associated with the label name
-- @param label The name of the label to use

function Geyser.Label:getWindow(label)
   for i,v in pairs(Geyser.windowList) do
        if v.name == label then
            return v
        end
		
		-- added to search down 1 additional level

		for key,val in pairs(v.windowList) do
			if val.name == label then
				return val
			end
		end
	end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>checkMask</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The checkMask function returns true/false if a character is a member of a set of classes.

-- checkMask(xmask, xname)
-- 	xmask - name of the mask to use
-- xname - name to check, or nil (whoami)
-- Returns true if xname's class is a member of the set

-- Example: Adud is a warrior

-- if checkMask("rogue", "Adud") then
--		display("This won't happen because Adud isn't a rogue")
-- end

-- Not including a character name means the character logged in will be used

-- Example: Nyyrazzilyss (an illithid) is currently logged in

-- if checkMask("psi") then
--		display("Nyyrazzilyss is a psi")
-- end

	masks = {
		classes = { "War", "Blk", "Pal", "UNK", "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" },
		noPsi = { "War", "Blk", "Pal", "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" },
		nopriest = { "War", "Blk", "Pal", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" },
		nocleric = { "War", "Blk", "Pal", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" },
		psi = { "Psi" },
		enc = { "Enc" },
		war = { "War" },
		cle = { "Cle" },
		sha = { "Sha" },
		rog = { "Rog" },
		ill = { "Ill" },
		inv = { "Inv" },
		dru = { "Dru" },
		bar = { "Bar" },
		ctr = { "Ctr" },
		ran = { "Ran" },
		ele = { "Ele" },
		pal = { "Pal" },
		blk = { "Blk" },
		lic = { "Lic" },
		nec = { "Nec" },
		dir = { "Dir" },
		all = { "War", "Blk", "Pal", "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" },
		self = { "Enc", "Sha" },
		petrescue = { "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec" },
		traintanks = {"War", "Pal", "Blk", "Ran", "Dir", "Bar", "Ctr"},
		warrior = {"War", "Pal", "Blk", "Ran" }, -- temporarily added ranger
		fighter = {"War", "Pal", "Blk", "Ran", "Dir" },
		hitter = { "Rog", "Dir", "Ran", "Blk", "Pal" },
		hitterToRescue = { "Rog", "Dir", "Ran" },
		hasBash = { "Dir"},
		singer = {"Bar", "Ctr"},
		autobless = {"Bar", "Ctr"},
		autohide = {"Psi", "Rog", "Ran"},
		hitterSinger = { "War", "Rog", "Dir", "Ran", "Blk", "Pal", "Bar", "Ctr"},
		displace = { "Cle", "Dru", "Sha", "Ctr", "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" },
		rightWindow = {"UNK", "War", "Blk", "Pal", "Bar", "Ctr", "Dir", "Ran", "Rog"},
		caster = {"Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha" },
		mage = {"Enc", "Inv", "Lic", "Nec", "Ill", "Ele" },
		casterGlobe= {"Enc", "Nec", "Lic"},
		casterSinger = {"Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha", "Bar", "Ctr" },
		casterPsi = {"Psi", "Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha" },
		casterPsiSinger = {"Psi", "Dru", "Enc", "Inv", "Lic", "Nec", "Ill", "Ele", "Cle", "Sha", "Bar", "Ctr" },
		statHitter = {"War", "Pal", "Blk", "Ran", "Dir", "Bar", "Ctr", "Rog" },
		priest = {"Sha", "Dru", "Ctr", "Cle" },
		pray = {"Sha", "Dru", "Cle", "Dir" },
		nonPriestCaster = { "Blk", "Dir" },
		rogue = {"Rog", "Bar", "Ctr"},
		petRescue = { "Psi", "Cle", "Enc", "Dru", "Lic", "Sha", "Inv", "Ill", "Ele",	 "Nec", "Bar", "Ctr", "Rog", "Ran" },
		haster = { "Enc", "Nec", "Ele", "Lic" },
		summonmount = { "Dir"},
		mountedCombat = { "Dir"},
		missile = { "Sha", "Ele", "Dir", "Enc", "Nec", "Inv", "Lic", "Ill", "Dru" },
		hlarea = { "Cle", "Sha", "Ele", "Dir", "Enc", "Nec", "Inv", "Lic", "Ill", "Dru" },
		ffire = { "Enc", "Ill", "Inv", "Dru", "Sha"},
		stoner = { "Sha", "Ele", "Enc" },
		venomer = { "Rog", "Blk" },
		dmgundead = { "Cle", "Nec", "Lic" },
		necros = { "Lic", "Nec" },
		powerCaster = { "Blk", "Pal", "Ran"},
			}

function checkMask(xmask, xname)
	local classname

	if xname == nil then
		xname = whoami()
	end

	classname = whoclass(xname) or "UNK"

	if masks[xmask] == nil then
		echoDebug("&lt;red&gt;[Error: mask " .. xmask .. " does not exist]\n")
		return
	end

	if table.contains( masks[xmask], classname ) then
		return(true)
	end

	return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>charData script</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
charData = charData or {}

-- charData:init(xkey, xval, xtop)
-- xkey - the variable to initialize
-- xval - value of the variable
-- xtop - true - This variable is for all profiles, not a single character


	setvar = {
-- { "name", "class", {"val1", "val2", "val3"}, "default", "instructions" },
	{ "sound", "", {"off", "limited", "on"}, "on", "play sounds"},
	{ "map", "", {"on", "off"}, "on", "display map"},
	{ "maperror", "", {"true", "false"}, "true", "suppress map room errors"},
	{ "roomwindow", "", {"true", "false"}, "false", "display room window"},
	{ "minimap", "", {"true", "false"}, "true", "display minimap"},
	{ "swedish", "", {"true", "false"}, "false", "translate acc/etc to swedish"},
	{ "style", "", {"true", "false"}, "true", "use Qt icon stylesheet"},
	{ "hideicons", "", {"true", "false"}, "false", "hide lower icon bar"},
	{ "hideequip", "", {"true", "false"}, "true", "hide left equip icon bar"},
	{ "border", "", {"*"}, "default", "file, default, or colour"},
	{ "numcolor", "*", {"*"}, "orange", "color of numbers on buttons"},
	{ "numcolcool", "*", {"*"}, "red", "color of numbers on buttons in cooldown"},
	{ "colbuttonoff", "*", {"*"}, "#ff815a", "color of button when off"},
	{ "colbuttonon", "*", {"*"}, "white", "color of button when on"},
	{ "font", "", {"*"}, "AvQest", "font to use for buttons"},
	{ "statname", "*", {"*"}, "unset", ""},
	{ "autoopen", "*", {"true", "false"}, "false", "auto-open doors",
				"\n&lt;green&gt;[Doors will be opened while moving and pathing.]\n",
				"\n&lt;red&gt;[Doors will not be opened.]\n",
		},
	{ "echodrag", "*", {"true", "false"}, "false", "gsay when a corpse is dragged" },
	{ "autoportal", "*", {"true", "false"}, "false", "auto enter rifts/portals/etc",
				"\n&lt;green&gt;[Special exits will be entered if warrior+1 group members use it.]\n",
				"\n&lt;red&gt;[Special exits will not be used automatically.]\n",
		},
	{ "movebuffer", "", {"#"}, "10", "maximum movements to send before buffering" },
	{ "condensed", "", {"dragon", "combat", "spells", "items", "arrows", "misc", "duplicate", "debug", "spellout", "debug2", "echosend"}, "", "" },
	{ "vnum", "", {"true", "false"}, "true", "display room vnum" },
	{ "chatfontsize", "", {"auto", "#"}, "12", "fontsize to use for the chat window" },
	{ "grpfontsize", "", {"auto", "#"}, "14", "fontsize to use for the group window" },
	{ "reconnect", "*", {"false", "#"}, "false", "auto login this char number" },
	{ "endspell", "*", {"vit", "dsp", "pwt", "fly", "grp", "pfu", "hst", "dop", "cbm"}, "vit", "" },
	{ "gcmd", "*", {"true", "false"}, "false", "use gcmd instead of gsay"},
	{ "group", "", { "true", "false" }, "true", "updated group display" },
	{ "assocchar", "", { "*" }, "false", "connect to association chat, storage" },
	{ "blurout", "", { "*" }, "[[ BLUR OUT ]]", "" },
	{ "displaceout", "", { "*" }, "[[ DISPLACE OUT ]]", "" },
	{ "globeout", "", { "*" }, "[[ GLOBE OUT ]]", "" },
	{ "hasteout", "", { "*" }, "[[ HASTE OUT ]]", "" },
	{ "scaleout", "", { "*" }, "[[ SCALE OUT ]]", "" },
	{ "stoneout", "", { "*" }, "[[ STONE OUT ]]", "" },
	{ "vitout", "", { "*" }, "[[ VIT OUT ]]", "" },
	{ "barkout", "", { "*" }, "[[ BARK OUT ]]", ""},
	{ "-", "-" },
	{ "container", "*", { "*" }, "", "set the name of your main container"},
	{ "food", "noPsi", { "*" }, "", "food name to eat"},
	{ "canteen", "noPsi", { "*" }, "", "name of water container"},
	{ "autoloot", "*", {"off", "coins", "all"}, "off", "",
				"\n&lt;red&gt;[Looting is disabled.]\n",
				"\n&lt;red&gt;[Only coins will be looted.]\n",
				"\n&lt;red&gt;[Everything will be looted from corpses.]\n"
		},
	{ "flee", "*", {"on", "off", "dragon", "lich"}, "on", "",
				"\n&lt;red&gt;[If you panic but can't get out, you'll flee again.]\n",
				"\n&lt;red&gt;[All flee triggers are turned off.]\n",
				"\n&lt;red&gt;[If a room is fled (for any reason), it will be returned to.]\n",
				"\n&lt;red&gt;[Staying in a room with a lich that touched you isn't going to happen.]\n"
		 },
	{ "autoassist", "*", { "true", "false" }, "true", "assist people in combat",
				"\n&lt;green&gt;[Any group member is combat will be assisted.]\n",
				"\n&lt;red&gt;[Assist commands will not be sent.]\n",
		},
	{ "petrescue", "*", {"NONE", "ALL", "ME"}, "ME", "",
				"\n&lt;red&gt;[Commands will not be generated to rescue anyone]\n",
				"\n&lt;green&gt;[Order pets to rescue all non-warriors]\n",
				"\n&lt;green&gt;[Only rescue me]\n"
		 },
	{ "-", "-" },
	{ "autocast", "caster", {"true", "false"}, "false", "cast/mem spells automatically", "SpellsButton"},
	{ "pokehaste", "haster", {"true", "false"}, "false", "cast haste when poked" },
	{ "autots", "enc", {"true", "false"}, "false", "cast time stop" },
	{ "self", "self", {"true", "false"}, "false", "spellup includes self",
				"\n&lt;green&gt;[The caster will be blurred, scaled or stoned on spellup.]\n",
				"\n&lt;red&gt;[Spellups are not including me.]\n"
		},
	{ "bard", "enc", {"true", "false"}, "false", "rogue spellups includes bards",
				"\n&lt;green&gt;[Bards will be treated as hitters.]\n",
				"\n&lt;red&gt;[Bards don't need spells.]\n"
		},
	{ "autoscale", "enc", {"true", "false"}, "false", "dragonscale targets",
				"\n&lt;green&gt;[Casters will now be scaled.]\n",
				"\n&lt;red&gt;[Warriors only will be scaled.]\n"
		},
	{ "autoblur", "enc", {"true", "false"}, "false", "blur targets",
				"\n&lt;green&gt;[Casters will now be blurred.]\n",
				"\n&lt;red&gt;[Warriors only will be blurred.]\n"
		},
	{ "autohaste", "enc", {"true", "false"}, "false", "incomplete",
				"\n&lt;red&gt;[Incomplete: Hitters will be hasted.]\n",
				"\n&lt;red&gt;[Incomplete: Hitters don't need haste.]\n"
		},
	{ "autoglobe", "casterGlobe", {"true", "false", "hitters"}, "false", "who to globe",
				"\n&lt;green&gt;[Hitters (including ogre warriors) will be globed.]\n",
				"\n&lt;red&gt;[Players don't need globe.]\n",
				"\n&lt;green&gt;[All hitters and warriors will be globed.]\n"
		},
	{ "resize", "enc", {"off", "small", "large", "all"}, "all", "resize setting",
			"\n&lt;red&gt;[Resizing will no longer occur.]\n",
			"\n&lt;red&gt;[Resizing will now occur for small players only.]\n",
			"\n&lt;red&gt;[All medium sized casters will be enlarged.]\n",
			"\n&lt;red&gt;[Ogre warriors will now be enlarged, and small casters reduced.]\n"
		},
	{ "vit", "priest", { "all", "hitter", "priest", "warrior", "nopriest", "nocleric", "mage" }, "all", "mask when casting vit" },
	{ "autovit", "priest", {"true", "false"}, "false", "cast vit automatically",
			"\n&lt;green&gt;[Auto-vitality turned on.]\n",
			"\n&lt;red&gt;[Auto vitality turned off.]\n"
		},
	{ "autogh", "sha", {"true", "false"}, "false", "cast group heal automatically",
			"\n&lt;green&gt;[Auto group-heal turned on.]\n",
			"\n&lt;red&gt;[Auto group-heal turned off.]\n"
		},
	{ "autofury", "sha", {"true", "false"}, "false", "cast ancestral fury automatically", 
			"\n&lt;green&gt;[Ancestral Fury turned on.]\n",
			"\n&lt;red&gt;[Ancestral Fury turned off.]\n"
		},
	{ "autoashield", "sha", {"true", "false"}, "false", "cast ancestral shield automatically", 
			"\n&lt;green&gt;[Ancestral Shield turned on.]\n",
			"\n&lt;red&gt;[Ancestral Shield turned off.]\n"
		},
	{ "autoheal", "cle", {"true", "false"}, "false", "cast fh/ha automatically"},
	{ "auto_heal", "ran", {"true", "false"}, "false", "cast heal spells automatically",
			"\n&lt;green&gt;[Healing spells will be cast during combat.]\n",
			"\n&lt;red&gt;[Healing spells will not be used.]\n"
		},
	{ "turnundead", "dmgundead", {"true", "false"}, "false", "damage undead automatically",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "autopurify", "cle", {"true", "false"}, "true", "cast divine purification automatically"},
	{ "autocb", "cle", {"true", "false"}, "true", "cast cure blind automatically"},
	{ "autoquake", "priest", {"true", "false"}, "false", "cast quake as needed",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "autores", "cle", {"true", "false"}, "false", "res all consented pcorpses in room",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "autorealm", "cle", {"true", "false"}, "false", "keep everyone realmd",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "warmaul", "equip", { "aid", "restore", "off"}, "off", ""},
	{ "gigbag", "singer", { "*" }, "", "name of container holding instruments" },
	{ "forcerenew", "singer", {"true", "false"}, "false", "force renew despite full psp"},
	{ "lute", "singer", { "*" }, "", "" },
	{ "piccolo", "singer", { "*" }, "", "" },
	{ "trumpet", "singer", { "*" }, "", "" },
	{ "drum", "singer", { "*" }, "", "" },
	{ "harp", "singer", { "*" }, "", "" },
	{ "mandolin", "singer", { "*" }, "", "" },
	{ "autobless", "autobless", {"true", "false"}, "false", "cast harmonious/natures blessing"},
	{ "bane", "equip", { "blind", "poison", "slow", "strike"}, "blind", ""},
	{ "valhalla", "equip", { "defend", "berserk" }, "defend", ""},
	{ "psicrystal", "psi", { "*" }, "", ""},
	{ "wormhole", "psi", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Wormhole and Rift triggers turned on.]\n",
			"\n&lt;red&gt;[Wormhole and Rift triggers turned off.]\n"
		 },
	{ "disableworm", "psi", { "true", "false" }, "false", "" },
	{ "autotower", "psi", { "true", "false" }, "false", "" },
	{ "autosustain", "psi", { "true", "false" }, "false", "" },

	{ "warbh", "war", { "true", "false" }, "false", "",
				"\n&lt;red&gt;[Auto-bash is turned on.]\n",
				"\n&lt;red&gt;[Auto-bash is turned off.]\n"
		 },
	{ "dirbh", "dir", { "true", "false" }, "false", "",
				"\n&lt;red&gt;[Auto-bash is turned on.]\n",
				"\n&lt;red&gt;[Auto-bash is turned off.]\n"
		 },

	{ "warbds", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Bodyslam is turned on.]\n",
				"\n&lt;red&gt;[Bodyslam is turned off.]\n"
		 },

	{ "warvip", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Vigilant Protector is turned on.]\n",
				"\n&lt;red&gt;[Vigilant Protector is turned off.]\n"
		 },


	{ "warcc", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Combat Challenge is turned on.]\n",
				"\n&lt;red&gt;[Combat Challenge is turned off.]\n"
		 },
	{ "warwu", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Warriors Ultimantum is turned on.]\n",
				"\n&lt;red&gt;[Warriors Ultimantum is turned off.]\n"
		 },
	{ "warcs", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Comeback Strike is turned on.]\n",
				"\n&lt;red&gt;[Comeback Strike is turned off.]\n"
		 },
	{ "warsb", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Shield Bash is turned on.]\n",
				"\n&lt;red&gt;[Shield Bash is turned off.]\n"
		 },
	{ "wards", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Defensive Strike is turned on.]\n",
				"\n&lt;red&gt;[Defensive Strike is turned off.]\n"
		 },
	{ "warbs", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Brutal Strike is turned on.]\n",
				"\n&lt;red&gt;[Brutal Strike is turned off.]\n"
		 },
	{ "warra", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Relentless Assault is turned on.]\n",
				"\n&lt;red&gt;[Relentless Assault is turned off.]\n"
		 },
	{ "warcv", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Cleave is turned on.]\n",
				"\n&lt;red&gt;[Cleave is turned off.]\n"
		 },
	{ "warss", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Spinning Sweep is turned on.]\n",
				"\n&lt;red&gt;[Spinning Sweep is turned off.]\n"
		 },
	{ "warsk", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Skull Crusher is turned on.]\n",
				"\n&lt;red&gt;[Skull Crusher is turned off.]\n"
		 },
	{ "warua", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Unyielding Avalanche is turned on.]\n",
				"\n&lt;red&gt;[Unyielding Avalanche is turned off.]\n"
		 },
	{ "warros", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Rain of Steel is turned on.]\n",
				"\n&lt;red&gt;[Rain of Steel is turned off.]\n"
		 },

	{ "warnop", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[No Opening is turned on.]\n",
				"\n&lt;red&gt;[No Opening is turned off.]\n"
		 },
	{ "wariw", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Iron Warrior is turned on.]\n",
				"\n&lt;red&gt;[Iron Warrior is turned off.]\n"
		 },
	{ "warut", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Unstoppable is turned on.]\n",
				"\n&lt;red&gt;[Unstoppable is turned off.]\n"
		 },
	{ "warhd", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Heroic Defense is turned on.]\n",
				"\n&lt;red&gt;[Heroic Defense is turned off.]\n"
		 },
	{ "warsod", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Storm of Destruction is turned on.]\n",
				"\n&lt;red&gt;[Storm of Destruction is turned off.]\n"
		 },
	{ "warub", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Unbreakable is turned on.]\n",
				"\n&lt;red&gt;[Unbreakable turned off.]\n"
		 },
	{ "wardsd", "war", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Diamond Shield Defense is turned on.]\n",
				"\n&lt;red&gt;[Diamond Shield Defense is turned off.]\n"
		 },


	{ "ranss", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Sweeping Strike is turned on.]\n",
				"\n&lt;red&gt;[Sweeping Strike is turned off.]\n"
		 },
	{ "ranev", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Eviscerate is turned on.]\n",
				"\n&lt;red&gt;[Eviscerate is turned off.]\n"
		 },
	{ "ranks", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Knockdown Shot is turned on.]\n",
				"\n&lt;red&gt;[Knockdown Shot is turned off.]\n"
		 },
	{ "rancn", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Concussive Shot is turned on.]\n",
				"\n&lt;red&gt;[Concussive Shot is turned off.]\n"
		 },
	{ "rants", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Twin Strike is turned on.]\n",
				"\n&lt;red&gt;[Twin Strike is turned off.]\n"
		 },
	{ "rantr", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Triple Shot is turned on.]\n",
				"\n&lt;red&gt;[Triple Shot is turned off.]\n"
		 },
	{ "ranbs", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Auto-bstorm is turned on.]\n",
				"\n&lt;red&gt;[Auto-bstorm is turned off.]\n"
		 },
	{ "ranha", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Hail of Arrows is turned on.]\n",
				"\n&lt;red&gt;[Hail of Arrows is turned off.]\n"
		 },
	{ "ranap", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Armor Splinter is turned on.]\n",
				"\n&lt;red&gt;[Armor Splinter is turned off.]\n"
		 },
	{ "ransp", "ran", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Splintering Shot is turned on.]\n",
				"\n&lt;red&gt;[Splintering Shot is turned off.]\n"
		 },

	{ "ranmsp", "ran", {"true", "false"}, "false", "cast misty path",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranhm", "ran", {"true", "false"}, "false", "mark enemy during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranclw", "ran", {"true", "false"}, "false", "use winds during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranclp", "ran", {"true", "false"}, "false", "use cloak of protection",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranclr", "ran", {"true", "false"}, "false", "use cloak of resilience",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranbof", "ran", {"true", "false"}, "false", "use blades of fire during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranlita", "ran", {"true", "false"}, "false", "use lightning arrow during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},

	{ "raneld", "ran", {"true", "false"}, "false", "use electric discharge during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranhot", "ran", {"true", "false"}, "false", "use hail of thorns during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "rangrf", "ran", {"true", "false"}, "false", "use greenfire during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "ranab", "ran", {"true", "false"}, "false", "use arctic barrage during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},



	{ "palfa", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Furious Assault is turned on.]\n",
				"\n&lt;red&gt;[Furious Assault is turned off.]\n"
		 },

	{ "palguard", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Guard is turned on.]\n",
				"\n&lt;red&gt;[Guard is turned off.]\n"
		 },

	{ "palbs", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Bolstering Strike is turned on.]\n",
				"\n&lt;red&gt;[Bolstering Strike is turned off.]\n"
		 },
	{ "palrc", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Radiant Charge is turned on.]\n",
				"\n&lt;red&gt;[Radiant Charge is turned off.]\n"
		 },
	{ "palss", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Shielding Smite is turned on.]\n",
				"\n&lt;red&gt;[Shielding Smite is turned off.]\n"
		 },
	{ "pales", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Enervating Smite is turned on.]\n",
				"\n&lt;red&gt;[Enervating Smite is turned off.]\n"
		 },
	{ "palws", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Wrathful Smite is turned on.]\n",
				"\n&lt;red&gt;[Wrathful Smite is turned off.]\n"
		 },



	{ "palvs", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Valiant Strike is turned on.]\n",
				"\n&lt;red&gt;[Valiant Strike is turned off.]\n"
		 },

	{ "palts", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Thunderous Smite is turned on.]\n",
				"\n&lt;red&gt;[Thunderous Smite is turned off.]\n"
		 },

	{ "palbrs", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Brilliant Smite is turned on.]\n",
				"\n&lt;red&gt;[Brilliant Smite is turned off.]\n"
		 },

	{ "paltrs", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Terrifying Smite is turned on.]\n",
				"\n&lt;red&gt;[Terrifying Smite is turned off.]\n"
		 },
	{ "palwws", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Whirlwind Smite is turned on.]\n",
				"\n&lt;red&gt;[Whirlwind Smite is turned off.]\n"
		 },


	{ "palds", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Divine Smite is turned on.]\n",
				"\n&lt;red&gt;[Divine Smite is turned off.]\n"
		 },
	{ "pallh", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Paladin healing is turned on.]\n",
				"\n&lt;red&gt;[Paladin healing is turned off.]\n"
		 },
	{ "paldc", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Divine Challenge is turned on.]\n",
				"\n&lt;red&gt;[Divine Challenge is turned off.]\n"
		 },
	{ "paltn", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[True Nemesis is turned on.]\n",
				"\n&lt;red&gt;[True Nemesis is turned off.]\n"
		 },
	{ "palsf", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Shield of Faith is turned on.]\n",
				"\n&lt;red&gt;[Shield of Faith is turned off.]\n"
		 },
	{ "palal", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Aura of Life is turned on.]\n",
				"\n&lt;red&gt;[Aura of Life is turned off.]\n"
		 },
	{ "palsw", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Shield of Warding is turned on.]\n",
				"\n&lt;red&gt;[Shield of Warding is turned off.]\n"
		 },
	{ "palboj", "pal", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Brand of Judgement will be used during combat.]\n",
				"\n&lt;red&gt;[Brand of Judgement is turned off.]\n"
		 },


	
	{ "blkfa", "blk", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Furious Assault is turned on.]\n",
			"\n&lt;red&gt;[Furious Assault is turned off.]\n"
	 },
	
	{ "autodspells", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Damage Spells are turned on.]\n",
				"\n&lt;red&gt;[Damage Spells are turned off.]\n"
		 },

	{ "blksot", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Soul Touch is turned on.]\n",
				"\n&lt;red&gt;[Soul Touch is turned off.]\n"
		 },
	{ "blkbc", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Baleful Challenge is turned on.]\n",
				"\n&lt;red&gt;[Baleful Challenge is turned off.]\n"
		 },
	{ "blktn", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[True Nemesis is turned on.]\n",
				"\n&lt;red&gt;[True Nemesis is turned off.]\n"
		 },



	{ "blkad", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Aura of Death is turned on.]\n",
				"\n&lt;red&gt;[Aura of Death is turned off.]\n"
		 },

	{ "blkdrs", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Dread Smite will be used during combat.]\n",
				"\n&lt;red&gt;[Dread Smite is turned off.]\n"
		 },

	{ "blkdm", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Dark Majesty is turned on.]\n",
				"\n&lt;red&gt;[Dark Majesty is turned off.]\n"
		 },
	{ "blkds", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Dominating Smite is turned on.]\n",
				"\n&lt;red&gt;[Dominating Smite is turned off.]\n"
		 },

	{ "blkps", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Plundering Smite is turned on.]\n",
				"\n&lt;red&gt;[Plundering Smite is turned off.]\n"
		 },

	{ "blkrs", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Ruinous Smite is turned on.]\n",
				"\n&lt;red&gt;[Ruinous Smite is turned off.]\n"
		 },

	{ "blkfs", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Frenzying Smite is turned on.]\n",
				"\n&lt;red&gt;[Frenzying Smite is turned off.]\n"
		 },
	{ "blksp", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Sigil of Pain will be used during combat.]\n",
				"\n&lt;red&gt;[Sigil of Pain is turned off.]\n"
		 },
	 { "blksos", "blk", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Shroud of Shadow is turned on.]\n",
			"\n&lt;red&gt;[Shroud of Shadow is turned off.]\n"
	 },
	{ "blkvs", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Vengeance Strike will be used during combat.]\n",
				"\n&lt;red&gt;[Vengeance Strike is turned off.]\n"
			},
	{ "blkss", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Shattering Smite will be used during combat.]\n",
				"\n&lt;red&gt;[Shattering Smite is turned off.]\n"
			},
	{ "blkmd", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Mortal Dread will be used during combat.]\n",
				"\n&lt;red&gt;[Mortal Dread is turned off.]\n"
			},
	{ "blksph", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Spirit Harrow will be used during combat.]\n",
				"\n&lt;red&gt;[Spirit Harrow is turned off.]\n"
			},
	{ "blkuf", "blk", { "true", "false" }, "false", "",
				"\n&lt;green&gt;[Uncontrolled Fury will be used during combat.]\n",
				"\n&lt;red&gt;[Uncontrolled Fury is turned off.]\n"
			},

	{ "wuss", "*", { "*" }, "", "always rescue and spell wuss"},
	{ "rescuetype", "fighter", { "off", "basic", "all" }, "basic", "",
			"\n&lt;red&gt;[Rescue is now turned off]\n",
			"\n&lt;green&gt;[All grouped non-warrior players will be rescued]\n",
			"\n&lt;green&gt;[All grouped players will be rescued]\n"
		},
	{ "autotank", "fighter", { "true", "false" }, "false", "" },
	{ "autocircle", "rog", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Auto-circle is turned on.]\n",
			"\n&lt;red&gt;[Auto-circle is turned off.]\n"
		},
	{ "autohide", "autohide", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Autohide is turned on.]\n",
			"\n&lt;red&gt;[Autohide is turned off.]\n"
		 },
	{ "autotrip", "rog", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Auto-trip is turned on.]\n",
			"\n&lt;red&gt;[Auto-trip is turned off.]\n"
		 },
	{ "autoassassinate", "rog", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Auto-assassinate is turned on.]\n",
			"\n&lt;red&gt;[Auto-assassinate is turned off.]\n"
		 },
	{ "autopoison", "venomer", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Auto-poison is turned on.]\n",
			"\n&lt;red&gt;[Auto-poison is turned off.]\n"
		},
	{ "autoarea", "missile", {"true", "false"}, "false", "cast 1-6th circle area combat spells",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "automissile", "missile", {"true", "false"}, "false", "cast 1-6th circle combat spells",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "autohlmissile", "missile", {"true", "false"}, "false", "cast 7th+ circle combat spells",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "autohlarea", "hlarea", {"true", "false"}, "false", "cast 7th circle+ area combat spells",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "autofm", "inv", {"true", "false"}, "false", "use force missiles in combat",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "autostorm", "inv", {"true", "false"}, "false", "use sandstorm in combat",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "autoharm", "priest", {"true", "false"}, "false", "cast harm spells"},
	{ "autoffire", "ffire", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[@ will be cast during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		 },
	{ "autodisplace", "ill", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Displacement will be used.]\n",
			"\n&lt;red&gt;[Displacement will not be used.]\n"
	},
	{ "autodoppel", "ill", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[Doppelganger will be used.]\n",
			"\n&lt;red&gt;[Doppelganger will not be used.]\n"
	},
	{ "displacemask", "ill", { "true", "false" }, "false", "",	},
	{ "autoblind", "ele", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
	},
	{ "autoward", "ele", { "true", "false" }, "false", "",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
	},
	{ "autostone", "stoner", { "off", "rogues", "tanks", "all" }, "off", "",
			"\n&lt;green&gt;[@ will be used on self.]\n",
			"\n&lt;green&gt;[@ will be used on self and rogues.]\n",
			"\n&lt;green&gt;[@ will be used on self and tanks.]\n",
			"\n&lt;green&gt;[@ will be used on all group members.]\n"
	},
	{ "poisonbag", "venomer", { "*" }, "", "name of container holding poisons" },
	{ "primaryp", "venomer", { "*" }, "", "poison for primary weapon"},
	{ "secondaryp", "venomer", { "*" }, "", "poison for secondary weapon"},
	{ "autopfu", "necros", {"true", "false"}, "false", "cast protection from undead",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "autowail", "necros", {"true", "false"}, "false", "use banshee wail",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "autovcurse", "necros", {"true", "false"}, "false", "use vampiric curse",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},

	{ "autopact", "lic", {"true", "false"}, "false", "cast death pact",
			"\n&lt;green&gt;[@ will be used.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "outflank", "dir", {"true", "false"}, "false", "outflank during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		},
	{ "autohowl", "dir", {"true", "false"}, "false", "howl during combat",
			"\n&lt;green&gt;[@ will be used during combat.]\n",
			"\n&lt;red&gt;[@ will not be used.]\n"
		}

 }

function charData:init(xkey, xval, xtop)
	if xtop ~= nil then
		if self[xkey] == nil then
			self[xkey]=xval
		end
	else
		if whoami() == nil then
			cecho("&lt;red&gt;[Error: whoami not set]\n")
			return
		end
	
		self[whoami()] = self[whoami()] or {}

		if self[whoami()][xkey] == nil then
			self[whoami()][xkey]=xval
		end
	end
end

-- TODO: change charData:set to update matching button

function charData:set(xkey, xval, xtop)
	if xtop ~= nil then
		self[xkey] = xval
	else
		if self[whoami()] == nil then
			cecho("\n&lt;red&gt;[Creating self." .. whoami() .. "]\n")
			self[whoami()] = {}
		end

		self[whoami()][xkey] = xval
	end
end

-- should return initial value if key doesn't exist

function charData:get(xkey, xtop)
	if xtop ~= nil then
		-- key is top level

		if self[xkey] ~= nil then
			return(self[xkey])
		end
	else
		-- key is indexed on charname

		if whoami() == nil then
			return(nil)
		end

		if self[whoami()][xkey] ~= nil then
			return(self[whoami()][xkey])
		end
	end

	-- doesn't exit, should return initial value from setvar table
	-- tables (i.e. condensed) always exist

	local nx

	for nx=1, #setvar, 1 do
		local key= setvar[nx][1]
		local value

		if key == xkey then
			value=setvar[nx][4]

			if value == "true" then
				value=true
			elseif value =="false" then
				value=false
			end

			return(value)
		end
	end
	
	if xkey == nil then
		echoDebug("\n&lt;red&gt;[nil xkey value]\n")
	else
		echoDebug("\n&lt;red&gt;[Warning: key " .. xkey .. " does not exist]\n")
	end

	return(nil)
end

function charData:save()
	table.save(homepath("chardata.dat"), self )
	cecho("\n&lt;red&gt;[Saved CharData table]\n")
end

function charData:load()
	local is_file = io.open(homepath("chardata.dat"))

	cecho("&lt;red&gt;[Loaded charData]\n")

	
	if is_file ~= nil then
		table.load(homepath("chardata.dat"), self)

		-- if old version, replace true/false with boolean
		for k1,v1 in pairs(self) do
			if v1 == "true" then
				charData:set(k1, true, true)
			end

			if v1 == "false" then
				charData:set(k1, false, true)
			end

			if type(self[k1]) == "table" then
				for k2,v2 in pairs(self[k1]) do
					if v2 == "true" then
						self[k1][k2] = true
					end

					if v2 == "false" then
						self[k1][k2] = false
					end
				end
			end
		end

		if self.spellouts ~= nil then
			self.blurout = self.spellouts[1][2]
			self.globeout = self.spellouts[2][2]
			self.hasteout = self.spellouts[3][2]
			self.scaleout = self.spellouts[4][2]
			self.vitout = self.spellouts[5][2]
			self.barkout = "[[ BARK OUT ]]"

			self.spellouts = nil
		end
	end

	self.border = self.border or "default"

	self.condensed= self.condensed or {}

	self.condensed["dragon"] = self.condensed["dragon"] or false
	self.condensed["combat"] = self.condensed["combat"] or false
	self.condensed["spells"] = self.condensed["spells"] or false
	self.condensed["items"] = self.condensed["items"] or false
	self.condensed["arrows"] = self.condensed["arrows"] or false
	self.condensed["misc"] = self.condensed["misc"] or false
	self.condensed["duplicate"] = self.condensed["duplicate"] or false
	self.condensed["debug"] = self.condensed["debug"] or false
	self.condensed["spellout"] = self.condensed["spellout"] or false
	self.condensed["echosend"] = self.condensed["echosend"] or false

	self.gags = self.gags or {}

	self.fwalk = self.fwalk or {}

	self.group = self.group or false

	self.potionc = self.potionc or "&lt;:medium_blue&gt;&lt;white&gt;"

	self.chatfontsize = self.chatfontsize or "auto"
	self.grpfontsize = self.grpfontsize or 14
	self.assocchar = self.assocchar or ""

	self.vnum = self.vnum or false
	
	return
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Spell Powers Header</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
powerAliases= powerAliases or {}

-- automissile: circle 1-6 single target
-- autoarea: circle 1-6 area
-- autohlmissle: circle7+ single target
-- autohlarea: circle 7+ area

-- Spellcast selection priority occurs by position of the spell in the table for the class.
-- The script starts at the end of the table, and works backwords until it hits a spell to cast.
-- To increase the priority of a spell being cast, move it down in the table.

--TODO: add field (true/false) re: spell count (auto-recharge circles don't have spell counts)
-- add field: effect (damage, heal, cure blind, resistance, supervit)


-- spell full name, alias, level, charData, ???

powerAliases["Psi"] = { }

powerAliases["Bar"] =
						{
{ "minor_creation", "minor", 6, "", false},
{ "detect_magic", "dm", 6, "", false},
{ "detect_invisibility", "di", 6, "", false},
{ "phantom_armor", "pa", 16, "", false},
{ "invisibility", "invis", 16, "", false},
{ "faerie_fire", "ff", 16, "autoffire", false, "Faerie_Fire"},
{ "ray_of_enfeeblement", "ray", 26, "", false},
{ "levitate", "lv", 26, "", false},
{ "harmonious_blessing", "hbl", 36, "", false, "Bless"},
{ "feeblemind", "feeb", 36, "", false},
{ "dispel_magic", "dism", 36, "", false},
{ "sonic_wave", "sw", 46, "", false},
{ "displacement", "ds", 46, "", false},
						}

powerAliases["War"] = 
						{
{ "no_opening", "nop", 1, "", false},
{ "unbreakable", "ub", 5, "", false, "Un|Breakable"},
{ "unstoppable", "ut", 10, "", false},
{ "heroic_defiance", "hd", 20, "", false,"Heroic|Defiance"},
{ "diamond_shield_defense", "dsd", 30, "", false, "Diamond|Shield"},
{ "storm_of_destruction", "sod", 35, "", false, "Storm of|Destruct"},
{ "iron_warrior", "iw", 40, "", false, "Iron|Warrior"},
						}


powerAliases["Ran"] = 
						{	
{ "longstrider", "lst", 1, "", false},
{ "hunters_mark", "hm", 1, "", false, "Hunters|Mark"},
{ "cloak_of_vigor", "clv", 1, "", false},
{ "dawns_renewal", "dr", 10, "", false},
{ "cloak_of_the_winds", "clw", 10, "", false,"The|Winds"},
{ "beast_sense", "bse", 10, "", false},
{ "lightning_arrow", "lita", 20, "", false, "Lightning|Arrow"},
{ "cloak_of_protection", "clp", 20, "", false, "Cloak Of|Protect"},
{ "blades_of_fire", "bof", 20, "", false, "Blades Of|Fire"},
{ "tree_stride", "trs", 30, "", false},
{ "hail_of_thorns", "hot", 30, "", false, "Hail of|Thorns"},
{ "electric_discharge", "eld", 30, "", false, "Electric|Discharge"},
{ "cloak_of_resilience", "clr", 30, "", false, "Resilience"},
{ "misty_path", "msp", 40, "", false, "Misty|Path"},
{ "greenfire", "grf", 40, "", false, "Greenfire"},
{ "cloak_of_life", "cll", 40, "", false, "Cloak of|Life"},
{ "arctic_barrage", "ab", 40, "", false, "Arctic|Barrage"}
						}

powerAliases["Blk"] = 
						{
{"umbral_armor", "ua", 1, "", false, "Umbral|Armor"},
{"dark_blessing", "db", 1, "", false, "Dark|Blessing"},
{"shadow_healing", "sh", 10, "", false, "Shadow|Healing"},
{"aspect_of_domination", "aod", 10, "", false},
{"sigil_of_pain", "sp", 20, "", false, "Sigil Of|Pain"},
{"corrupt_weapon", "cw", 20, "", false, "Corrupt|Weapon"},
{"consumption", "cs", 20, "", false, "Consumption"},
{"scourge_of_agony", "soa", 30, "", false, "Scourge Of|Agony"},
{"dark_grace", "dg", 30, "", false, "Dark|Grace"},
{"shroud_of_shadow", "sos", 30, "", false, "Shroud of|Shadow"},
{"ravenous_shadows", "rav", 40, "", false, "Ravenous|Shadows"},
{"aura_of_death", "ad", 40, "", false, "Aura Of|Death"}
						}

powerAliases["Pal"] =
						{
{ "shield_of_faith", "sf", 1, "", false, "Shield Of|Faith"},
{ "heroism", "hr", 1, "", false, "Heroism"},
{ "healing_light", "hl", 10, "", false, "Healing|Light"},
{ "aura_of_glory", "ag", 10, "", false, "Aura Of|Glory"},
{ "holy_sword", "hs", 20, "", false, "Holy|Sword"},
{ "cleansing_spirit", "cs", 20, "", false, "Cleaning|Spirit"},
{ "brand_of_judgement", "boj", 20, "", false, "Brand Of|Judgement"},
{ "shield_of_warding", "sw", 30, "", false, "Shield Of|Warding"},
{ "noble_shield", "ns", 30, "", false, "Noble|Shield"},
{ "divine_bolt", "db", 30, "", false, "Divine|Bolt"},
{ "sunburst", "sb", 40, "", false, "Sunburst"},
{ "aura_of_life", "al", 40, "", false, "Aura Of|Life"},
						} 

powerAliases["Dir"] =
						{
{ "vigorize_light", "vl", 1, "", true},
{ "detect_magic", "dm", 1, "", true},
{ "cure_light", "curel", 1, "autoheal", true, "Cure|Light"},
{ "sense_life", "sen", 6, "", true},
{ "create_water", "crw", 6, "", true},
{ "create_food", "cfood", 6, "", true},
{ "vigorize_serious", "vs", 11, "", true},
{ "faerie_fire", "ff", 11, "", true, "Faerie|Fire"},
{ "detect_invisibility", "di", 11, "", true},
{ "command_undead", "comu", 11, "", true, "Command|Undead"},
{ "bless", "bls", 11, "", true},
{ "poison", "pn", 16, "", true},
{ "jar_the_soul", "js", 16, "automissile", true, "Jar The|Soul"},
{ "invisibility", "invis", 16, "", true},
{ "cure_serious", "cs", 16, "autoheal", true, "Cure|Serious"},
{ "vigorize_critic", "vc", 21, "", true},
{ "protection_from_animals", "pfan", 21, "", true},
{ "heal_mount", "hm", 21, "", true, "Heal|Mount"},
{ "fear", "fe", 26, "", true},
{ "blindness", "bl", 26, "", true},
{ "totem_darts", "td", 6, "automissile", true, "Totem|Darts"},
{ "strength", "str", 31, "", true},
{ "dispel_magic", "dism", 31, "", true},
{ "barkskin", "bark", 31, "", true},
{ "minor_paralysis", "minp", 36, "", true},
{ "cure_critic", "ccr", 36, "autoheal", true, "Cure|Critic"},
{ "hex", "hx", 41, "", true, "Hex"},
{ "farsee", "fs", 41, "", true},
{ "poltergeist", "pg", 46, "autohlarea", true, "Poltergeist"},
{ "pass_without_trace", "pwt", 46, "", true}
						}

powerAliases["Dru"] = 
						{ 	
{ "shillelagh", "shl", 1, "automissile", true, "Shillelagh"},
{ "goodberry", "gdb", 1, "", true, "Good|Berry"},
{ "detect_magic", "dm", 1, "", true, "Detect|Magic"},
{ "cure_light", "curel", 1, "autoheal", true, "Cure|Light"},
{ "create_water", "crw", 1, "", true, "Create|Water"},
{ "cause_light", "caul", 1, "autoharm", true, "Cause|Light"},
{ "word_of_recall", "word", 6, "", true, "Word Of|Recall"},
{ "vigorize_light", "vl", 6, "", true, "Vigorize|Light"},
{ "protection_from_animals", "pfan", 6, "", true, "Prot From|Animals"},
{ "preserve", "prs", 6, "", true, "Preserve"},
{ "faerie_fire", "ff", 6, "autoffire", true, "Faerie|Fire"},
{ "detect_good", "dg", 6, "", true, "Detect|Good"},
{ "detect_evil", "de", 6, "", true, "Detect|Evil"},
{ "cure_serious", "cs", 6, "autoheal", true, "Cure|Serious"},
{ "cause_serious", "causs", 6, "autoharm", true, "Cause|Serious"},
{ "bless", "bls", 6, "", true, "Bless"},
{ "vigorize_serious", "vs", 11, "", true, "Vigorize|Serious"},
{ "summon_insects", "si", 11, "automissile", true, "Summon|Insects"},
{ "remove_poison", "rp", 11, "", true, "Remove|Poison"},
{ "protection_from_lightning", "pfl", 11, "", true, "Prot From|Lightning"},
{ "protection_from_gas", "pfg", 11, "", true},
{ "protection_from_fire", "pff", 11, "", true},
{ "protection_from_cold", "pfc", 11, "", true},
{ "protection_from_acid", "pfa", 11, "", true},
{ "faerie_fog", "ffog", 11, "", true, "Faerie|Fog"},
{ "barkskin", "bark", 11, "", true, "Barkskin"},
{ "transport_via_plants", "tvp", 16, "", true},
{ "summon", "sum", 16, "", true},
{ "sense_life", "sen", 16, "", true},
{ "earthquake", "eaq", 16, "autoquake", true, "Earth|Quake"},
{ "dust_devil", "dd", 16, "automissile", true, "Drust|Devil"},
{ "cure_critic", "ccr", 16, "autoheal", true, "Cure|Critic"},
{ "create_spring", "csp", 16, "", true, "Create|Spring"},
{ "cause_critical", "cauc", 16, "autoharm", true, "Cause|Critical"},
{ "vigorize_critic", "vc", 21, "", true, "Vigorize|Critic"},
{ "sunray", "sr", 21, "", true, "Sunray"},
{ "raise_dead", "rd", 21, "", true, "Raise|Dead"},
{ "harm", "hm", 21, "autoharm", true, "Harm"},
{ "dispel_magic", "dism", 21, "", true, "Dispel|Magic"},
{ "control_weather", "cnw", 21, "", true, "Control|Weather"},
{ "call_lightning", "call", 21, "autoarea", true, "Call|Lightning"},
{ "vitality", "vt", 26, "autovit", true, "Vitality"},
{ "suffocate", "suf", 26, "", true, "Suffocate"},
{ "insect_plague", "ip", 26, "autoarea", true, "Insect|Plague"},
{ "heal", "hl", 26, "autoheal", true, "Heal"},
{ "firestorm", "fst", 26, "autoarea", true, "Firestorm"},
{ "fear", "fe", 26, "", true, "Fear"},
{ "continual_light", "cnl", 26, "", true, "Continual|Light"},
{ "changestaff", "cstf", 26, "", true, "Change|Staff"},
{ "sticks_to_snakes", "sts", 6, "automissile", true, "Sticks To|Snakes"},
{ "pass_without_trace", "pwt", 31, "", true, "Pass Without|Trace"},
{ "group_vigorize", "gvig", 31, "", true, "Group|Vigorize"},
{ "flame_blade", "fb", 31, "autohlmissile", true, "Flame|Blade"},
{ "cyclone", "cy", 31, "autohlarea", true, "Cyclone"},
{ "water_breathing", "wb", 36, "", true, "Water|Breathing"},
{ "spiked_stones", "ss", 36, "autohlmissile", true, "Spiked|Stones"},
{ "rock_to_mud", "rktm", 36, "", true, "Rock To|Mud"},
{ "mud_to_rock", "mudtr", 36, "", true, "Mud To|Rock"},
{ "fire_seeds", "fs", 36, "autohlmissile", true, "Fire|Seeds"},
{ "hailstorm", "hs", 41, "autohlarea", true, "Hailstorm"},
{ "entangle", "eng", 41, "", true, "Entangle"},
{ "dessicate", "des", 41, "autohlarea", true, "Dessicate"},
{ "plane_shift", "psh", 41, "", true, "Plane|Shift"},
{ "group_barkskin", "gbark", 46, "", true, "Group|Barkskin"},
{ "creeping_doom", "cd", 46, "autohlarea", true, "Creeping|Doom"},
{ "moonwell", "mw", 46, "", true, "Moonwell"},
						}

powerAliases["Cle"] =
						{ 	
{ "detect_magic", "dm", 1, "", true},
{ "detect_good", "dg", 1, "", true},
{ "detect_evil", "de", 1, "", true},
{ "cure_light", "curel", 1, "autoheal", true, "Cure|Light"},
{ "create_water", "crw", 1, "", true, "Create|Water"},
{ "create_food", "cfood", 1, "", true, "Create|Food"},
{ "cause_light", "caul", 1, "autoharm", true, "Cause|Light"},
{ "armor", "am", 1, "", true},
{ "word_of_recall", "word", 6, "", true},
{ "vigorize_light", "vl", 6, "", true},
{ "slow_poison", "slp", 6, "", true},
{ "preserve", "prs", 6, "", true},
{ "cure_serious", "cs", 6, "autoheal", true, "Cure|Serious"},
{ "cause_serious", "causs", 6, "autoharm", true, "Cause|Serious"},
{ "bless", "bls", 6, "", true},
{ "vigorize_serious", "vs", 11, "", true},
{ "sense_life", "sen", 11, "", true},
{ "earthquake", "eaq", 11, "autoquake", true, "Earth|Quake"},
{ "dispel_good", "dispg", 11, "", true},
{ "dispel_evil", "dev", 11, "", true},
{ "cure_critic", "ccr", 11, "autoheal", true, "Cure|Serious"},
{ "cure_blind", "cb", 11, "", true},
{ "command_undead", "comu", 11, "", true, "Command|Undead"},
{ "cause_critical", "cauc", 11, "autoharm", true, "Cause|Critical"},
{ "ward_undead", "wu", 16, "turnundead", true, "Ward|Undead"},
{ "transport_via_plants", "tvp", 16, "", true},
{ "summon", "sum", 16, "", true},
{ "remove_poison", "rp", 16, "", true},
{ "remove_curse", "remc", 16, "", true},
{ "protection_from_lightning", "pfl", 16, "", true},
{ "protection_from_good", "pfd", 16, "", true},
{ "protection_from_gas", "pfg", 16, "", true},
{ "protection_from_fire", "pff", 16, "", true},
{ "protection_from_evil", "pfe", 16, "", true},
{ "protection_from_cold", "pfc", 16, "", true},
{ "protection_from_acid", "pfa", 16, "", true},
{ "flame_strike", "fs", 16, "automissile", true, "Flame|Strike"},
{ "blindness", "bl", 16, "", true},
{ "vitality", "vt", 21, "autovit", true, "Vitality"},
{ "vigorize_critic", "vc", 21, "", true},
{ "raise_dead", "rd", 21, "", true, "Raise|Dead"},
{ "heal", "hl", 21, "autoheal", true, "Heal"},
{ "dispel_magic", "dism", 21, "", true},
{ "silence_person", "sp", 26, "", true, "Silence|Person"},
{ "harm", "hm", 26, "autoharm", true, "Harm"},
{ "fear", "fe", 26, "", true, "Fear"},
{ "destroy_undead", "dun", 26, "turnundead", true, "Destroy|Undead"},
{ "darkness", "dkn", 26, "", true},
{ "curse_item", "curi", 26, "", true},
{ "curse", "cr", 26, "", true},
{ "continual_light", "cnl", 26, "", true},
{ "water_breathing", "wb", 31, "", true},
{ "group_vigorize", "gvig", 31, "", true},
{ "full_heal", "fh", 31, "autoheal", true, "Full|Heal"},
{ "full_harm", "fhm", 36, "autoharm", true, "Full|Harm"},
{ "eradicate_undead", "eu", 36, "turnundead", true, "Eradicate|Undead"},
{ "divine_purification", "dpu", 41, "", true},
{ "divine_blessing", "dvb", 41, "", true},
{ "greater_realm_of_protection", "realm", 46, "autorealm", true, "Greater|Realm"},
{ "divine_power", "dp", 16, "", true, "Divine|Power"},
{ "healing_aura", "ha", 36, "autoheal", true, "Healing|Aura"},
{ "righteous_might", "rm", 41, "", true},
{ "plane_shift", "psh", 41, "", true},
{ "resurrect", "resu", 46, "autores", true, "Resurrect"},
{ "unholy_word", "uw", 31, "autohlarea", true, "Unholy|Word"},
{ "holy_word", "hw", 31, "autohlarea", true, "Holy|Word"},
{ "disruption_burst", "db", 46, "turnundead", true, "Disruption|Burst"},
						}

powerAliases["Sha"] =
						{ 	
{ "cure_light", "curel", 1, "autoheal", true, "Cure|Light"},
{ "create_water", "crw", 1, "", true},
{ "create_food", "cfood", 1, "", true},
{ "cause_light", "caul", 1, "autoharm", true, "Cause|Light"},
{ "armor", "am", 1, "", true},
{ "vigorize_light", "vl", 6, "", true},
{ "spiritknife", "sk", 6, "automissile", true, "Spirit|Knife"},
{ "invisibility", "invis", 6, "", true},
{ "detect_magic", "dm", 6, "", true},
{ "detect_invisibility", "di", 6, "", true},
{ "detect_good", "dg", 6, "", true},
{ "detect_evil", "de", 6, "", true},
{ "cure_serious", "cs", 6, "autoheal", true, "Cure|Serious"},
{ "cause_serious", "causs", 6, "autoharm", true, "Cause|Serious"},
{ "bless", "bls", 6, "", true},
{ "word_of_recall", "word", 11, "", true},
{ "vigorize_serious", "vs", 11, "", true},
{ "sense_life", "sen", 11, "", true},
{ "remove_poison", "rp", 11, "", true},
{ "preserve", "prs", 11, "", true},
{ "jar_the_soul", "js", 11, "automissile", true, "Jar The|Soul"},
{ "blindness", "bl", 11, "", true},
{ "vigorize_critic", "vc", 16, "", true},
{ "unleash_fetish", "uf", 16, "automissile", true, "Unleash|Fetish"},
{ "minor_paralysis", "minp", 16, "", true},
{ "faerie_fire", "ff", 16, "autoffire", true, "Faerie|Fire"},
{ "earthquake", "eaq", 16, "autoquake", true, "Earth|Quake"},
{ "cure_critic", "ccr", 16, "autoheal", true, "Cure|Critic"},
{ "cure_blind", "cb", 16, "", true},
{ "cause_critical", "cauc", 16, "autoharm", true, "Cause|Critical"},
{ "summon", "sum", 21, "", true},
{ "slowness", "slow", 21, "", true},
{ "remove_curse", "remc", 21, "", true},
{ "raise_dead", "rd", 21, "", true},
{ "puppet", "pp", 21, "automissile", true, "Puppet"},
{ "protection_from_lightning", "pfl", 21, "", true},
{ "protection_from_good", "pfd", 21, "", true},
{ "protection_from_gas", "pfg", 21, "", true},
{ "protection_from_fire", "pff", 21, "", true},
{ "protection_from_evil", "pfe", 21, "", true},
{ "protection_from_cold", "pfc", 21, "", true},
{ "protection_from_acid", "pfa", 21, "", true},
{ "faerie_fog", "ffog", 21, "", true},
{ "command_undead", "comu", 21, "", true},
{ "stoneskin", "ss", 26, "autostone", true},
{ "ray_of_enfeeblement", "ray", 26, "", true},
{ "hex", "hx", 26, "", true},
{ "heal", "hl", 26, "autoheal", true, "Heal"},
{ "fear", "fe", 26, "", true},
{ "farsee", "fs", 26, "", true},
{ "dispel_magic", "dism", 26, "", true},
{ "continual_light", "cnl", 26, "", true},
{ "totem_darts", "td", 1, "automissile", true, "Totem|Darts"},
{ "vitality", "vt", 31, "autovit", true, "Vitality"},
{ "soul_tempest", "stp", 31, "autohlarea", true, "Soul|Tempest"},
{ "silence_person", "sp", 31, "", true},
{ "minor_globe_of_invulnerability", "mgi", 31, "", true},
{ "group_vigorize", "gvig", 31, "", true},
{ "darkness", "dkn", 31, "", true},
{ "water_breathing", "wb", 36, "", true},
{ "spirit_wrack", "sw", 36, "autohlmissile", true, "Spirit|Wrack"},
{ "missile_shield", "ms", 36, "", true},
{ "scry_remains", "screm", 36, "", true},
{ "control_weather", "cnw", 41, "", true},
{ "spirit_walk", "swalk", 41, "", true},
{ "plane_shift", "psh", 41, "", true},
{ "ancestral_fury", "afu", 46, "autohlarea", true, "Ancestral|Fury"},
{ "group_heal", "gh", 41, "autogh", true, "Group|Heal"},
{ "ancestral_shield", "ash", 46, "autoashield", true, "Ancestral|Shield"}
						}

powerAliases["Ill"] =
					   { 
{ "mage_flame", "mf", 1, "", true},
{ "erase", "erase", 1, "", true},
{ "detect_magic", "dm", 1, "", true},
{ "detect_invisibility", "di", 1, "", true},
{ "minor_creation", "minor", 6, "", true},
{ "invisibility", "invis", 6, "", true},
{ "faerie_fire", "ff", 6, "autoffire", true, "Faerie|Fire"},
{ "dispel_invisible", "disi", 6, "", true},
{ "blackthorns", "bt", 6, "automissile", true, "Black|Thorns"},
{ "phantom_armor", "pa", 11, "", true},
{ "mass_invisibility", "massi", 11, "", true},
{ "locate_object", "loco", 11, "", true},
{ "change_self", "chs", 11, "", true},
{ "teleport", "tele", 16, "", true},
{ "spook", "sp", 16, "automissile", true, "Spook"},
{ "scarlet_outline", "sct", 16, "autoffire", true, "Scarlet|Outline"},
{ "phantom_steed", "pst", 16, "", true},
{ "levitate", "lv", 16, "", true},
{ "farsee", "fs", 16, "", true},
{ "dispel_magic", "dism", 16, "", true},
{ "beautify", "btf", 16, "", true},
{ "true_sight", "ts", 21, "", true},
{ "shadow_magic", "shm", 21, "automissile", true, "Shadow|Magic"},
{ "shadow_burst", "sb", 21, "autoarea", true, "Shadow|Burst"},
{ "doppleganger", "dpl", 21, "autodoppel", true, "Dopple|Ganger"},
{ "dimension_door", "dim", 21, "", true},
{ "tranquility", "tq", 26, "", true},
{ "summon_shade", "shade", 26, "", true},
{ "nondetection", "non", 26, "", true},
{ "displacement", "ds", 26, "autodisplace", true, "Displcmnt"},
{ "clairvoyance", "clv", 26, "", true},
{ "shadow_bolt", "bolt", 1, "automissile", true, "Shadow|Bolt"},
{ "shadow_flux", "sf", 31, "", true},
{ "shadechill", "sh", 31, "autohlmissile", true, "Shadechill"},
{ "sequester", "sq", 31, "", true},
{ "phantasmal_blades", "pb", 31, "autohlarea", true, "Phantasml|Blades"},
{ "corpse_glamor", "cglam", 31, "", true},
{ "camouflage", "camo", 31, "", true},
{ "sun_shadow", "sshd", 36, "", true},
{ "rainbow_pattern", "rp", 36, "", true},
{ "phantom_heal", "pheal", 36, "autoheal", true, "Phantom|Heal"},
{ "mislead", "ml", 36, "", true},
{ "mirror_image", "mi", 36, "", true},
{ "feign_death", "fnd", 36, "", true},
{ "dimensional_fold", "fold", 36, "", true},
{ "phantasmal_killer", "pk", 41, "autohlmissile", true, "Phantasml|Killer"},
{ "massmorph", "massm", 41, "", true},
{ "gate", "gate", 41, "", true},
{ "shadow_walk", "swalk", 41, "", true},
{ "nightmare", "nm", 46, "autohlmissile", true, "Nightmare"},
{ "phantasmal_tendrils", "pt", 46, "autohlarea", true, "Phantasml|Tendrils"},
						}

powerAliases["Inv"] = {
{ "mage_flame", "mf", 1, "", true},
{ "erase", "erase", 1, "", true},
{ "detect_magic", "dm", 1, "", true},
{ "detect_invisibility", "di", 1, "", true},
{ "chill_touch", "ct", 1, "automissile", true, "Chill|Touch"},
{ "burning_hands", "bh", 1, "automissile", true, "Burning|Hands"},
{ "shocking_grasp", "sg", 6, "automissile", true, "Shocking|Grasp"},
{ "minor_creation", "minor", 6, "", true},
{ "faerie_fire", "ff", 6, "autoffire", true, "Faerie|Fire"},
{ "acid_blast", "acb", 6, "automissile", true, "Acid|Blast"},
{ "locate_object", "loco", 11, "", true},
{ "lightning_bolt", "lb", 11, "automissile", true, "Lightning|Bolt"},
{ "invisibility", "invis", 11, "", true},
{ "teleport", "tele", 16, "", true},
{ "ray_of_enfeeblement", "ray", 16, "", true},
{ "mordenkainens_sword", "msw", 16, "automissile", true, "Mordenkainens|Sword"},
{ "minor_paralysis", "minp", 16, "", true},
{ "levitate", "lv", 16, "", true},
{ "fireball", "fbl", 16, "autoarea", true, "Fireball"},
{ "farsee", "fs", 16, "", true},
{ "dispel_magic", "dism", 16, "", true},
{ "slowness", "slow", 21, "", true},
{ "infravision", "iv", 21, "", true},
{ "fireshield", "fsh", 21, "", true},
{ "dimension_door", "dim", 21, "", true},
{ "cone_of_cold", "cone", 21, "autoarea", true, "Cone Of|Cold"},
{ "ice_storm", "is", 21, "autoarea", true, "Ice Storm"},
{ "coldshield", "csh", 21, "", true},
{ "melfs_acid_arrow", "ma", 26, "automissile", true, "Melfs Acid|Arrow"},
{ "clairvoyance", "clv", 26, "", true},
{ "chain_lightning", "chain", 26, "", true},
{ "magic_missile", "mg", 1, "automissile", true, "Magic|Missile"},
{ "power_word_stun", "pws", 31, "", true},
{ "bigbys_clenched_fist", "bcf", 31, "autohlmissile", true, "Bigbys|Fist"},
{ "minute_meteors", "mm", 11, "automissile", true, "Minute|Meteors"},
{ "thunderblast", "tb", 36, "", true},
{ "major_paralysis", "mp", 36, "", true},
{ "force_missiles", "fm", 36, "autohlmissile", true, "Force|Missiles"},
{ "blazing_beam", "bb", 26, "automissile", true, "Blazing|Beam"},
{ "fell_frost", "frost", 41, "autohlmissile", true, "Fell|Frost"},
{ "sandblast", "sb", 46, "autohlmissile", true, "Sand|Blast"},
{ "incendiary_cloud", "ic", 31, "autohlarea", true, "Incendiary|Cloud"},
{ "meteorswarm", "ms", 41, "autohlarea", true, "Meteor|Swarm"},
{ "relocate", "relo", 41, "", true},
{ "gate", "gate", 41, "", true},
{ "ball_lightning", "bl", 46, "autohlarea", true, "Ball|Lightning"},
{ "inferno", "inf", 46, "autohlarea", true, "Inferno"},
{ "sandstorm", "ss", 46, "autostorm", true, "Sandstorm"},
}

powerAliases["Enc"] = 
						{
{ "mage_flame", "mf", 1, "", true},
{ "erase", "erase", 1, "", true},
{ "detect_magic", "dm", 1, "", true},
{ "detect_invisibility", "di", 1, "", true},
{ "minor_creation", "minor", 6, "", true},
{ "invisibility", "invis", 6, "", true},
{ "faerie_fire", "ff", 6, "autoffire", true, "Faerie|Fire"},
{ "energy_shield", "es", 6, "", true},
{ "chill_touch", "ct", 6, "automissile", true, "Chill|Touch"},
{ "burning_hands", "bh", 6, "automissile", true, "Burning|Hands"},
{ "strength", "str", 11, "", true},
{ "ray_of_enfeeblement", "ray", 11, "", true, "Enfeeble"},
{ "missile_shield", "ms", 11, "", true},
{ "locate_object", "loco", 11, "", true},
{ "dispel_invisible", "disi", 11, "", true},
{ "dexterity", "dex", 11, "", true},
{ "chromatic_orb", "co", 11, "automissile", true, "Chromatic|Orb"},
{ "blink", "bk", 11, "", true},
{ "wizard_eye", "weye", 16, "", true},
{ "teleport", "tele", 16, "", true},
{ "sleep", "slp", 16, "", true},
{ "minor_paralysis", "minp", 16, "", true},
{ "mass_invisibility", "massi", 16, "", true},
{ "lightning_bolt", "lb", 16, "automissile", true, "Lightning|Bolt"},
{ "levitate", "lv", 16, "", true},
{ "haste", "hs", 16, "", true},
{ "fumble", "fmb", 16, "", true},
{ "farsee", "fs", 16, "", true},
{ "dispel_magic", "dism", 16, "", true},
{ "stumble", "stm", 21, "", true},
{ "stoneskin", "ss", 21, "autostone", true},
{ "slowness", "slow", 21, "", true},
{ "minor_globe_of_invulnerability", "mgi", 21, "", true},
{ "infravision", "iv", 21, "", true},
{ "fireshield", "fsh", 21, "", true},
{ "dimension_door", "dim", 21, "", true},
{ "coldshield", "csh", 21, "", true},
{ "charm_person", "chp", 21, "", true},
{ "needle_swarm", "ns", 26, "automissile", true, "Needle|Swarm"},
{ "identify", "id", 26, "", true},
{ "fireball", "fbl", 26, "autoarea", true, "Fireball"},
{ "feeblemind", "feeb", 26, "", true},
{ "enervate", "env", 26, "", true},
{ "enchant_weapon", "enchw", 26, "", true},
{ "cone_of_cold", "cone", 26, "autoarea", true, "Cone Of|Cold"},
{ "clairvoyance", "clv", 26, "", true},
{ "blur", "bl", 26, "autoblur", true, "Blur"},
{ "magic_missile", "mg", 1, "automissile", true, "Magic|Missile"},
{ "solid_fog", "sfog", 31, "", true},
{ "repulsion", "rps", 31, "", true},
{ "reduce", "red", 31, "", true},
{ "power_word_blind", "pwb", 31, "", true},
{ "fly", "fly", 31, "", true},
{ "enlarge", "enl", 31, "", true},
{ "constriction", "cn", 41, "autohlmissile", true, "Cnstrctn"},
{ "prismatic_spray", "ps", 31, "autohlarea", true, "Prismatic|Spray"},
{ "major_paralysis", "mp", 36, "", true},
{ "globe_of_invulnerability", "gi", 36, "autoglobe", true},
{ "blacklight_burst", "bb", 36, "autohlarea", true, "Blacklight|Burst"},
{ "airy_water", "airy", 36, "", true},
{ "breach", "brc", 41, "", true},
{ "aura_of_the_griffon", "grf", 46, "", true},
{ "relocate", "relo", 41, "", true},
{ "mind_blank", "mb", 41, "", true},
{ "gate", "gate", 41, "", true},
{ "time_stop", "ts", 46, "autots", true, "Time Stop"},
{ "dragonscales", "ds", 46, "autoscale", true, "Dragon|Scales"}
						}

powerAliases["Ele"] =
						{ 	
{ "minor_creation", "minor", 1, "", true},
{ "mage_flame", "mf", 1, "", true},
{ "erase", "erase", 1, "", true},
{ "detect_invisibility", "di", 1, "", true},
{ "invisibility", "invis", 6, "", true},
{ "ice_spear", "is", 6, "automissile", true, "Ice|Spear"},
{ "detect_magic", "dm", 6, "", true},
{ "summon_elemental_kin", "ekin", 11, "", true},
{ "locate_object", "loco", 11, "", true},
{ "dispel_magic", "dism", 11, "", true},
{ "air_blast", "ab", 11, "automissile", true, "Air|Blast"},
{ "sleep", "slp", 16, "", true},
{ "ray_of_enfeeblement", "ray", 16, "", true},
{ "levitate", "lv", 16, "", true},
{ "fireball", "fbl", 16, "autoarea", true, "Fireball"},
{ "faerie_fog", "ffog", 16, "", true},
{ "thunder_lance", "tl", 21, "automissile", true, "Thunder|Lance"},
{ "teleport", "tele", 21, "", true},
{ "infravision", "iv", 21, "", true},
{ "glitterdust", "gl", 21, "autoblind", true, "Glitter|Dust"},
{ "fireshield", "fsh", 21, "", true},
{ "conjure_elemental", "ele", 21, "", true},
{ "coldshield", "csh", 21, "", true},
{ "stoneskin", "ss", 26, "autostone", true},
{ "feeblemind", "feeb", 26, "", true},
{ "earth_darts", "ed", 1, "automissile", true, "Earth|Darts"},
{ "earth_stones", "es", 26, "automissile", true, "Earth|Stones"},
{ "cone_of_cold", "cone", 26, "autoarea", true, "Cone of|Cold"},
{ "clairvoyance", "clv", 26, "", true},
{ "blizzard_sphere", "bs", 26, "autoarea", true, "Blizzard|Sphere"},
{ "ice_tongue", "it", 31, "", true},
{ "ice_layer", "il", 31, "", true},
{ "haste", "hs", 31, "pokehaste", true, "Haste"},
{ "elemental_water_embodiment", "ewe", 31, "", true},
{ "dimension_door", "dim", 31, "", true},
{ "whirlwind", "ww", 36, "autohlmissile", true, "Whirlwind"},
{ "power_word_stun", "pws", 36, "", true},
{ "power_word_blind", "pwb", 36, "", true},
{ "icewave", "iw", 36, "autohlarea", true, "Icewave"},
{ "firewave", "fw", 36, "autohlarea", true, "Firewave"},
{ "fire_fog", "fifog", 36, "", true},
{ "elemental_air_embodiment", "eae", 36, "", true},
{ "earth_fog", "efog", 36, "", true},
{ "earthblood", "eb", 41, "autohlmissile", true, "Earth|Blood"},
{ "relocate", "relo", 41, "", true},
{ "gate", "gate", 41, "", true},
{ "lava_burst", "lb", 46, "autohlarea", true, "Lava|Burst"},
{ "elemental_ward", "ew", 46, "autoward", true, "Elemental|Ward"},
{ "gate", "gate", 41, "", true},
{ "elemental_earth_embodiment", "eee", 41, "", true},
{ "elemental_fire_embodiment", "efe", 46, "", true},
					   }

powerAliases["Nec"] =
						{
{ "preserve", "prs", 1, "", true},
{ "mage_flame", "mf", 1, "", true},
{ "erase", "erase", 1, "", true},
{ "detect_magic", "dm", 1, "", true},
{ "detect_invisibility", "di", 1, "", true},
{ "animate_skeleton", "skel", 1, "", true},
{ "protection_from_undead", "pfu", 6, "autopfu", true, "Prot From|Undead"},
{ "protection_from_cold", "pfc", 6, "", true},
{ "minor_creation", "minor", 6, "", true},
{ "invisibility", "invis", 6, "", true},
{ "command_undead", "comu", 6, "", true},
{ "chill_touch", "ct", 6, "automissile", true, "Chill|Touch"},
{ "animate_zombie", "zomb", 6, "", true},
{ "soul_bind", "sb", 11, "", true},
{ "rejuvenate_minor", "rjm", 11, "", true},
{ "pain_touch", "pt", 11, "automissile", true, "Pain|Touch"},
{ "animate_ghoul", "ghoul", 11, "", true},
{ "wither", "wt", 16, "", true},
{ "strength", "str", 16, "", true},
{ "spectral_hand", "sh", 16, "automissile", true, "Spectral|Hand"},
{ "sleep", "slp", 16, "", true},
{ "dispel_magic", "dism", 16, "", true},
{ "command_horde", "comh", 16, "", true},
{ "animate_shadow", "shadow", 16, "", true},
{ "teleport", "tele", 21, "", true},
{ "snapping_teeth", "snp", 21, "automissile", true, "Snapping|Teeth"},
{ "ray_of_enfeeblement", "ray", 21, "", true},
{ "levitate", "lv", 21, "", true},
{ "infravision", "iv", 21, "", true},
{ "ice_storm", "is", 21, "autoarea", true, "Ice Storm"},
{ "heal_undead", "hu", 21, "autoheal", true, "Heal|Undead"},
{ "feeblemind", "feeb", 21, "", true},
{ "energy_drain", "ed", 21, "automissile", true, "Energy|Drain"},
{ "cone_of_cold", "cone", 21, "autoarea", true, "Cone Of|Cold"},
{ "coldshield", "csh", 21, "", true},
{ "animate_wight", "wight", 21, "", true},
{ "ward_undead", "wu", 26, "turnundead", true, "Ward|Undead"},
{ "vampiric_touch", "vt", 26, "", true},
{ "rejuvenate_major", "rejuv", 26, "", true},
{ "nerve_dance", "nd", 26, "automissile", true, "Nerve|Dance"},
{ "minor_globe_of_invulnerability", "mgi", 26, "", true},
{ "animate_ghast", "ghast", 26, "", true},
{ "age", "age", 26, "", true},
{ "magic_missile", "mg", 1, "automissile", true, "Magic|Missile"},
{ "protect_undead", "pu", 31, "", true},
{ "haste", "hs", 31, "pokehaste", true, "Haste"},
{ "dimension_door", "dim", 31, "", true},
{ "corpse_glamor", "cglam", 31, "", true},
{ "beltyns_burning_blood", "bbb", 31, "autohlmissile", true, "Burning|Blood"},
{ "animate_wraith", "wraith", 31, "", true},
{ "soul_shackles", "ssh", 36, "", true},
{ "destroy_undead", "dun", 36, "turnundead", true, "Destroy|Undead"},
{ "contagion", "ctg", 36, "", true},
{ "blackmantle", "bm", 36, "", true},
{ "animate_spectre", "spect", 36, "", true},
{ "globe_of_invulnerability", "gi", 41, "autoglobe", true},
{ "eradicate_undead", "eu", 41, "turnundead", true, "Eradicate|Undead"},
{ "animate_ghost", "ghost", 41, "", true},
{ "vampiric_curse", "vc", 41, "autovcurse", true, "Vampiric|Curse"},
{ "life_walk", "lwalk", 41, "", true},
{ "soul_walk", "soul", 41, "", true},
{ "abi_dalzims_horrid_wilting", "abi", 41, "autohlmissile", true, "Horrid|Wilting"},
{ "rain_of_blood", "rb", 46, "autohlarea", true, "Rain Of|Blood"},
{ "boneshatter", "bs", 46, "autohlmissile", true, "Boneshatter"},
{ "banshee_wail", "bw", 46, "autowail", true, "Banshee|Wail"},
{ "annihilate_undead", "au", 46, "turnundead", true, "Annihilate|Undead"}
					   }	

powerAliases["Lic"] =
						{ 	
{ "preserve", "prs", 1, "", true},
{ "mage_flame", "mf", 1, "", true},
{ "erase", "erase", 1, "", true},
{ "detect_magic", "dm", 1, "", true},
{ "detect_invisibility", "di", 1, "", true},
{ "animate_skeleton", "skel", 1, "", true},
{ "protection_from_undead", "pfu", 6, "autopfu", true, "Prot From|Undead"},
{ "protection_from_cold", "pfc", 6, "", true},
{ "minor_creation", "minor", 6, "", true},
{ "invisibility", "invis", 6, "", true},
{ "command_undead", "comu", 6, "", true},
{ "chill_touch", "ct", 6, "automissile", true, "Chill|Touch"},
{ "animate_zombie", "zomb", 6, "", true},
{ "soul_bind", "sb", 11, "", true},
{ "rejuvenate_minor", "rjm", 11, "", true},
{ "pain_touch", "pt", 11, "automissile", true, "Pain|Touch"},
{ "animate_ghoul", "ghoul", 11, "", true},
{ "wither", "wt", 16, "", true},
{ "strength", "str", 16, "", true},
{ "spectral_hand", "sh", 16, "automissile", true, "Spectral|Hand"},
{ "sleep", "slp", 16, "", true},
{ "embalm", "emm", 16, "", true},
{ "dispel_magic", "dism", 16, "", true},
{ "command_horde", "comh", 16, "", true},
{ "animate_shadow", "shadow", 16, "", true},
{ "teleport", "tele", 21, "", true},
{ "snapping_teeth", "snp", 21, "automissile", true, "Snapping|Teeth"},
{ "ray_of_enfeeblement", "ray", 21, "", true},
{ "levitate", "lv", 21, "", true},
{ "infravision", "iv", 21, "", true},
{ "ice_storm", "is", 21, "autoarea", true, "Ice Storm"},
{ "heal_undead", "hu", 21, "autoheal", true, "Heal|Undead"},
{ "feeblemind", "feeb", 21, "", true},
{ "energy_drain", "ed", 21, "automissile", true, "Energy|Drain"},
{ "cone_of_cold", "cone", 21, "autoarea", true, "Cone Of|Cold"},
{ "coldshield", "csh", 21, "", true},
{ "animate_wight", "wight", 21, "", true},
{ "ward_undead", "wu", 26, "turnundead", true, "Ward|Undead"},
{ "vampiric_touch", "vt", 26, "", true},
{ "rejuvenate_major", "rejuv", 26, "", true},
{ "nerve_dance", "nd", 26, "automissile", true, "Nerve|Dance"},
{ "minor_globe_of_invulnerability", "mgi", 26, "", true},
{ "animate_ghast", "ghast", 26, "", true},
{ "age", "age", 26, "", true},
{ "magic_missile", "mg", 1, "automissile", true, "Magic|Missile"},
{ "protect_undead", "pu", 31, "", true},
{ "locate_remains", "locr", 31, "", true},
{ "haste", "hs", 31, "pokehaste", true, "Haste"},
{ "dimension_door", "dim", 31, "", true},
{ "corpse_glamor", "cglam", 31, "", true},
{ "beltyns_burning_blood", "bbb", 31, "autohlmissile", true, "Burning|Blood"},
{ "animate_wraith", "wraith", 31, "", true},
{ "soul_shackles", "ssh", 36, "", true},
{ "life_drain", "ld", 36, "autohlmissile", true, "Life|Drain"},
{ "destroy_undead", "dun", 36, "turnundead", true, "Destroy|Undead"},
{ "contagion", "ctg", 36, "", true},
{ "blackmantle", "bm", 36, "", true},
{ "animate_spectre", "spect", 36, "", true},
{ "lich_touch", "lt", 41, "autohlmissile", true, "Lich|Touch"},
{ "globe_of_invulnerability", "gi", 41, "autoglobe", true},
{ "eradicate_undead", "eu", 41, "turnundead", true, "Eradicate|Undead"},
{ "animate_ghost", "ghost", 41, "", true},
{ "abi_dalzims_horrid_wilting", "abi", 41, "autohlmissile", true, "Horrid|Wilting"},
{ "rain_of_blood", "rb", 46, "autohlarea", true, "Rain Of|Blood"},
{ "rot", "rot", 46, "autohlarea", true, "Living|Rot"},
{ "ice_tomb", "it", 46, "autohlmissile", true, "Ice Tomb"},
{ "death_pact", "dp", 46, "autopact", true, "Death Pact"},
{ "banshee_wail", "bw", 46, "autowail", true, "Banshee|Wail"},
{ "siphon_undead", "su", 46, "turnundead", true, "Siphon|Undead"}
					   }</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Button Format Header</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- these are buttons not defined in 'Spell Powers Header'

buttonText = 
						{	

mysizeDisplay= { "T", "S", "M", "L", "H"},

TiaMask = { "Tentacle|Rings"},
TiaSleeves= { "Mystic|Sleeves"},
TiaSandals= {"Tiamat|Sandals"},
baatorian= {"Slaad"},
TiaStaff= {"Ancient|Staff"},
TiaClaws= {"Gelugon|Claws"},
TiaLoop= {"Fighter's|Loop"},
TiaManacle= {"Mesh|Manacle"},
TiaVolance= {"Band Of|Volance"},
TiaScale= {"Silvered|Scale"},
TiaBracers= {"Time|Bracers"},
TiaCincture= { "Cincture" },
TiaWarder= {"Warder|Cloak"},
VermSleeves= {"Vermillion|Sleeves"},
TiaValhalla= {"Valhalla|Scepter", "Valhalla|Berserk", "Valhalla|Defend"},
TiaStability= {"Boots Of|Stability"},
TiaOcular= {"Ocular|Disc"},
SuppleGirdle= {"Supple|Girdle"},
AshenStaff= {"Ashen|Soul"},
FrenziedGrin= {"Frenzied|Grin"},
DragonCult= {"Dragonclt|Robes"},
TiaWarmaul= {"War|Maul"},
TiaBane= {"Bane"},


-- misc buttons

auto_heal = { "Auto|Heal" },

MemButton = { "Memorize", "Meditate", "Pray", "Stand" },


pet_rescue = { "Pet|Rescue", "PetRescue|ME", "PetRescue|ALL"},


-- dire

howl = { "Howl" },
bash = { "Bash" },


-- bard/battlechanter

barBless = {"Bless"},
StopMusic = {"Stop|Music"},
RegenSong = {"Regen"},
HealSong = {"Heal"},
HasteSong = {"Haste"},
SlowSong = {"Slow"},
HarmSong = {"Harm"},
RenewSong = {"Renew"},
ProtectSong = {"Protect"},
TravelSong = { "Travel"},
Accompany = {"Accompany"},

-- Warrior

rescue={"Rescue|Off", "Rescue|Basic", "Rescue|All"},

combat_challenge={"Combat|Challenge"},
warriors_ultimatum={"Warriors|Ultimatum"},
comeback_strike={"Comeback|Strike"},
shield_bash={"Shield|Bash"},
defensive_strike={"Defensive|Strike"},
brutal_strike={"Brutal|Strike"},
relentless_assault={"Relentless|Assault"},
cleave={"Cleave"},
spinning_sweep={"Spinning|Sweep"},
skullcrusher={"Skull|Crusher"},
unyielding_avalanche={"Unyieldng|Avalnche"},
rain_of_steel={"Rain Of|Steel"},
unstoppable={"Un|Stoppable"},
vigilant_protector={"Vigilant|Protector"},

-- rogue
							
assassinate = {"Assassinate"},
trip = {"Trip"},
circle = {"Circle"},
poisonRogue = {"Poison"},
autohide = {"Auto|Hide"},
							
-- psi

ultrablast={"Ultra|Blast"},
deathfield={"Death|Field"},
battletrance={"Battle|Trance"},
tower={"Tower Of|Iron Will"},
combatmind={"Combat|Mind"},
psidarkness={"Auto|Hide"},
wormhole={"Worm|Hole"},
							
-- blackguard
							
soul_touch = {"Soul|Touch"},
dread_smite= {"Dread|Smite"},
dominating_smite = {"Domnatng|Smite"},
sigil_of_pain = {"Sigil Of|Pain"},
damage_spells = {"Damage|Spells"},
aura_of_death = {"Aura Of|Death"},
shroud_of_shadow = {"ShroudOf|Shadow"},
dark_majesty = {"Dark|Majesty"},
ruinous_smite = {"Ruinous|Smite"},
baleful_challenge = {"Baleful|Challenge"},
plundering_smite = {"Plundrng|Smite"},
frenzying_smite = {"Frenzying|Smite"},
shattering_smite = {"Shattering|Smite"},
mortal_dread = {"Mortal|Dread"},
spirit_harrow = {"Spirit|Harrow"},
vengeance_strike = {"Vengeance|Strike"},
uncontrolled_fury = {"Uncntrld|Fury"},

-- ranger
							
sweeping_strike={"Sweeping|Strike"},
misty_path={"Misty|Path"},
hunters_mark={"Hunters|Mark"},
blades_of_fire={"Blades|Of Fire"},
greenfire={"Greenfire"},
electric_discharge={"Electric|Discharge"},
twin_strike={"Twin|Strike"},
eviscerate={"Evscerate"},
armor_splinter={"Armor|Splinter"},
bladestorm={"Blade|Storm"},
cloak_of_protection={"Cloak Of|Protect"},
cloak_of_the_winds={"The|Winds"},
cloak_of_resilience={"Resilience"},
auto_heal={"Auto|Heal"},
knockdown_shot={"Knckdown|Shot"},
hail_of_thorns={"Hail Of|Thorns"},
arctic_barrage={"Arctic|Barrage"},
lightning_arrow={"Lightning|Arrow"},
triple_shot={"Triple|Shot"},
concussive_shot={"Concusve|Shot"},
splintering_shot={"Splinter|Shot"},
hail_of_arrows={"Hail Of|Arrows"},
							
--paladin

guard={"Guard"},

lay_on_hands={"Lay On|Hands"},
divine_smite={"Divine|Smite"},
radiant_charge={"Radiant|Charge"},
brand_of_judgement={"Brand Of|Judgement"},
aura_of_life={"Aura Of|Life"},
shield_of_warding={"Shield Of|Warding"},
shielding_smite={"Shielding|Smite"},
enervating_smite={"Enervating|Smite"},
divine_challenge={"Divine|Challenge"},
bolstering_strike={"Bolsterng|Strike"},
wrathful_smite={"Wrathful|Smite"},
thunderous_smite={"Thunder|Smite"},
brilliant_smite={"Brilliant|Smite"},
terrifying_smite={"Terror|Smite"},
valiant_strike={"Valiant|Strike"},
whirlwind_smite={"Whirlwind|Smite"},

-- enchanter

encSelf= {"Self"},
encResize= { "Resize", "Resize|Small", "Resize|Large", "Resize|All" },

globe_of_invulnerability= { "Globe Of|Invul", "Globe|Hitters" },
stoneskin= {"Stoneskin", "Stoneskin|Rogues", "Stoneskin|Self", "Stoneskin|Tanks"},

time_stop= { "Time Stop" },

-- illusionist

massmorph= { "Mass|Morph" },

-- necro/lich

SoulShackleButton = {"Soul|Shackles"},

							 }
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sqlfunctions</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function sqlinwho(xname)
	local recs, row
	local profilename

	recs = assert(NyyLIB.conn:execute([[SELECT class_name, char_race, account_name FROM chars WHERE char_name = ']] .. xname .. [[']]))

	row = recs:fetch({})

	recs:close()
	
	if row == nil then
		return(false)
	else
		for k, v in pairs(NyyLIB.fullclasslist) do
			if v[1] == row[1]:trim()	 then
				whoadd(xname, v[2], row[2], row[3])
				profilename = row[3]
				--echo("\n[Adding - " .. xname .. " " .. v[2] .. " " .. row[2] .. "]\n")
			end
		end

		return(profilename)
	end
end

function sqlprofilename(xname)
	local recs, row

	recs = assert(NyyLIB.conn:execute([[SELECT class_name, char_race, account_name FROM chars WHERE char_name = ']] .. xname .. [[']]))

	row = recs:fetch({})

	recs:close()
	
	if row == nil then
		--echo(" [Not found in database]\n")
		return(false)
	else
		return(row[3])
	end
end

function sqlclist(xname)
	local recs, row

	local retval = {}

	recs = assert(NyyLIB.conn:execute([[
				SELECT char_name, class_name, char_race, char_level, account_name FROM 
				chars WHERE vis = 't' AND (account_name = (SELECT account_name 
				FROM chars WHERE LOWER(char_name) = LOWER(']] .. xname .. [[') AND vis = 't') OR 
				LOWER(account_name) = LOWER(']] .. xname .. [[')) ORDER BY char_level DESC, 
				char_name ASC]]))

	row = recs:fetch({})

	while row do
		retval[#retval+1] = {row[4], row[2], row[1], row[3], row[5]}
		row= recs:fetch({})
	end

	recs:close()

	return(retval)
end

function sqliditem(xitemname)
	local recs, row

	local retval = {}

	-- remove trailing (poisoned) from name	
	xitemname=string.gsub(xitemname, "%(poisoned%)", "")
	xitemname= xitemname:trim()

	xitemname=string.gsub(xitemname, "'", "''")

	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_name LIKE '%]] .. xitemname .. [[%']]))

	row = recs:fetch({})

	while row do
		retval[#retval+1] = row[2]
		row = recs:fetch({})
	end

	recs:close()
	
	return(retval)
end

function sqlIsWeapon(xitemname)
	local recs, row

	local retval = {}

	xitemname=string.gsub(xitemname, "'", "''")

	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE (item_type = 'weapon' or item_type = "ranged") AND item_name LIKE '%]] .. xitemname .. [[%']]))

	row = recs:fetch({})

	while row do
		retval[#retval+1] = row[2]
		row = recs:fetch({})
	end

	recs:close()
	
	return(retval)
end


function sqlIsBow(xitemname)
	local recs, row

	local retval = {}

	xitemname=string.gsub(xitemname, "'", "''")

	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'ranged' AND item_name LIKE '%]] .. xitemname .. [[%']]))

	row = recs:fetch({})

	while row do
		retval[#retval+1] = row[2]
		row = recs:fetch({})
	end

	recs:close()
	
	return(retval)
end

function sqlIs2H(xitemname)
	-- return list of matching 2h weapons

	local recs, row

	local retval = {}

	xitemname=string.gsub(xitemname, "'", "''")

	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items, item_flags WHERE item_type = 'weapon' AND
																							 item_name LIKE '%]] .. xitemname .. [[%']] ..
																							 [[ AND item_flags.item_id = items.item_id AND item_flags.flag_abbr = 'two_hand']] 
																							 			 ))

	row = recs:fetch({})

	while row do
		retval[#retval+1] = row[2]
		row = recs:fetch({})
	end

	recs:close()
	
	return(retval)
end


function sqlindexitem(xitemname)
	local recs, row

	local retval = {}

	xitemname=string.gsub(xitemname, "'", "''")

	recs = assert(NyyLIB.conn:execute([[SELECT rowid, item_name FROM items WHERE item_name LIKE '%]] .. xitemname .. [[%']]))

	row = recs:fetch({})

	while row do
		display(row[1])
		display(row[2])
		retval[#retval+1] = row[2]
		row = recs:fetch({})
	end

	recs:close()
	
	return(retval)
end

function createconsumabledb()
	local recs, row

	NyyLIB.itemdb = NyyLIB.itemdb or {}

	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'potion']]))

	row = recs:fetch({})

	while row do
		if string.find(row[2], "%(Potion%) ") ~= nil then
			local st, en, retval

			st, en, retval = string.find (row[2], "%(Potion%)([A-Za-z0-9: -]+)%*")

			NyyLIB.itemdb[row[1]]={"potion", retval:trim()}
		end

		row= recs:fetch({})
	end

	recs:close()

	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'scroll']]))

	row = recs:fetch({})

	while row do
		if string.find(row[2], "%(Scroll%) ") ~= nil then
			local st, en, retval

			st, en, retval = string.find (row[2], "%(Scroll%)([A-Za-z0-9: -]+)%*")

			NyyLIB.itemdb[row[1]]={"scroll", retval:trim()}
		end

		row= recs:fetch({})
	end

	recs:close()

	--recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'wand']]))

	--row = recs:fetch({})

	--while row do
	--	if string.find(row[2], "%(Wand%) ") ~= nil then
	--		local st, en, retval

	--		st, en, retval = string.find (row[2], "%(Wand%)([A-Za-z0-9: -]+)%*")

	--		NyyLIB.itemdb[row[1]]={"wand", retval:trim()}
	--	end

	--	row= recs:fetch({})
	--end

	--recs:close()

	--recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'staff']]))

	--row = recs:fetch({})

	--while row do
	--	if string.find(row[2], "%(Staff%) ") ~= nil then
	--		local st, en, retval

	--		st, en, retval = string.find (row[2], "%(Staff%)([A-Za-z0-9: -]+)%*")

	--		NyyLIB.itemdb[row[1]]={"staff", retval:trim()}
	--	end

	--	row= recs:fetch({})
	--end

	--recs:close()


	recs = assert(NyyLIB.conn:execute([[SELECT item_name, short_stats FROM items WHERE item_type = 'poison']]))

	row = recs:fetch({})

	while row do
		if string.find(row[2], "%(Poison%) ") ~= nil then
			local st, en, retval

			st, en, retval = string.find (row[2], "%(Poison%)([A-Za-z0-9: -]+)%*")

			NyyLIB.itemdb[row[1]]={"poison", retval:trim()}
		end

		row= recs:fetch({})
	end

	recs:close()


	cecho("&lt;red&gt;[Consumable database cached: Potions, Scrolls, Poisons]\n")
end


function sqlwhoclass(xname)
	display(NyyLIB.conn)

	recs = assert(NyyLIB.conn:execute([[SELECT class_name FROM chars WHERE char_name LIKE ']] .. xname .. [[']]))

	row = recs:fetch({})

	while row do
	
		echo ( row[1] .. "\n")
		row = recs:fetch({})
	end

	recs:close()

end





function opendb()
	NyyLIB.env = assert (luasql.sqlite3())
	
	NyyLIB.conn = assert (NyyLIB.env:connect(mainpath("toril.db")))

	display(NyyLIB.conn)
end

function closedb()
	cecho("&lt;red&gt;[Closing database]\n")
	NyyLIB.conn:close()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tiapoints</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


-- @([A-Za-z]+) - ([0-9]+)
-- \1=\2,

TiamatPoints={
Adriorn=0,
Aetius=200,
Afu=200,
Alak=0,
Alane=0,
Alimam=0,
Anashoa=475,
Andreww=150,
Annam=0,
Areh=200,
Arete=0,
Arrithes=0,
Ashades=0,
Azralek=100,
Babo=0,
Banducci=100,
Baram=375,
Beern=0,
Berrin=80,
Blaez=100,
Cobu=200,
Con=150,
Dagk=400,
Damet=0,
Delkor=400,
Delmair=100,
Deshana=435,
Diel=0,
Diggz=300,
Dixa=0,
Donny=300,
Drabyl=400,
Drahken=200,
Drake=465,
Draqus=75,
Drakkochian=100,
Druzix=0,
Duard=200,
Elscint=0,
Enth=100,
Etrangere=100,
Ezwar=300,
Fibble=0,
Fkteval=0,
Flib=100,
Flyngspaghetti=175,
Frensolith=500,
Gehadron=0,
Gene=0,
George=825,
Gerin=200,
Getaris=100,
Gindipple=0,
Gormal=0,
Graum=100,
Grundar=75,
Gruuggh=550,
Gubody=0,
Gyrx=0,
Hamwich=100,
Hefa=275,
Hibbidy=100,
Hue=425,
Hyla=0,
Iamtux=100,
Ice=100,
Ikhar=200,
Iledor=50,
Inames=200,
Isisa=0,
Jacob=0,
Jasix=0,
Jaul=100,
Jhira=265,
Jimak=200,
Jkersey=325,
Jlewis=100,
John=100,
Justmefjs=50,
Kaern=0,
Kajj=235,
Kalantha=200,
Kanenan=0,
Kathal=100,
Kayos=0,
Kelemon=0,
Kidus=0,
Kimi=200,
Klandan=35,
Klosh=100,
Koric=200,
Koxa=0,
Kramel=100,
Krimic=0,
Kugol=400,
Kuno=180,
Kwirl=100,
Lenen=0,
Lienna=375,
Lilithelle=400,
Lilmeshay=0,
Lopi=100,
Lusas=100,
Maxler=300,
Mayoung=100,
Mij=0,
Mikempty=0,
Misi=0,
Mrizzalazzrazzi=0,
Mrorange=625,
Mung=200,
Myrranth=200,
Naled=0,
Nerox=50,
Netonosel=250,
Nolumakil=0,
Ntwolfgang=0,
Nurpy=300,
Nyyrazzilyss=1325,
Oggsk=50,
Onut=0,
Osheara=0,
Oteb=0,
Ozzec=100,
Parsnip=400,
Pibbinivil=0,
Popinoples=350,
Qaz=300,
Quinn=100,
Raronsil=0,
Redgoat=200,
Rhazien=0,
Rirus=0,
Riwer=100,
Rorg=50,
Rouse=525,
Ruagh=0,
Saerian=100,
Saitcho=100,
Samiam=0,
Sasin=150,
Sekfarok=325,
Selshanar=0,
Shoshana=0,
Silena=100,
Silvenleif=0,
Sipes=1000,
Solah=100,
Ssezef=0,
Stephanie=500,
Stoutwoodarcanos=0,
Sulaco=100,
Susab=150,
Syrac=200,
Tafi=0,
Talomis=100,
Tanji=100,
Teresias=65,
Thegnome=100,
Tibek=100,
Tilsen=250,
Timok=0,
Todd=200,
Toraza=175,
Torlin=100,
Torsoul=300,
Travok=0,
Turg=100,
Turtle=200,
Turxx=0,
Tyndall=200,
Typographer=0,
Utheba=100,
Venlarin=75,
Verarb=400,
Violeti=300,
Vooku=1100,
Wired=100,
Wobb=0,
Xboomx=300,
Xilissisix=100,
Xuter=0,
Yadir=100,
Ykor=200,
Yog=100,
Yxageirr=175,
Zarel=100,
Zellas=300,
Zepharian=0,
Zerogod=0,
Zipalodok=100,
Zoe=200,
Zusuk=600
}


function getPoints(xprofile)
	if TiamatPoints[xprofile] ~= nil then
		return(TiamatPoints[xprofile])
	end

	return(0)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>StatsScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function groupStatsDisplay(xcharname)
	local profilename=inwho(xcharname)
	local temp = whoclass(xcharname)

	
	if not charData:get("group", true) then
		return
	end

	if temp ~= nil then
		if temp ~= "UNK" then
			local hits = getHits(xcharname)
			local attacks = getAttacks(xcharname)

			local cntRescueFail=getStat(xcharname, "failedrescue")
			local cntRescueSuccess=getStat(xcharname, "successrescue")


-- 			cecho(string.format("%" .. (16-string.len(xcharname)) .. "s", " "))

  			cecho(string.format("&lt;cyan&gt;%5.1f%% (%4d)", 
						(hits*100)/attacks,
						attacks))

			
			if cntRescueFail+cntRescueSuccess ~= 0 then
				cecho(string.format("&lt;cyan&gt;%5.1f%% (%4d)   ", 
							cntRescueSuccess*100/(cntRescueFail+cntRescueSuccess),
							cntRescueFail+cntRescueSuccess))
			end

			echo("\n")
		end
	else
		echo(" [ Unknown ]\n")
	end
end

function resetStats()
	cecho("\n&lt;red&gt;[Resetting stats counters.]\n")

	NyyLIB.stats = {}
end

function addStat(xcharname, xstatname)
	NyyLIB.stats = NyyLIB.stats or {}

	if xcharname == "Someone" or xcharname == nil then
		return
	end

	echoDebug(" &lt;red&gt;[ &lt;cyan&gt;addStat(" .. xcharname .. "," .. xstatname .. ") &lt;red&gt;]\n")

	if NyyLIB.stats[xcharname] == nil then
		NyyLIB.stats[xcharname] = {}
	end

	if NyyLIB.stats[xcharname][xstatname] == nil then
		NyyLIB.stats[xcharname][xstatname] = 0
	end

	NyyLIB.stats[xcharname][xstatname] = NyyLIB.stats[xcharname][xstatname] + 1
end

function getStat(xcharname, xstatname)
	if NyyLIB.stats[xcharname] == nil then
		-- echo("\n[" .. xstatname .. " on " .. xcharname .. " is nil stat]\n")
		NyyLIB.stats[xcharname]={}
	end

	if NyyLIB.stats[xcharname][xstatname] == nil then
		-- echo("\n[" .. xstatname .. " on " .. xcharname .. " is nil stat]\n")
		
		NyyLIB.stats[xcharname][xstatname]=0
	end

	return ( NyyLIB.stats[xcharname][xstatname] )
end

function getHits(xcharname)

	local c_offHit = getStat(xcharname, "offHit")
	local c_offParry = getStat(xcharname, "offParry")
	local c_offDodge = getStat(xcharname, "offDodge")
	local c_offdeflect = getStat(xcharname, "offDeflect")

	local c_offShieldBlock = getStat(xcharname, "offShieldBlock")	

	local c_offMiss = getStat(xcharname, "offMiss")

	local c_all=c_offHit+ c_offMiss + c_offParry + c_offdeflect + c_offDodge + c_offShieldBlock

	local c_adjhit=c_all-c_offMiss

	return(c_adjhit)
end

function getAttacks(xcharname)

	local c_offHit = getStat(xcharname, "offHit")
	local c_offParry = getStat(xcharname, "offParry")
	local c_offDodge = getStat(xcharname, "offDodge")
	local c_offdeflect = getStat(xcharname, "offDeflect")

	local c_offShieldBlock = getStat(xcharname, "offShieldBlock")	

	local c_offMiss = getStat(xcharname, "offMiss")

	local c_all=c_offHit+ c_offMiss + c_offParry + c_offdeflect + c_offDodge + c_offShieldBlock


	return(c_all)
end


function printDeaths()
	local deathcount={}
	local nx=0


	for k,v in pairs(NyyLIB.stats) do
		deathcount[k]= getStat(k, "death")

		--echo( string.format("%15s %d\n", k, getStat(k, "death") ) )
	end

	cecho ("&lt;blue&gt;gcc * &lt;red&gt;... DEATH Top 20 ...\n")

	for k,v in spairs(deathcount, function(t, a, b) return (t[a]&gt;t[b]) end) do
		nx=nx+1

		if nx &lt; 21 then
			cecho( string.format("&lt;blue&gt;gcc * &lt;green&gt;%-14s %d\n", k, getStat(k, "death") ) )
		end
	end

end

function printHeals(xmode)
	local gheals={}
	local gotfullheal={}
	local gothealingaura={}

	local prefix = "&lt;blue&gt;gcc "

	for k,v in pairs(NyyLIB.stats) do
		if getStat(k, "GroupHeal") ~= 0 then
			gheals[k] = {getStat(k, "GroupHeal"), getStat(k, "Vitality") }
			-- echo(k .. " Group Heal: " .. getStat(k, "GroupHeal") .. " Vitality: " .. getStat(k, "Vitality") .. "\n")
		end

		if getStat(k, "gotHealingAura") ~= 0 or getStat(k, "gotFullHeal") ~= 0  then
			gothealingaura[k] = getStat(k, "gotHealingAura")
			gotfullheal[k] = getStat(k, "gotFullHeal")
		end

		--if getStat(k, "Vitality") ~= 0 then
		--	echo(k .. " Vitality: " .. getStat(k, "Vitality") .. "\n")
		--end
	end

	cecho(prefix .. "* &lt;red&gt;............... Heal F-Heal G-Heal Aura Vit\n")

	if xmode == "3" then
		cecho( "&lt;blue&gt;gsay * &lt;red&gt;............... Heal F-Heal G-Heal Aura Vit")
	end

	if gheals ~= {} then
		for k,v in spairs(gheals, function(t, a, b) return (t[a][1]&gt;t[b][1]) end) do
			cecho ( string.format(prefix .. "* &lt;green&gt;%-15s              %3d        %2d\n", k, v[1], v[2]) )

			if xmode == "3" then
				cecho( string.format(prefix .. "* &lt;green&gt;%-15s  %3d        %3d\n", k, v[1], v[2]) )
			end	
		end
	end

	for k,v in pairs(NyyLIB.stats) do
		if whoclass(k) == "Cle" then
			cecho( string.format(prefix .. "* &lt;green&gt;%-15s        %2d           %2d  %2d\n", k, getStat(k, "castFullHeal"), getStat(k, "castHealingAura"), getStat(k, "Vitality") ) )
		end
	end

	cecho(prefix .. "* &lt;red&gt;...............\n")

	if xmode == "3" then
		cecho( prefix .. "* &lt;red&gt;...............")
	end

	for k,v in spairs(gotfullheal, function(t, a, b) return (t[a]&gt;t[b]) end) do
		if checkMask("warrior", k) then
			cecho( string.format(prefix .. "* &lt;green&gt;%-15s        %2d           %2d \n", k, v, getStat(k, "gotHealingAura") ) )
		end
	end

	echo("\n")

end

function printStats(xmode)
	local hitters=false

	local c_attackmiss=getStat(whoami(), "offMiss")
	local c_attackhit=getStat(whoami(), "offHit")

	local c_block=getStat(whoami(), "defShieldBlock")
	local c_dodge=getStat(whoami(), "defDodge")
	local c_graze=getStat(whoami(), "defGraze")
	local c_deflect=getStat(whoami(), "defWeaponDeflect")
	local c_glances=getStat(whoami(), "defShieldGlance")
	local c_svamp=getStat(whoami(), "shieldvamp")
	local c_parry=getStat(whoami(), "defParry")
	local c_pdeflect=getStat(whoami(), "defParryPartial")
	local c_crit=getStat(whoami(), "crithit")

	local c_hit=getStat(whoami(), "defHit")
	local c_miss=getStat(whoami(), "defMiss")

	local c_offdodge=getStat(whoami(), "offDodge") -- attacked mob, but dodged - count as hit

	local c_all=c_hit+ c_miss + c_parry + c_deflect + c_dodge + c_block
	local skillblocked = c_block + c_parry + c_deflect + c_dodge
	local partialblock=  c_pdeflect + c_graze + c_glances
	local v2allhit = c_hit + skillblocked
	local v2weapon = c_parry + c_deflect + c_pdeflect

	local c_adjhit=c_all-c_miss

	local ptar = getStat(whoami(), "planetar")

	local defstring = string.format("[Defense: Hit %2.1f%% (%d/%d), %2.1f%% (%d) direct, %2.1f%% (%d) dodge, %2.1f%% (%d) shield, %2.1f%% (%d) weapon]\n",
												c_hit*100/c_all, c_hit, c_all,
												(v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances),
												c_graze*100/c_hit, c_graze,
												c_glances*100/c_hit, c_glances,
												c_pdeflect*100/c_hit, c_pdeflect   ) 

	local prefix = "&lt;blue&gt;gcc &lt;green&gt;"
	
	
	for k,v in pairs(NyyLIB.stats) do
		if k ~= whoami() then
			if checkMask("statHitter", k) then
				hitters=true
			end
		else
			if xmode == nil or xmode == 2 then
				hitters=true
			end
		end
	end 

	--echo("\npeople groupList:ingroup only - () echo (1) gsay hitters (2) gsay hitters+me (3) gsay all\n")


	if hitters then
		if xmode == nil then
			cecho(prefix .. "* &lt;red&gt;................... Hit (Total)   Rescues\n")
		else
			if xmode == 3 then
				mud:send("gcmd * [gsay stats reset] [gsay stats display]")
			end
			--send("gsay * ......................   Hit (Total) Spells")
			mud:send("gcmd * ......................   Hit (Total)")
		end
	end

	--for k,v in pairs(NyyLIB.stats) do
	--	if getStat(k, "offHit") == 0 then
	--		addStat(k, "offHit")
	--	end

	--	if getStat(k, "offMiss") == 0 then
	--		addStat(k, "offMiss")
	--	end
	--end
	
	for k,v in spairs(NyyLIB.stats, function(t,a,b) return (getHits(b)*100/(getHits(b)+t[b]["offMiss"])) &lt;
																	  (getHits(a)*100/(getHits(a)+t[a]["offMiss"])) end) do


		local varstring

		if whoclass(k) ~= nil then 

			varstring =  string.format("[%3s] %-16s:%5.1f%% (%4d)",
							whoclass(k), k, 
							getHits(k)*100/(getHits(k)+getStat(k, "offMiss")), 
							getHits(k) + getStat(k, "offMiss") )


			--local cntSpellCast = getStat(k, "spellCast")

			--if cntSpellCast ~= 0 then
			--	varstring = varstring .. string.format(" %4d", cntSpellCast)
			--end

			local cntRescueFail=getStat(k, "failedrescue")
			local cntRescueSuccess=getStat(k, "successrescue")


			if xmode ~= 3 then
				if cntRescueFail + cntRescueSuccess ~= 0 then
					varstring = varstring ..	string.format(" %5.1f%% (%4d)", 
									cntRescueSuccess*100/(cntRescueFail+cntRescueSuccess),	cntRescueFail+cntRescueSuccess)
				end
			end

			varstring = "* " .. varstring .. "\n"

			if checkMask("statHitter", k) then
				if k ~= whoami() then
					if xmode == 1 or xmode == 2 or xmode == 3 then
						if groupList:ingroup(k) then
							mud:send("gcmd ".. varstring)
						end
					end
				else
					if xmode == 2 or xmode == 3 then
						if groupList:ingroup(k) then
							mud:send("gcmd ".. varstring)
						end
					end
				end
			else
				if xmode == 3 then
					if groupList:ingroup(k) then
						mud:send("gcmd " .. varstring)
					end
				end
			end

			if xmode == nil then
				cecho(prefix .. varstring)
	--			send("acc " .. varstring)
			end
		end
	end

	-- print defense stats
	if xmode == nil then
		echo("\n")

		-- check is ac,spells-&gt;parry-&gt;block-&gt;dodge-&gt;partial parry-&gt;partial block-&gt;partial dodge

		cecho(string.format("%s* &lt;green&gt;Of %d attacks on %s, AC and spells caused %d (%4.1f%%) to miss completely. The remaining %d:\n", prefix, c_all, whoami(), c_miss, c_miss*100/c_all, c_adjhit ))
		
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were parried\n", prefix, c_parry, c_parry*100/c_adjhit ) )
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were deflected\n", prefix, c_deflect, c_deflect*100/c_adjhit ) )
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were shieldblocked\n", prefix, c_block, c_block*100/c_adjhit ) )
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were dodged\n", prefix, c_dodge, c_dodge*100/c_adjhit ) )
		
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were partially deflected\n", prefix, c_pdeflect, c_pdeflect*100/c_adjhit ) )
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were partially shieldblocked\n", prefix, c_glances, c_glances*100/c_adjhit ) )
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) were partially dodged\n", prefix, c_graze, c_graze*100/c_adjhit ) )

		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) struck directly\n", prefix, 
			c_adjhit-skillblocked-partialblock, (c_adjhit-skillblocked-partialblock)*100/c_adjhit ) )
	
		cecho(string.format("%s* &lt;green&gt;   %4d (%4.1f%%) of shieldblocks were vamped\n", prefix, c_svamp, c_svamp*100/(c_block+c_glances) ) )
	end

	--mud:send("gsay Planetar heal procs: " .. ptar)

	echo("\n")

	printHeals()

	printDeaths()
end

function spairs(t, order)
    -- collect the keys
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end

    -- if order function given, sort by it by passing the table and keys a, b,
    -- otherwise just sort the keys 
    if order then
        table.sort(keys, function(a,b) return order(t, a, b) end)
    else
        table.sort(keys)
    end

    -- return the iterator function
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end

function v2print(xname)

local cntRescueFail=getStat(xname, "failedrescue")
local cntRescueSuccess=getStat(xname, "successrescue")

local c_attackmiss=getStat(xname, "offMiss")
local c_attackhit=getStat(xname, "offHit")

local c_block=getStat(xname, "defShieldBlock")
local c_dodge=getStat(xname, "defDodge")
local c_graze=getStat(xname, "defGraze")
local c_deflect=getStat(xname, "defWeaponDeflect")
local c_glances=getStat(xname, "defShieldGlance")
local c_svamp=getStat(xname, "shieldvamp")
local c_parry=getStat(xname, "defParry")
local c_pdeflect=getStat(xname, "defParryPartial")
local c_crit=getStat(xname, "crithit")

local c_hit=getStat(xname, "defHit")
local c_miss=getStat(xname, "defMiss")


local c_all=c_hit+c_miss + c_parry + c_deflect + c_dodge + c_block

local output = {}

local skillblocked = c_block + c_parry + c_deflect + c_dodge
local partialblock=  c_pdeflect + c_graze + c_glances


local v2allhit = c_hit + skillblocked
local v2weapon = c_parry + c_deflect + c_pdeflect

-- csv line

output[#output+1] = string.format("//%s,%s,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", 
											charData:get("statname"), whoami(), NyyLIB.str, NyyLIB.agibonus, NyyLIB.hitroll, NyyLIB.damroll,
												cntRescueFail, cntRescueSuccess, c_attackmiss, c_attackhit,
											c_block,c_dodge,c_graze,c_deflect,c_glances,c_svamp,c_parry,c_pdeflect, c_crit,c_hit,c_miss)

output[#output+1] = string.format("[Based on AC alone, %2.1f%% (%d) hit, %2.1f%% (%d) missed]\n",
							v2allhit*100/c_all, c_all,
							c_miss*100/c_all, c_miss)
							
output[#output+1] = string.format("[Of hits/potential hits (%d), %2.1f%% (%d) of them were dodged, %2.1f%% (%d) of them partially]\n",
								v2allhit,
								(c_dodge+c_graze)*100/v2allhit,
								 c_dodge+c_graze,
								c_graze*100/(c_dodge+c_graze),
								c_graze )

output[#output+1] = string.format("[Of available attacks (%d), %2.1f%% (%d) were shield blocked, %2.1f%% (%d) of them partially]\n",
							 	v2allhit-c_dodge-c_graze,
								(c_block+c_glances)*100/(v2allhit-c_dodge-c_graze), c_block+c_glances,
								c_glances*100/(c_block+c_glances), c_glances)

output[#output+1] = string.format("[Of the remaining %d attacks, %2.1f%% (%d) were riposted, %2.1f%% (%d) of them partially]\n",
							 	v2allhit-c_dodge-c_graze-c_block-c_glances,
								v2weapon*100/(v2allhit-c_dodge-c_graze-c_block-c_glances), v2weapon,
								c_pdeflect*100/(v2weapon), c_pdeflect   )

output[#output+1] = string.format("[%2.1f%% (%d) partially dodged, %2.1f%% (%d) glanced off shield, %2.1f%% (%d) partially deflected]\n",
											c_graze*100/c_hit, c_graze,
											c_glances*100/c_hit, c_glances,
											c_pdeflect*100/c_hit, c_pdeflect)

output[#output+1] = string.format("[%2.1f%% (%d) attacks went through all defenses]\n", 
							(v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances) )

output[#output+1] = string.format("[The final hit rate is %2.1f%% (%d)]\n",
											c_hit*100/c_all,	c_hit )

output[#output+1] = string.format("[Defense: Hit %2.1f%% (%d/%d) : %2.1f%% (%d) direct, %2.1f%% (%d) dodge, %2.1f%% (%d) shield, %2.1f%% (%d) weapon]\n",
												c_hit*100/c_all, c_hit, c_all,
												(v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances)*100/c_hit, (v2allhit-c_dodge-c_graze-v2weapon-c_block-c_glances),
												c_graze*100/c_hit, c_graze,
												c_glances*100/c_hit, c_glances,
												c_pdeflect*100/c_hit, c_pdeflect   )

output[#output+1] = string.format("[+HIT %d +DAM %d : Missed %2.1f%% (%d) Hit %2.1f%% (%d)]\n", 
								NyyLIB.hitroll, NyyLIB.damroll,
								c_attackmiss*100/(c_attackhit+c_attackmiss), c_attackmiss,
								c_attackhit*100/(c_attackhit+c_attackmiss), c_attackhit)


if cntRescueFail + cntRescueSuccess &gt; 0 then
	output[#output+1] = string.format("[%2.2f%% (%d) failed rescues, %2.2f%% (%d) success]\n", 
											cntRescueFail*100 / (cntRescueFail+cntRescueSuccess), cntRescueFail, 
											cntRescueSuccess*100 / (cntRescueFail+cntRescueSuccess), cntRescueSuccess)
end

local nx

echo("\n")

for nx=2, #output, 1 do
	echo(output[nx])
end

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>HelpScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function showHelp(xindex)
	local index, name
	local found=false
	
	for line in io.lines(mainpath("helpfile.dat")) do
		if string.find(line, ";;") ~= nil then
			if found == false then
				index,name = string.match(line, ";;([0-9]+),([a-zA-Z ]+)")
			else
				return
			end
		else
			if index == tostring(xindex) or name == xindex then
				found=true
				echo(line .. "\n")
			end
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>DisconnectEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function DisconnectEvent()
	cecho("&lt;red&gt;[DisconnectEvent was just called]\n")

	if charData:get("reconnect") ~= false and charData:get("reconnect") ~= nil then
		cecho("&lt;red&gt;[Sending reconnect in 30 seconds]")
		tempTimer(30, [[reconnect()]])
	end
end</script>
					<eventHandlerList>
						<string>sysDisconnectionEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MiscScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- anti timeout for autoroller

function autoroll(fname, xcommand)
	if xcommand == buttons.TIMEREXPIRE then
		mud:send("cha pow")
	end
end

-- anti timeout function

function timeout(fname, xcommand)
	--echo(xcommand .. " ")
	
	if xcommand == buttons.TIMEREXPIRE then
		mud:send("TIME")
	end
end

-- copy entire contents from src to dst

function copyBuffer(srcBuffer, dstBuffer)
	local srcBufferSize = getLastLineNumber(srcBuffer)
	local nx
	
	if srcBufferSize &gt; 100 then
		cecho("&lt;red&gt;[ copyBuffer: srcBuffer &gt; 100 lines ]\n")
		return
	end

	-- buffer is 0 based, final line is blank from the previous newline
	
	for nx=0, srcBufferSize-1, 1 do
		moveCursor(srcBuffer, 0, nx)
		selectCurrentLine(srcBuffer)
		copy(srcBuffer)
		appendBuffer(dstBuffer)
	end
end

-- return true if in combat - incomplete

function inCombat()
	if prompt:get("enemy") ~= "" or prompt:get("tank") ~= "" then
		return(true)
	end

	return(false)
end

-- return true if hidden

function getHide()
	hidden = hidden or false

	return(hidden)
end

function setHide(xval)
	hidden = xval
end

-- echo debug messages to screen

function echoDebug(xline)
	if charData:get("condensed", true)["debug"] then
		cecho(xline)
	end
end

-- basic button script: button (spell) name, chardata entry, command button recieved

function shiftButton(xfname, xchardata, xcommand)
	if xcommand == buttons.UPDATE then
		updateButton(xfname)
		return
	end

	if xcommand ~= buttons.INIT then
		shiftSetting(xfname, xchardata)
	end

	local current=charData:get(xchardata)

	if type(current) == "boolean" then
		if charData:get(xchardata) then
			setLabelImage(xfname, xfname .. "-on.png")
		else
			setLabelImage(xfname, xfname .. "-off.png")
		end
	else
		if current == nil then
			return
		end
		
		setLabelImage(xfname, xfname .. "-" .. current .. ".png")
	end

	-- only call if a spell
	updateSpellCount(xfname)

	--display("X")
	--mud:send("\n")
end

-- basic button script: button (spell) name, chardata entry, command button recieved
-- this button does not place spell counts on it

function shiftSkillButton(xfname, xchardata, xcommand)
	if xcommand == buttons.UPDATE then
		return
	end

	if xchardata == nil then
		cecho("&lt;red&gt;[shiftSkillButton Error: " .. tostring(xfname) .. " xchardata is nil]\n")
		return
	end

	-- display( charData:get(xchardata) )

	if xcommand ~= buttons.INIT then
		shiftSetting(xfname, xchardata)
	end

	--display( charData:get(xchardata) )

	local current=charData:get(xchardata)

	if current == nil then
		cecho("&lt;red&gt;[Error: " .. tostring(xchardata) .. " is nil in table]\n")
		return
	end

	if type(current) == "boolean" then
		if charData:get(xchardata) then
			setLabelImage(xfname, xfname .. "-on.png")
		else
			setLabelImage(xfname, xfname .. "-off.png")
		end
	else
		setLabelImage(xfname, xfname .. "-" .. current .. ".png")
	end

	--updateSpellCount(xname)

	--mud:send("\n")
end

-- shiftSetting moves a setting to the right, and echoes any attached information

function shiftSetting(xname, xsetting)
	local setting = charData:get(xsetting)

	-- convert boolean to "true"/ "false"
	if setting == false then
		setting = "false"
	elseif setting == true then
		setting = "true"
	end

	for k,v in pairs(setvar) do
		if v[1] == xsetting then
			local element=table.index_of(v[3], setting) or 0

			element=element+1

			if element &gt; table.size(v[3]) then
				element=1
			end

			local tosetvalue= v[3][element]

			-- convert "true"/ "false" to boolean
			if tosetvalue == "true" then
				tosetvalue=true
			elseif tosetvalue == "false" then
				tosetvalue=false
			end

			charData:set(xsetting, tosetvalue )

			-- display message on screen
			local screenecho= v[6+element-1]

			if screenecho ~= nil then
				-- substitute xname in string for @ if value was passed 
				if xname ~= nil then
					screenecho = string.gsub(screenecho, "@", to_english(xname) )
				end

				cecho( screenecho )
			end
		end
	end
end

-- rtrim(xstring) - trim trailing spaces

function rtrim(xstring)
  local n = #xstring
  while n &gt; 0 and xstring:find("^%s", n) do n = n - 1 end
  return xstring:sub(1, n)
end

-- condenseLine(newline) - delete line if identical to previous and suffix with x#


function previousLine()
	local previousline = getLines(getLineNumber()-1, getLineNumber())[1]

	return(previousline)
end

function condenseLine(newline)
	local previousline = getLines(getLineNumber()-1, getLineNumber())[1]

	if newline == "" and previousline == "" then
		eraseLine()
	end

	if newline == "" then
		return
	end

	-- new line is prompt, previous line blank, and line prior is prompt
	if previousline == "" then
		if string.find(newline, "^&lt; .* &gt; ") then
			if string.find(getLines(getLineNumber()-2, getLineNumber())[1], "&lt;") then
				-- delete empty line prior to current line   TODO - change to copy current line to previous + blank it
				moveCursor(0, getLineCount()-1)	
				eraseLine()

				condenseLine(rtrim(newline))
				return
			end
		end
	end

	if string.len(previousline) &gt; 10 and string.len(newline) &gt; 10 then
		if string.find(previousline, newline, 1, true) ~= nil then
			-- delete previous line
			moveCursor(0, getLineCount()-1)
			eraseLine()

			-- don't suffix counter on prompt lines
			if not string.find(previousline, "^&lt; .* &gt;") then
				-- if previous line had (x#) at the end, echo (x#+1)
				if string.findPattern(previousline, "(x[0-9]+)" ) ~= nil then
					cecho(" &lt;red&gt;(x" .. (tonumber(string.findPattern(string.findPattern(previousline, "%(x([0-9]+)%)" ), "[0-9]+" ))+1) .. ")")
				else
					cecho(" &lt;red&gt;(x2)")
				end
			end
		end
	end
end

function printSorted(xlist)
	local sortedlist=xlist

	table.sort(sortedlist)

	for nx=1, #sortedlist, 1 do
		cecho("&lt;green&gt;" .. sortedlist[nx])
	end
end

function homepath(xname)
	if xname == nil then
		cecho("\n&lt;red&gt;[Homepath Error: xname is nil]\n")
		return
	end

	local path = getMudletHomeDir() .. "\\" .. xname

	path=string.gsub(path, "\\", "/")	

	return(path)
end


function mainpath(xname)
	local pathname= string.gsub(NyyLIB.homedir .. xname, "\\", "/")

	local is_file = io.open(pathname)

	if is_file == nil then
		cecho("&lt;red&gt;[Error: file " .. pathname .. " not found]\n")
	else
		io.close(is_file)
	end

	return(pathname)
end

function soundpath(xname)
	local pathname= string.gsub(NyyLIB.homedir .. "sounds\\" .. xname, "\\", "/")

	local is_file = io.open(pathname)

	if is_file == nil then
		cecho("&lt;red&gt;[Error: file " .. pathname .. " not found]\n")
	else
		io.close(is_file)
	end

	return(pathname)
end


function iconpath(xname)
	local pathname= string.gsub(NyyLIB.homedir .. "buttons\\" .. xname, "\\", "/")

	local is_file = io.open(pathname)

	if is_file == nil then
		cecho("&lt;red&gt;[Error: file " .. pathname .. " not found]\n")
	else
		io.close(is_file)
	end

	return(pathname)
end

-- togBoolean will return the true/false reverse of the boolean provided

function togBoolean(xvar)
	if xvar then
		xvar=false
	else
		xvar=true
	end

	return(xvar)
end

function g(xitem)
	local container= charData:get("container")

	if container == "" then
		cecho("&lt;red&gt;[Container not set: @set container containername]\n")
	end

	return ( "get " .. xitem .. " " .. container )
end

function p(xitem)
	local container= charData:get("container")

	if container == "" then
		cecho("&lt;red&gt;[Container not set: @set container containername]\n")
	end

	return ( "put " .. xitem .. " " .. container )
end

function eraseLine()
	if not charData:get("condensed", true)["debug"] and not charData:get("condensed", true)["debug2"] then
		deleteLine()
	end
	
	if charData:get("condensed", true)["debug"] then
		cinsertText("&lt;red&gt;-")
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GroupClassScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

groupList = groupList or {}

previous = previous or {}

tankingList = tankingList or {}

-- return grouplist in a table

function groupList:get()
	return (self)
end

-- number of members in current grouplist

function groupList:size()
	return (#groupList)
end

-- delete all members in current grouplist

function groupList:reset()
	-- copy table before erasing
	previous=table.deepcopy(groupList)

	local nx

	for nx=1, groupList:size(), 1 do
		groupList[nx]=nil
	end
end

-- identify if anyone has been vitalized

function groupList:checkMaxHP()
	local nx

	--display(previous)

	for nx=1, #previous, 1 do
		local charname=previous[nx][1]
		local maxhp= tonumber(previous[nx][4])

		local newmaxhp= groupList:getMaxHP(charname)

		if newmaxhp ~= nil then
			if maxhp ~= 0 then
				if tonumber(newmaxhp) &gt; (maxhp+50) then
					if not buff:get("vitality", charname) then
						sendStatus(charname)
					end
				end
			end
		end
	end
end

-- reset tanking to 0

function groupList:resetTanking()
	tankingList = {}
end

-- add 1 to tank

function groupList:incTanking(xchar)
	tankingList[xchar] = tankingList[xchar] or 0
	tankingList[xchar] = tankingList[xchar] + 1
end

-- who is tanking? is so, return who, how many

function groupList:whoTanking()
	if next(tankingList) == nil then
		return(false)
	end

	return(tankingList)
end

-- return how many mobs xchar is known to be tanking

function groupList:getTanking(xchar)
	tankingList[xchar] = tankingList[xchar] or 0

	return(tankingList[xchar])
end


-- check if xchar exists in current grouplist

function groupList:ingroup(xchar)
	local nx

	if xchar == "" then
		return(false)
	end

	if xchar ~= nil then
		xchar = string.title(xchar)
	end

	for nx=1, groupList:size(), 1 do
		if groupList[nx][1] == xchar then
			return(true)
		end
	end
	
	return(false)
end

-- set hp, maxhp for xchar in grouplist

function groupList:setHP(xchar, xhp, xmaxhp)
	local nx

	for nx=1, groupList:size(), 1 do
		if groupList[nx][1] == xchar then
			groupList[nx][3] = xhp
			groupList[nx][4] = xmaxhp
			return
		end
	end
end

-- return hp, maxhp for xchar in grouplist

function groupList:getHP(xchar)
	local nx

	for nx=1, groupList:size(), 1 do
		if groupList[nx][1] == xchar then
			return(groupList[nx][3])
		end
	end

	if xchar ~= "gray" and xchar ~= "spirit" then
		--cecho("\n&lt;red&gt;[Error: " .. xchar .. " does not exist in groupList]\n")
	end
end

function groupList:getMaxHP(xchar)
	local nx

	for nx=1, groupList:size(), 1 do
		if groupList[nx][1] == xchar then
			return(groupList[nx][4])
		end
	end

	if xchar ~= "gray" and xchar ~= "spirit" then
		--cecho("\n&lt;red&gt;[Error: " .. xchar .. " does not exist in groupList]\n")
	end
end


-- return list of all pc chars in grouplist, or matching mask

function groupList:pc(xmask)
	local temp={}, nx

	if xmask == nil then
		xmask="classes"
	end

	for nx=1, groupList:size(), 1 do
		local charname=groupList[nx][1]

		-- Don't add if Someone, 2.Someone, etc
		if not string.find( charname, "Someone") then
			if checkMask(xmask, charname) then
				table.insert(temp, charname)
			end
		end
	end

	return(temp)
end

-- add xchar to grouplist

function groupList:add(xchar, xcls, xhp, xmaxhp)
	--if xchar == "a gray slaad" then
	--	table.insert(self, 1, {xchar, xcls, xhp, xmaxhp})
	--	return;
	--end

	if xchar == "doppelganger" then
		return
	end

	-- change hell hound to wolf

	if xchar == "hound" then
		xchar= "wolf"
	end

	-- If name already exists in table, rename to 2. 3. etc

	for nx=1, #groupList, 1 do
		if groupList[nx][1] == xchar then
			local test=string.findPattern(xchar, "([0-9]+)[.]" )

			if test==nil then
				xchar = "2." .. xchar
			else
				xchar = tonumber(string.findPattern( string.findPattern(xchar, "([0-9]+)[.]" ), "[0-9]+" ) )+1 .. "." .. string.sub(xchar, 3)
			end
		end
	end

	
	if xcls == "A-P" then
		xcls="Blk"
	end
	
	local newc = table.index_of(NyyLIB.classes, xcls)
	
	if newc == nil then
		display(xcls)
	end
	
	-- TODO: reorder insert to x, 2., 3.

	for nx=1, #groupList, 1 do
		--display(table.index_of(NyyLIB.classes, groupList[nx][2]))
		if newc == nil then
			--display("XXX")
		end
		if table.index_of(NyyLIB.classes, groupList[nx][2] ) &gt; newc then
			table.insert(groupList, nx, {xchar, xcls, xhp, xmaxhp})
			return(nil)
		end
	end

	table.insert(groupList, #groupList+1, {xchar, xcls, xhp, xmaxhp})

	--for nx=#groupList, 1, -1 do
	--	if table.index_of(NyyLIB.classes, groupList[nx][2] ) &lt; newc then
	--		table.insert(groupList, nx+1, {xchar, xcls, xhp, xmaxhp})
	--		return(nil)
	--	end
	--end

	--table.insert(groupList, 1, {xchar, xcls, xhp, xmaxhp})
end

-- modifed group display 

function groupList:display(xname, xhp, xmaxhp, xmv, xmaxmv, xpsp, xmaxpsp )
	local profilename=inwho(xname)

	local charClass = whoclass(xname)

	local color="&lt;green&gt;"

	if xhp ~= nil then
		color=colorNumber(xhp, xmaxhp)
	end

	if charClass ~= nil then
		if charData:get("group", true) then
			eraseLine()

			if xhp ~= nil then
				cecho ( string.format("\n%s%4d/%-4d", color, xhp, xmaxhp ) ) --hp
			else
				cecho ( "\n    /    " )
			end

			if profilename then
				cecho ( string.format("[%s] %s%-16s @%-15s", charClass, color, xname, profilename)) -- class, name, profilename
			else
				cecho ( string.format("[UNK] %s%-16s @%-15s", color, xname, "unknown")) -- name, profilename
			end

			if xmv ~= nil then
				cecho ( string.format("&lt;green&gt;%3d/%-3d ", xmv, xmaxmv) )
			else
				cecho ( color .. "   /    " )
			end

			if xpsp ~= nil then
				cecho ( string.format("&lt;green&gt;%4d/%-4d ", xpsp, xmaxpsp) )
			else
				cecho ( color .. "    /     " )
			end

		end

		if charClass ~= "UNK" then
			groupStatsDisplay(xname)
		end
	else
	-- pet
		if charData:get("group", true) then
			local linecheck = string.find(matches[1], xname)

			selectSection(linecheck-1, string.len(matches[1])-linecheck+1)
			copy()

			selectCurrentLine()
			replace("")

			if xhp ~= nil then
				cecho ( string.format("%s%4d/%-4d", color, xhp, xmaxhp ) ) --hp
			else
				cecho ( "    /    " )
			end

			echo ( "[UNK] " )

			paste()

			moveCursor(0, getLineCount())
			eraseLine()
		end
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>BuffScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

buff = buff or {}

power = {
 armor=1200, 
 haste=324, 
 dragonscales=360,
 blur=202,	
 globe_of_invulnerability=324,
 displace=1200,
 time_stop=175,
 stoneskin=240,
 elemental_ward=180,
 vitality=480
}

function power:get(powername)
	return( power[powername] )
end

function power:set(xname, xdur)
	power[xname] = xdur
end

function buff:set(xname, xbuff, xdur)
	-- name is set to a titled string
	xname=string.title(xname)
	
	self[xname] = self[xname] or {}

	if xdur == -1 then
		self[xname][xbuff] = nil
	elseif xdur == nil then
		-- get from db based on xbuff
		self[xname][xbuff] = power:get(xbuff)
	else
		self[xname][xbuff] = xdur
	end
end


-- function buff:set(xname, xbuff, xdur)	: Add buff to character
-- function buff:get(xbuff, xname) 		: Return time left on buff. whoami() substituted for xname if nil
-- function buff:del(xname, xbuff, xsuppress) : Remove an individual or all buffs from xchar
-- function decreasebuffs() 				   	: internal - decrement all buffs by 1 second

function buff:get(xbuff, xname)
	
	
	if xname == nil then
		xname=whoami()
	end

	-- on login, whoami isn't yet known

	if xname == nil then
		return nil
	end

	-- change string to title
	xname = string.title(xname)

	if self[xname] ~= nil then
		if self[xname][xbuff] ~= nil then
			return(self[xname][xbuff])
		end
	end

	return nil
end

function buff:del(xname, xbuff, xsuppress)
	if xbuff == nil then
		self[xname]={}
		return
	end

	buff:set(xname, xbuff, -1)

	if xsuppress ~= nil then
		buffexpired(xname, xbuff)
	end
end

-- substitute underscore for spaces, make all lower case
function to_snake(xname)
	local newname

	newname=string.trim(xname)

	newname=string.lower(newname)

	newname=string.gsub(newname, " ", "_") -- replace space with underscore

	return(newname)
end

function to_english(xname)
	local newname

	if xname == nil or xname == "" then
		return("")
	end

	newname=string.title(xname)

	newname=string.gsub(newname, "_", " ")


	local cappedname=""

	-- change capitalization

	for k,v in pairs( string.split(newname, " ") ) do
		if #v &gt; 3 then
			cappedname = cappedname .. string.title(v) .. " "
		else
			cappedname = cappedname .. v .. " "
		end
	end

	return( string.trim(cappedname) )
end

function decreasebuffs()
	for key, value in pairs(buff) do 
		if type(value) == "table" then
			for k, v in pairs(value) do 
				buff[key][k] = v-1

				if (v-1) == 0 or v &lt; -10 then
					buffexpired(key, k)

					buff:del(key, k)
				end
			end
		end
	end
end

function buffexpired(xname, xbuff)
	if groupList:ingroup(xname) then
		if not charData:get("condensed", true)["spellout"] then
			cecho("\n&lt;red&gt;[" .. to_english(xbuff) .. " has expired on &lt;green&gt;" .. xname .. "&lt;red&gt;.]\n")
		end
	end

	if xbuff == "combatmind" and checkMask("psi") then
		dropcombatmind()
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIGroup</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function colorNumber(xhp, xmaxhp)
	local pct = 1
	local col="&lt;green&gt;"

	if xhp == nil then
		pct=100
	else
		if tonumber(xhp) then
			pct=(xhp*100)/xmaxhp
		end
	end

	if not tonumber(xmaxhp) then
		cecho("&lt;red&gt;[Prompt appears incorrect: Rent/Re-enter Toril]\n")
		display(xmaxhp)
	end

	pct=(xhp*100)/xmaxhp

	if pct &gt;= 100 then
		col = "&lt;green&gt;"
	elseif pct &lt; 100 and pct &gt; 91 then
		col = "&lt;DarkGoldenrod&gt;"
	elseif pct &lt;= 91 and pct &gt; 75 then
 		col = "&lt;yellow&gt;"
	elseif pct &lt;= 75 and pct &gt; 50 then
 		col = "&lt;magenta&gt;"
	elseif pct &lt;= 50 and pct &gt; 33 then
		col = "&lt;magenta&gt;"
	elseif pct &lt;= 33 and pct &gt; 15 then
 		col = "&lt;OrangeRed&gt;"
	elseif pct &lt;= 15 and pct &gt; -500 then
		col = "&lt;red&gt;"
	end

	if xhp == "" then
  		col = "&lt;green&gt;"
	end

	return(col)
end

function countlines(xstr)
	local n=0
	local len=string.len(xstr)

	for i in xstr:gmatch("\n") do n=n+1 end

	if xstr:sub(len,len) ~= "\n" then
		n=n+1 -- last char is not newline
	end

	if xstr == "" then
		n=0
	end

	return(n)
end


function genline(xchar, xcls, xhp, xmaxhp)
	
	local pct = 1
	local col=colorNumber(xhp, xmaxhp)
	local cls = ""	

	local buffdisplay = ""
	local var

	if xcls == "UNK" then
		cls = "&lt;red&gt;" .. xcls .. "&lt;green&gt;"
	else
  		cls = xcls
	end

	-- scale/stone

	if buff:get("dragonscales", xchar) then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "dragonscales", "scl")
	else
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "stoneskin", "stn")
	end	

	-- blur

	buffdisplay = buffdisplay .. createBuffDisplay(xchar, "blur", "blr")

	-- globe/ward

	if buff:get("elemental_ward", xchar) then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "elemental_ward", "wrd")
	else
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "globe_of_invulnerability", "glb")
	end

	-- display final item on each group display line

	local endspell=charData:get("endspell")

	if endspell == "vit" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "vitality", "vit")
	elseif endspell == "cbm" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "combatmind", "cbm")
	elseif endspell == "dsp" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "displacement", "dsp")
	elseif endspell == "pwt" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "pass_without_trace", "pwt")
	elseif endspell == "fly" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "fly", "fly")
	elseif endspell == "grp" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "greater_realm_of_protecti", "grp")
	elseif endspell == "pfu" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "protection_from_undead", "pfu")
	elseif endspell == "hst" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "haste", "hst")
	elseif endspell == "dop" then
		buffdisplay = buffdisplay .. createBuffDisplay(xchar, "doppleganger", "dop")
	end

	-- various display formats

	local displayname= xchar
	local displaynamecol=col

	local petname=pet:getShortName(xchar)

	if petname then
		displayname=petname

		if pet:getInRoom(xchar) then
			displaynamecol="&lt;cyan&gt;"
		else
			displaynamecol="&lt;grey&gt;"
		end
	end

	if table.contains(NyyLIB.deadpeople, xchar) then
		-- This group member is dead 
		-- pets should never show here

		return ("&lt;navy&gt;" .. string.format("[%s]            %-16s                             ", xcls, displayname))
	else
		-- blind, paralyzed, or silenced

		if buff:get("blindness", xchar) or buff:get("blind", xchar) then
			return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "          [[ BLIND ]]       "))
		end

		if buff:get("major_paralysis", xchar) then
			return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "           [[ PARA ]]              "))
		end

		if buff:get("silence_person", xchar) then
			return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "          [[ SILENT ]]      "))
		end

		if buff:get("venom", xchar) then
			return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, "           [[ VENOM ]]             "))
		end

		-- No major penalties on char

		if xhp == 0 then
			-- character is not in room

			return (col .. string.format("[%s] %4s/%4s  %s%-16s&lt;green&gt; %s", xcls, "----", "----", displaynamecol, displayname, buffdisplay))
		else
			-- default group line

			if xchar == whoami() and (groupList:size() ~= 1 or pet:size() &gt; 0 ) then
				return (col .. string.format("[%s] %4d/%-4d  &lt;cyan&gt;%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displayname, buffdisplay))
			else
				return (col .. string.format("[%s] %4d/%-4d  %s%-16s&lt;green&gt; %s", xcls, xhp, xmaxhp, displaynamecol, displayname, buffdisplay))
			end
		end
	end
end

function createBuffDisplay(xchar, xbuff, xdsp)
	local var = buff:get(xbuff, xchar)
	local time = bufftimedisplay(var)

	if var then	
		if string.starts(time, "0") then
			return ( "&lt;red&gt;" .. xdsp:upper() .. ":" .. time .. " ")
		else
			return ( "&lt;green&gt;" .. xdsp:upper() .. ":" .. time .. " ")
		end
	else
		return ( "&lt;grey&gt;" .. xdsp .. "    ")
	end
end

function RedrawGroupStatus()
	local bottomwin = ""
	local rightwin = ""
	local count=0
	local i=0

	local numchars = groupList:size() + pet:size()

	if groupRedraw ~= nil then
		return
	end

	if charData:get("groupwindow") == "bottom"	and numchars &gt; 4 then
		charData:set("groupwindow", "split")
		selectGroupWindows()
	end

	if charData:get("groupwindow") == "split"	and numchars &lt; 5 then
		charData:set("groupwindow", "bottom")
		rightGroupWindowLines=0
		selectGroupWindows()
	end

	-- loop through group list

	for k,char in pairs(groupList:pc()) do
		local cls=whoclass(char) or "UNK"

		local charline = genline( char, cls, groupList:getHP(char), groupList:getMaxHP(char) )

		if not ( cls == "UNK" and pet:status(char) ) then
			i=i+1
			if charData:get("groupwindow") == "split" then
				if checkMask("rightWindow", char) then
					rightwin = rightwin .. charline .. "\n"
				else
					count=count+1	
							
					if charData:get("iconbar") == "left" then
						if count % 2 ~= 0 then	-- indent window for left iconbar
							bottomwin = bottomwin .. "          "
						end
					end

					bottomwin = bottomwin .. charline
						
					if count % 2 == 0 then
						bottomwin = bottomwin .. "\n"
					end
				end			
			else
				if i &gt; 1 and (i % 2) == 0 then		
					bottomwin = bottomwin .. "                  "
				end

				bottomwin = bottomwin .. charline
				rightwin = rightwin .. charline .. "\n"

				if i ~= numchars and (i % 2) == 0 then
					bottomwin = bottomwin .. "\n"
				end
			end
		end
	end

	-- loop through followers (pets) - should cyan highlight, title

	-- pet:getShortName(xname)


	for k,char in pairs( pet:getTable() ) do
		i=i+1

		local cls="UNK"

		local charline = genline( char, "UNK", pet:getHP(char) or 0, pet:getMaxHP(char) or 0 )

		if charData:get("groupwindow") == "split" then
			if checkMask("rightWindow", char) then
				rightwin = rightwin .. charline .. "\n"
			else
				count=count+1	
							
				if charData:get("iconbar") == "left" then
					if count % 2 ~= 0 then	-- indent window for left iconbar
						bottomwin = bottomwin .. "          "
					end
				end

				bottomwin = bottomwin .. charline
						
				if count % 2 == 0 then
					bottomwin = bottomwin .. "\n"
				end
			end			
		else
			if i &gt; 1 and (i % 2) == 0 then		
				bottomwin = bottomwin .. "                  "
			end

			bottomwin = bottomwin .. charline
			rightwin = rightwin .. charline .. "\n"

			if i ~= numchars and (i % 2) == 0 then
				bottomwin = bottomwin .. "\n"
			end
		end
	end

	bottomGroupWindowLines=countlines(bottomwin)

	if rightGroupWindowLines ~= countlines(rightwin) then
		force=true
	end

	rightGroupWindowLines=countlines(rightwin)

	if bottomGroupWindowLines == 1 then
		bottomGroupWindowLines=2
	end

	resizeGroupWindow(force)
	force=nil

	local grw=charData:get("groupwindow")

	if grw == "bottom" or grw == "all" or grw == "split" then
		local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")

		clearWindow("gGroupStatusWindow")
		bottomWindow:show()

		-- display( parseLine(bottomwin) )

		bottomWindow:echo( parseLine(bottomwin) )
	end

	if grw == "right" or grw == "all" or grw == "split" then
		clearWindow("gGroupStatusWindow2")
		showWindow("gGroupStatusWindow2")		

		gGroupStatusWindow2:cecho(rightwin)
	end
end

-- this function is always the bottom window
function parseLine(xline)
	local fontsize = charData:get("grpfontsize", true)
	local WindowWidth, WindowHeight = getMainWindowSize()
	local retval=""

	-- calculate/set font size of lower window
	if groupList:size() &lt; 3 and charData:get("grpfontsize", true) == "auto" then
		--fontsize= maxfont(55, WindowWidth)
		fontsize= maxfont(40, WindowWidth)	

		--display(fontsize)

		if fontsize &gt; 14 then
			fontsize = 14
		end
	end

	for k,v in pairs( string.split(xline, "&lt;") ) do
		if v ~= "" then
			local tmp = 	string.split(v, "&gt;")
		
			if tmp[2] ~= nil then
				retval = retval .. [[&lt;span style="color:]] .. tmp[1] .. [["&gt;]] .. 
					 string.gsub(tmp[2], " ", "&amp;nbsp;")
					 .. [[&lt;/span&gt;]]
			end
		end
	end


	retval = [[&lt;p style="font-size:]] .. fontsize .. [[px;font-style:normal;font-family: 'Bitstream Vera Sans Mono'"&gt;]] .. retval .. [[&lt;/font&gt;&lt;/p&gt;]]
	--retval = [[&lt;p style="font-size:]] .. fontsize .. [[px;font-style:normal;font-family: ']] .. charData:get("font", true) .. [['"&gt;]] .. retval .. [[&lt;/font&gt;&lt;/p&gt;]]
	retval = string.gsub(retval, "\n", "&lt;br&gt;")

	return(retval)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIButtons</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
buttons = buttons or {}

-- buttons.list = buttons.list or { [0]={}, [1]={} }

buttons.TIMEREXPIRE = 0

buttons.INIT = -1
buttons.CLICK = -2
buttons.UPDATE = -3
buttons.ENTER = -4
buttons.NESTCLICK = -5
buttons.HOVER = -6

function onEnter(xname,xid)
	currentIcon = {xname,xid}
end

function buttons:init()
	buttons.list = { [0]={}, [1]={} }
end

-- button name, position (1-20), minimum level to create, width (or nil), height (or nil)

-- Button will callback to self on click IF a function exists for it.
-- If no function exists, information is taken from the powerAliases[Classname] table
-- A spell button is populated with the highest known memorized spell matching the charData entry

-- xbar= itembar to use 0=bottom, 1=left side

function addbutton(xname, xbar, xid, xlevel, xwidth, xheight)
	local newbutton=nil

	local text1
	local text2
	local text3

	if xid == nil then
		cecho("\n&lt;red&gt;[Adding non-existant button: " .. xname .. "]\n")
		powerAliases:addButtons()
		return
	end

	local createname

	if xbar == 0 then
		createname = xbar .. "button" .. xid
		xwidth= xwidth or "4.8%"
		xheight = xheight or "2c"
	elseif xbar == 1 then
		createname= xbar .. "button" .. xid
		xwidth= xwidth or "95%"
		xheight = xheight or "8%"
	end

	if xid &gt; 20 then
		display(xname)
		display(xid)
	end

	assert( tonumber(xlevel), xlevel )

	if charData:get("level") &gt;= xlevel then
		local window
		
		if xbar == 0 then
			window=Geyser.Label:getWindow("gIconBarWindow")
		elseif xbar == 1 then
			window=Geyser.Label:getWindow("LeftPanel")
		end

		-- reuse button if previously created
		if buttons.list[xbar][xid] ~= nil then
			echoDebug("&lt;red&gt;Re-using button: " .. xname .. " " .. tostring(xbar) .. " " .. tostring(xid) .. "]\n")
			
			-- button overlay
			newbutton = buttons.list[xbar][xid][2]
		
			-- show base button
			buttons.list[xbar][xid][3]:show()
		else
			-- init button, it doesn't exist
			buttons.list[xbar][xid] = {}

			echoDebug("&lt;red&gt;Creating button: " .. xname .. " " .. tostring(xbar) .. " " .. tostring(xid) .. "]\n")

			local xp
			local yp
			local ys
			
			if xbar == 0 then
				xp=iconxp(xid)
				yp=0
				ys="100%"
			elseif xbar == 1 then
				xp=0
				yp=lefticonyp(xid)
				ys="8%"
			end
		
			if xid &gt; 15 then
				yp=8
				ys="2c"
			end
			
			
			local baseButton = Geyser.Label:new({name=createname .. "base", x=xp, y=yp, width=xwidth, height=ys}, window)
			
			
			buttons.list[xbar][xid][3] = baseButton
			
			buttons.list[xbar][xid][3]:setStyleSheet([[background-color : transparent]])
			
			buttons.list[xbar][xid][4] = Geyser.Label:new({name="textLabelButton" .. tostring(xbar) .. "." .. tostring(xid) .. "a", x=0, y=3, width="100%", height=20}, baseButton)
			buttons.list[xbar][xid][4]:setStyleSheet([[background-color : transparent]])

			buttons.list[xbar][xid][5] = Geyser.Label:new({name="textLabelButton" .. tostring(xbar) .. "." .. tostring(xid) .. "b", x=0, y=19, width="100%", height=20}, baseButton)
			buttons.list[xbar][xid][5]:setStyleSheet([[background-color : transparent]])

			buttons.list[xbar][xid][6] = Geyser.Label:new({name="textLabelButton" .. tostring(xbar) .. "." .. tostring(xid) .. "c", x=0, y=10, width="100%", height=20}, baseButton)
			buttons.list[xbar][xid][6]:setStyleSheet([[background-color : transparent]])
		
			newbutton = Geyser.Label:new({name=createname, x="1%", y="1%", width="98%", height="98%"}, baseButton)

			buttons.list[xbar][xid][2] = newbutton

			-- make label transparent
			newbutton:setStyleSheet([[background-color : transparent]])

			if xname == "dummy" then
				buttons.list[xbar][xid][1] = xname
				return
			end
		end

		newbutton:setFontSize(window.fontSize)
		newbutton:echo([[&lt;p style="font-size:12px"&gt;&lt;b&gt;&lt;center&gt;     &lt;br&gt;     &lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])

		-- chose the correct callback function

		local isMeleeButton = meleePowers:getCharData(xname)

		if isMeleeButton then
			newbutton:setClickCallback("meleePowersUpdate", xname, buttons.CLICK)
		elseif _G[xname] == nil then -- if no existing function use the generic spell button function
			newbutton:setClickCallback("updateSpellCount", xname, buttons.CLICK)
		else
			newbutton:setClickCallback(xname, xname, buttons.CLICK)
		end


		-- use tooltips only on bottom bar
		if xbar == 0 then
			newbutton:setOnEnter( "onEnter", xname, xid )
		end
		
		newbutton:setOnLeave( "buttonLeave" ) -- use this to clear tooltips

		newbutton:show()
		
		buttons.list[xbar][xid][1] = xname
		buttons.list[xbar][xid][2] = newbutton

		initButton(xname)
	end

	return(newbutton)
end

function updateButton(xname, nest)
	local label

	if nest == nil then
		label=findlabel(xname)		
	else
		label=findlabel(nest)
	end

	if label ~= nil then
		label:echo([[&lt;p style="font-size:24px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor") .. [["&gt;]] .. getSpellCount(xname) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
	end
end

function buttons:hide()
	local nx

	-- changed to hide base button, only hide to button 15
	for nx=1, 20, 1 do
		label=findlabel("0button" .. nx .. "base")

		if label ~= nil then
			label:hide()
		end
	end
end

function buttons:change(xchardata, xvalue, xbutton)
	cecho("&lt;red&gt;[Setting " .. xchardata .. " to " .. tostring(xvalue) .. "]\n")

	charData:set(xchardata, xvalue)

	buttons:sync()

	--if _G[xbutton] ~= nil then
	--	_G[xbutton](xbutton, buttons.INIT)
	--end
end

function buttons:sync()
	local bar
	
	-- highlight buttons re: new charData
	for bar=0, #buttons.list, 1 do
		if table.size(buttons.list[bar]) ~= 0 then
			for i,v in pairs(buttons.list[bar] ) do
				initButton( v[1])
			end
		end
	end
end

function buttons:id(xname)
	local bar
	
	for bar=0, #buttons.list, 1 do
		if table.size(buttons.list[bar]) ~= 0 then
			for i,v in pairs(buttons.list[bar]) do
				if v[1] == xname then
					return bar, i -- location, id
				end
			end
		end
	end

	return(nil)
end

function	showIconbar()
	local window=Geyser.Label:getWindow("gIconBarWindow")

	if charData:get("hideicons", true) then
		window:hide()
	else
		window:show()
	end
end

-- return true if label is not hidden

function isIconActive(xname)
	local label=findlabel(xname)

	if label == nil then
		return(false)
	end

	if label["hidden"] then
		return(false)
	else
		return(true)
	end
end

-- use correct label: either text, or .png

function setLabelImage(xname, ximage)
	local label=findlabel(xname)
	
	label:clear()

	-- format of returned label name should be # button #, (bar) (button number)
	
	local spellText= powerAliases:getLabelText(xname)

	echoDebug("&lt;red&gt;[setLabelImage: " .. xname .. " " .. ximage .. "]\n")

	-- is this in text array?
	
	if buttonText[xname] ~= nil or spellText ~= nil then
		local textArray
		
		if spellText ~= nil then
			textArray= string.split(spellText, "|")
		else
			textArray= string.split(buttonText[xname][1], "|")
		end
		
		local buttonBar, buttonNumber=buttons:id(xname)

		echoDebug("&lt;red&gt;[Bar: " .. tostring(buttonBar) .. " Number: " .. buttonNumber .. "]\n")

		local text1= buttons.list[buttonBar][buttonNumber][4]
		local text2= buttons.list[buttonBar][buttonNumber][5]
		local text3= buttons.list[buttonBar][buttonNumber][6]

		local fontColour=charData:get("colbuttonoff")
	
		-- located correct button text to use if multiple choices

		ximage = string.gsub(ximage, "^[A-Za-z_]+-", ""):lower()
		ximage = string.gsub(ximage, ".png", "")

		if spellText == nil then
			for k,v in pairs(buttonText[xname]) do
				if string.find(ximage, v:lower()) or string.find(v:lower(), ximage) then
					textArray= string.split(v, "|")
				end
			end
		end
		
		-- use button color 2 for specific buttons
		if table.contains( { "me", "on", "basic", "all", "large", "small", "hitters", "rogues", "tanks", "sizet", "sizes", "sizem", "sizel", "sizeh"}, ximage) then
			fontColour=charData:get("colbuttonon")
		end
		
		-- use grey for active
		
		if ximage == "active" then
			fontColour="grey"
		end
		
		label:setStyleSheet([[background-color : transparent]])
		
		if buttonNumber == nil or text1 == nil or text2 == nil then
			cecho(string.format("&lt;red&gt;[Error: setLabelImage xname %s ximage %s buttonNumber %s text1 %s text2 %s]\n", xname, ximage, tostring(buttonNumber),
															tostring(text1), tostring(text2) ) )
			return
		end

		-- determine max font size
		-- function maxfont(xchars, xpixelwidth)
		
		local WindowWidth, WindowHeight = getMainWindowSize()
		local labelWidth = WindowWidth * .048

		-- 1276 x 687

		-- width: 92 font: 18
		-- width: 72 font: 13
		-- width  51 font: 11

		local fontSize = "18"
		
		if labelWidth &lt; 72 then
			fontSize= "13"
		end

		if labelWidth &lt; 62 then
			fontSize= "11"
		end

		if #textArray == 2 then
			if fontColour == charData:get("colbuttonon") then
				-- add bold
				text1:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[1] .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
				text2:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[2] .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
			else
				text1:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[1] .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
				text2:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. textArray[2] .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
			end

			text3:echo("")
		else
			text1:echo("")
			text2:echo("")

			if fontColour == charData:get("colbuttonon") then
				-- add bold
				
				text3:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;b&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. 
									textArray[1] .. [[&lt;/b&gt;&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
			else
				text3:echo([[&lt;p style="font-size:]] .. fontSize .. [[px;font-family: ']] .. charData:get("font", true) .. [['"&gt;&lt;center&gt;&lt;font color="]] .. fontColour .. [["&gt;]] .. 
									textArray[1] .. [[&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;]])
			end
		end
		
		return
	end

	-- cecho("&lt;red&gt;[setLabelImage: " .. xname .. " " .. ximage .. "]\n")

	if label ~= nil then
		label:setStyleSheet([[border-image: url(]] .. iconpath(ximage) .. [[)]])
		return(label)
	else
		cecho("\n&lt;red&gt;[Error: unable to locate label: " .. xname .. "]")
		return(nil)
	end
end

function findlabel(xname)
	local othername=xname
	local window=Geyser.Label:getWindow("gIconBarWindow")
	local leftwindow=Geyser.Label:getWindow("LeftPanel")

	-- icon bar hasn't been created
	if window == nil then -- or 1 == 1
		return(nil)
	end

	-- search for target name in existing buttons

	local bar
	
	for bar=0, #buttons.list, 1 do
		if table.size(buttons.list[bar]) ~= 0 then
			for i,v in pairs(buttons.list[bar]) do
				if v[1] == xname then
					othername = bar .. "button" .. i			 
				end
			end
		end
	end

	-- Search top + 1 level of labels, lower icon bar

	for i,v in pairs(window.windowList) do
		if v.name == othername then
			return v
		end

		for key,val in pairs(v.windowList) do
			if val.name == othername then
				return val
			end
		end
	end

	-- search through left icon bar
	
	for i,v in pairs(leftwindow.windowList) do
		if v.name == othername .. "base" then
			return v
		end
	end

	if string.find(xname, "^[01]button([0-9])+$") == nil then
		 --echoDebug("&lt;red&gt;[label not found " .. xname .. "]")
	end

	return(nil)
end

function buttonLeave()
	currentIcon=nil
	hideToolTip()
end

function hideToolTip()
	if toolTip ~= nil then
		toolTip:hide()
	end

	toolTipActive = false
end

function showToolTip()
	if currentIcon == nil or currentIcon[2] == nil then
		--display("error: currentIcon is nil")
		return
	end

	local WindowWidth, WindowHeight = getMainWindowSize()
	local wwidth,wheight = calcFontSize(14)

	local xs = string.len(currentIcon[1]) * wwidth
		
	toolTip:resize( xs, nil)
		
	toolTip:echo( " " .. to_english(currentIcon[1]) )
		
	-- move icon to left or right of active icon
	if currentIcon[2] &lt; 16 then
		toolTip:move( iconxp(currentIcon[2]+1), 10)
	else
		toolTip:move( currentIcon[2]*WindowWidth/20-xs-10, 10)
	end

	toolTip:show()
	raiseWindow(toolTip.name)
	toolTipActive = true
end

function dummy()
	return
end

function createButtons()
	local nx=0
	
	for nx=1, 15, 1 do
		addbutton("dummy", 0, nx, 0)
	end
end


function findbutton(xid)
	local window=Geyser.Label:getWindow("gIconBarWindow")

	if xid == nil then
		cecho("\n&lt;red&gt;[findbutton: nil xid]\n")
	end

	-- search two levels
	
	for i,v in pairs(window.windowList) do
		if v.name == "0button" .. xid then
			return v
		end
	
		for key,val in pairs(v.windowList) do
			if val.name == "0button" .. xid then
				return val
			end
		end
	end

	return(nil)
end

function iconxp(xnum)
	if xnum &gt; 20 then
		xnum = 20
	end

	return( xnum/20*100 .. "%" )
end

function lefticonyp(xnum)
	if xnum &gt; 10 then
		xnum = 10
	end

	xnum=11-xnum

	return( xnum/10*100 .. "%" )
end

function iconyp(xnum)
	-- bottom row only
	return(8)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- RightLabel - Righthand side image label that runs top to bottom
-- RightPanel - Righthand side container that holds other windows, just inside RightLabel

-- demonnic.chat.container is created inside RightPanel
-- tab box is 25px, created inside demonnic.chat.container

-- iconbar height is always 40 pixels
-- currenty top left corner of icon bar
-- Geyser.Label:getWindow("gIconBarWindow").y  will return in the format -78px



function leftIcons()
	local WindowWidth, WindowHeight = getMainWindowSize()
	local lLabel=Geyser.Label:getWindow("LeftLabel")
	local exitLabel=Geyser.Label:getWindow("LeftExitLabel")

	if charData:get("hideequip", true) then
		setBorderLeft( 10 )

		exitLabel:show()

		lLabel:resize(5, nil)
	else
		setBorderLeft ( math.ceil(WindowWidth/20)+4 )

		exitLabel:hide()		

		lLabel:resize("5%", nil)
	end
end

function hideLeftIcons()

	local WindowWidth, WindowHeight = getMainWindowSize()

	if charData:get("hideequip", true) then
		local lLabel=Geyser.Label:getWindow("LeftLabel")
		local exitLabel=Geyser.Label:getWindow("LeftExitLabel")

		exitLabel:hide()

		lLabel:resize(5, nil)

		setBorderLeft( 10 )
	else
		setBorderLeft ( math.ceil(WindowWidth/20)+4 )
	end
end

function showLeftIcons()
	local lLabel=Geyser.Label:getWindow("LeftLabel")
	local exitLabel=Geyser.Label:getWindow("LeftExitLabel")
	local WindowWidth, WindowHeight = getMainWindowSize()

	if charData:get("hideequip", true) then
		exitLabel:show()
	else
		exitLabel:hide()
	end

	lLabel:resize("5%", nil)

	setBorderLeft ( math.ceil(WindowWidth/20)+4 )
end

function leftsideOnEnter()
	showLeftIcons()
end

function leftsideOnLeave()
	hideLeftIcons()
end

function createLeftsideContainers()
	local WindowWidth, WindowHeight = getMainWindowSize()

--	local label = Geyser.Label:new({name="LeftLabel", x="0%", y=0, width="5%", height=WindowHeight-200,})
--	Geyser.Container:new({name="LeftPanel", x="1%", y="2%", width="98%", height="90%",}, label)


-- if charData:get("level") == 50 then -- xp window = 32

--	local label = Geyser.Label:new({name="LeftLabel", x="0%", y=32, width="5%", height="100%",})
	local label = Geyser.Label:new({name="LeftLabel", x="0%", y=0, width="5%", height="100%",})
	Geyser.Container:new({name="LeftPanel", x="1%", y="2%", width="98%", height="75%",}, label)

	local exitlabel = Geyser.Label:new({name="LeftExitLabel", x="5%", y=0, width="10%", height="100%",})
	exitlabel:setStyleSheet([[background-color : transparent]]);

	label:setOnEnter( "leftsideOnEnter" )
	exitlabel:setOnEnter( "leftsideOnLeave" )

	leftsideOnLeave()
end

function createRightsideContainers()
	local label = Geyser.Label:new({name="RightLabel", x="66%", y="0%", width="34%", height="100%",})
	Geyser.Container:new({name="RightPanel", x="1%", y="2%", width="98%", height="90%",}, label)
end

function createToolTip()
	local iconBar=Geyser.Label:getWindow("gIconBarWindow")
	
	if toolTip == nil then
		toolTip = Geyser.Label:new({name="toolTip", x=80, y=80, width="30c", height=25,fgColor = "black",color = "white",}, iconBar)
		toolTip:setFontSize(14)
	
		toolTip:setOnEnter( "hideToolTip" )
	end
end

function setBorder()
	local window=Geyser.Label:getWindow("gIconBarWindow")
	local rLabel=Geyser.Label:getWindow("RightLabel")
	local lLabel=Geyser.Label:getWindow("LeftLabel")

	local border=charData:get("border", true)

	local is_file = io.open(border)

	if is_file ~= nil then
		io.close(is_file)
	end

	if border == "default" then

		if window ~= nil then
--			window:setStyleSheet([[border-image: url(]] .. mainpath("leftbar.png") .. [[)]])
			window:setStyleSheet([[border-image: url(]] .. mainpath("bottombar.png") .. [[)]])

			-- Geyser.Label:getWindow("gIconBarWindow"):setStyleSheet([[background-color: yellow]])
		end

		if rLabel ~= nil then
			rLabel:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])
		end

		if lLabel ~= nil then
--			lLabel:setStyleSheet([[border-image: url(]] .. iconpath("frame-1.png") .. [[)]])
			lLabel:setStyleSheet([[border-image: url(]] .. mainpath("leftbar.png") .. [[)]])
		end

		return
	end

	if border == "none" then
		if window ~= nil then
			window:setStyleSheet([[border-image: url("")]])
		end

		if rLabel ~= nil then
			rLabel:setStyleSheet([[border-image: url("")]])
		end

		if lLabel ~= nil then
			lLabel:setStyleSheet([[border-image: url("")]])
		end

		return
	end

	if is_file then
		if window ~= nil then
			window:setStyleSheet([[border-image: url(]] .. charData:get("border", true) .. [[)]])
		end

		if rLabel ~= nil then
			rLabel:setStyleSheet([[border-image: url(]] .. charData:get("border", true) .. [[)]])
		end

		if lLabel ~= nil then
			lLabel:setStyleSheet([[border-image: url(]] .. charData:get("border", true) .. [[)]])
		end
	
		return
	end

	-- it's a colour

	if window ~= nil then
		window:setStyleSheet([[background-color: ]] .. border )
	end

	if rLabel ~= nil then
		rLabel:setStyleSheet([[background-color: ]] .. border )
	end

	if lLabel ~= nil then
		lLabel:setStyleSheet([[background-color: ]] .. border )
	end
end

function GUIScripts( event, x, y )
	local rightGroupWindow=gGroupStatusWindow2

	-- called on sysWindowResizeEvent

	if NyyLIB == nil or NyyLIB == {} then
		return
	end

	if 	NyyLIB.initcompleted ~= true then
		return
	end

	if NyyLIB.homedir == nil then
		return
	end

	local WindowWidth, WindowHeight = getMainWindowSize()

	if (NyyLIB.windowx == nil or NyyLIB.windowy == nil) or (NyyLIB.windowx ~= x or NyyLIB.windowy ~= y) then 
		-- window size has changed

		miniMap:resizeFont()

		NyyLIB.windowx = x
		NyyLIB.windowy = y

		if rightGroupWindow ~= nil then
			rightGroupWindow:setFontSize(maxfont(40, x/3-15))
		end

		if demonnic ~= nil then
			if demonnic.chat ~= nil then
				if demonnic.chat.config.fontSize == nil then
					demonnic.chat.config.fontSize=12
				end

				demonnic.chat:redo()
			end
		end

		setBorderRight( math.ceil(WindowWidth/3)+15 )	

		resizeGroupWindow(true)
	
		-- redraw button text
		buttons:sync()
	end
end

-- return the maximum fontsize that can display xchars in space of xpixelwidth

function maxfont(xchars, xpixelwidth)
	local fontSize=5
	local fontWidth,fontHeight = calcFontSize(5)

	if xchars == 10 then
		--display(xpixelwidth)
	end

	while xpixelwidth/fontWidth &gt; xchars do
		
		if xchars == 10 then
			--display(fontSize)
			--display(fontWidth)
		end

		fontSize=fontSize+1
		fontWidth,fontHeight = calcFontSize(fontSize)

		if fontSize == 16 then break end
	end

	fontSize=fontSize-1

	return(fontSize)
end

function initgui()
	local WindowWidth, WindowHeight = getMainWindowSize()
	local wwidth,wheight = calcFontSize(11)
	local rPanel = Geyser.Label:getWindow("RightPanel")

	NyyLIB = NyyLIB or {}

	-- lower group status window

	if gGroupStatusWindow == nil then
		gGroupStatusWindow = Geyser.Label:new({name="gGroupStatusWindow", x="0%", y="-1c", width="100%", height="1c",})
	end

	setBackgroundColor("gGroupStatusWindow", 0,0,0,255)
	gGroupStatusWindow:setFontSize(11)

	-- right group status window
	
	if rPanel == nil then
		display("Error: Rightpanel is nil")
	end


	-- can't be looked up because miniconsole?
	if gGroupStatusWindow2 == nil then
		gGroupStatusWindow2 = Geyser.MiniConsole:new(
			{name="gGroupStatusWindow2", x=0, y="55%", width="100%", height="48%",}, Geyser.Label:getWindow("RightPanel") )
	end

	setBackgroundColor("gGroupStatusWindow2", 0,0,0,255)

	-- icon bar (bottom)
	local window=Geyser.Label:getWindow("gIconBarWindow")

	if window == nil then
		window = Geyser.Label:new({name="gIconBarWindow", x="0%", y=-51, width="100%", height="40",})
		setBorder()

		window:show()
		window:hide()
	
		-- create all possible buttons
		createButtons()
	
		-- createtooltip
		createToolTip()
	end

	window:setFontSize(8)

	buttons:hide()

	showIconbar()

	roomWindow:create()
	miniMap:create()
	
	-- non-specific buttons

	baseButtons()

	-- groupwindow

	initGroupWindow()

	timer:init()

	-- map window

	local currentmap =	charData:get("map")
	expandAlias("@map on", false)

	charData:set("map", currentmap)

	if charData:get("map") == "off" then
		expandAlias("@map off", false)
	end
end

function initGroupWindow()
	selectGroupWindows()

	local groupWindowsType=charData:get("groupwindow")

	if table.contains( { "right", "split", "all" }, groupWindowsType) then
		showWindow("gGroupStatusWindow2")
	end
		
	if table.contains( { "bottom", "split", "all" }, groupWindowsType) then
		showWindow("gGroupStatusWindow")
	end

	if groupWindowsType == "right" then
		window=Geyser.Label:getWindow("gIconBarWindow")

		window:move(nil,-40)
		NyyLIB.IconBarLabel:move(nil,-40)
	end

	bottomGroupWindowLines=0
	rightGroupWindowLines=0
end

-- This function displays the correct windows

function	selectGroupWindows()
	local rPanel=Geyser.Label:getWindow("RightLabel") 

	-- rPanel is container with demonnic.chat.container inside it - The Label however is the container that's moved

	hideWindow("gGroupStatusWindow")
	hideWindow("gGroupStatusWindow2")
	clearWindow("gGroupStatusWindow")
	clearWindow("gGroupStatusWindow2")

	-- resizing of map window - rightlabel is 34%
	if charData:get("groupwindow") == "bottom" then
		demonnic.chat.container:move(nil, 0)

		if NyyLIB.mapwindow ~= nil then
			NyyLIB.mapwindow:move("66%", nil)
			NyyLIB.mapwindow:resize("34%", "50%")
		end
	end

	if charData:get("groupwindow") == "split" then
		demonnic.chat.container:move(nil, 0)

		if NyyLIB.mapwindow ~= nil then
			NyyLIB.mapwindow:move("46%", nil)
			NyyLIB.mapwindow:resize("20%", "33%")
		end
	end

	RedrawGroupStatus()
end

-- This function resizes the group windows if needed

function resizeGroupWindow(xforce)
	local iconBar=Geyser.Label:getWindow("gIconBarWindow")
	local bottomWindow=Geyser.Label:getWindow("gGroupStatusWindow")
	local rightGroupWindow=gGroupStatusWindow2 -- Geyser.Label:getWindow("gGroupStatusWindow2") miniconsole doesn't work
	local rLabel=Geyser.Label:getWindow("RightLabel") 
	local WindowWidth, WindowHeight = getMainWindowSize()
	local currenty	-- holds the positive yp of the iconbar

	if iconBar ~= nil then
		currenty = tonumber(string.match(iconBar.y, '[0-9]+'))
	else
		-- windows haven't been created yet
		return
	end

	-- calculate/set font size of lower window
	local fontSize
	
	if charData:get("grpfontsize", true) == "auto" then
		--fontSize= maxfont(60, (WindowWidth/3-15))
	
		fontSize= maxfont(40, (WindowWidth/3-15))

		if fontSize &gt; 14 then
			fontSize = 14
		end	
	else
		fontSize= tonumber(charData:get("grpfontsize", true))
	end
	-- max font is 13
	

	local fontWidth,fontHeight = calcFontSize(fontSize)	
   bottomWindow:setFontSize(fontSize)

	local bottomWindowSize = fontHeight * bottomGroupWindowLines

	-- move and resize the windows
	if currenty ~= (bottomWindowSize+40) or xforce then
		local groupWindowsType=charData:get("groupwindow")

		-- move icon window up/or down .y is top 
		if groupWindowsType == "bottom" or groupWindowsType == "all" then
			iconBar:move(nil,-(bottomWindowSize+40) )

			-- move RLabel if map on/off
			if charData:get("map") == "on" then
				rLabel:move(nil, "50%")
			else
				rLabel:move(nil, "0")
			end
		elseif groupWindowsType == "split" then
			iconBar:move(nil, -(bottomWindowSize+40) )
		else
			iconBar:move(nil,-(40))
		end
		
		-- update currenty to the new iconbar position
		currenty = tonumber(string.match(iconBar.y, '[0-9]+'))

		-- lower window
		bottomWindow:move(nil, "-" .. bottomGroupWindowLines .. "c")	
		bottomWindow:resize(nil, bottomGroupWindowLines .. "c")
		setBackgroundColor("gGroupStatusWindow", 0,0,0,255)
	
		-- resize RightPanel
		Geyser.Label:getWindow("RightPanel"):resize(nil, WindowHeight-currenty )

		-- lua display(Geyser.Label:getWindow("RightPanel"):get_height() )
		--826


		-- move right window, resize chat window
		local rFontSize=rightGroupWindow.fontSize
		local rFontWidth,rFontHeight = calcFontSize(rFontSize)	

		local newyp=-( rightGroupWindowLines*rFontHeight+(.02*WindowHeight ) ) -- correct

		if groupWindowsType == "split" then

			Geyser.Label:getWindow("RightLabel"):move(nil, 0)
			-- resize and move right group window

			rightGroupWindow:resize(nil, rightGroupWindowLines .. "c") -- correct

			rightGroupWindow:move(nil, newyp) -- correct note: newyp is a negative number

			-- resize chat window

			-- newyp is a negative number
			demonnic.chat.container:resize(nil, WindowHeight+newyp - (currenty) - 40 )
			--demonnic.chat.container:resize(nil, (WindowHeight*.82)+newyp ) -- TODO fix
		else
			-- *** rightpanel has been resized. .chat.container is inside right panel

			if charData:get("map") == "on" then
				demonnic.chat.container:resize(nil, (Geyser.Label:getWindow("RightPanel"):get_height()*.98)/2-currenty) -- correct?
			else
				demonnic.chat.container:resize(nil, (Geyser.Label:getWindow("RightPanel"):get_height()*.98)-40 ) -- almost correct
			end
		end

		-- resize left panel -  WindowHeight-(bottomWindowSize+40) (32 for xp window)

		local lLabel=Geyser.Label:getWindow("LeftLabel")

		-- move label if xp window is visible, resize
		if charData:get("level") == 50 then 
			lLabel:resize(nil, WindowHeight-(bottomWindowSize+40) )
			lLabel:move(nil,0)
		else
			lLabel:resize(nil, WindowHeight-(bottomWindowSize+40+32) )
			lLabel:move(nil,32)
		end

		demonnic.chat:redo()
	end

	-- adjust left border

	--setBorderLeft ( math.ceil(WindowWidth/20) )

	-- set bottom border if window sizes have changed
	bottomBorderPX = bottomBorderPX or 0

	if bottomBorderPX ~= currenty then
		bottomBorderPX = currenty
		setBorderBottom(bottomBorderPX)
	end
end

-- credit to Akaya @ http://forums.mudlet.org/viewtopic.php?f=5&amp;t=4610&amp;start=10#p21770

function setStyle()
local background_color = "#26192f"
local border_color = "#b8731b"
local black_color = "#000000"

--		spacing: 10;
-- 	QToolButton:pressed {	background-color: red;}

 
setAppStyleSheet([[
  QMainWindow {
     background: ]]..background_color..[[;
  }

  QMainWindow::separator {
     background: ]]..background_color..[[;
  }

  QToolBar {
     background: ]]..background_color..[[;
  }

  QToolButton {
     background: ]]..background_color..[[;
     border-style: solid;
     border-width: 2px;
     border-color: ]]..border_color..[[;
     border-radius: 5px;
	  font-family: BigNoodleTitling;
     color: white;
     margin: 2px;
     font-size: 12pt;
  }

	QToolButton:hover { background-color: grey;}
	QToolButton:focus { background-color: grey;}

	QMenuBar{ background-color: ]]..background_color..[[;}

	QMenuBar::item{ background-color: ]]..background_color..[[;}

  QDockWidget::title {
     background: ]]..border_color..[[;
  }

  QStatusBar {
     background: ]]..background_color..[[;
  }
  QScrollBar:vertical {
     background: ]]..background_color..[[;
     width: 15px;
     margin: 22px 0 22px 0;
  }
  QScrollBar::handle:vertical {
     background-color: ]]..background_color..[[;
     min-height: 20px;
     border-width: 2px;
     border-style: solid;
     border-color: ]]..border_color..[[;
     border-radius: 7px;
  }
  QScrollBar::add-line:vertical {
   background-color: ]]..background_color..[[;
   border-width: 2px;
   border-style: solid;
   border-color: ]]..border_color..[[;
   border-bottom-left-radius: 7px;
   border-bottom-right-radius: 7px;
        height: 15px;
        subcontrol-position: bottom;
        subcontrol-origin: margin;
  }
  QScrollBar::sub-line:vertical {
   background-color: ]]..background_color..[[;
   border-width: 2px;
   border-style: solid;
   border-color: ]]..border_color..[[;
   border-top-left-radius: 7px;
   border-top-right-radius: 7px;
        height: 15px;
        subcontrol-position: top;
        subcontrol-origin: margin;
  }
  QScrollBar::up-arrow:vertical, QScrollBar::down-arrow:vertical {
     background: white;
     width: 4px;
     height: 3px;
  }
  QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
     background: none;
  }
]])

	setBackgroundColor("gGroupStatusWindow", 0,0,0,255)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>TimerScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
timer = timer or {}
timer.values = timer.values or {}

-- Usage:
--
-- timer:init() - create master timer
-- timer:get(xname) - return current value or nil
-- timer:set(xname, xduration) -- set timer 'xname' to value 'xduration' (duration=nil removes timer)
-- timer:custom - if created, this script will be called every second after all timers are updated
--
-- If a function exists matching the name of the timer, it will be called every second with arguments (functionname, timervalue).
-- When time remaining reaches 0, the timer will then be removed.


function timer:init()
	-- disable v1 timer if present, create v2 timer

	if exists("MudTimer", "timer") == 1 then
		disableTimer("MudTimer")
	end

	if exists("MudTimer2", "timer") == 0 then
		permTimer("MudTimer2", "", 1, [[timer:script()]] )
	end


	enableTimer("MudTimer2")
end

function timer:set(xname, xduration)
	-- echoDebug("&lt;red&gt;\n[timer:set - " .. tostring(xname) .. " : " .. tostring(xduration) .. "]\n")
	
	if xname == nil then
		cecho("&lt;red&gt;\n[Error: timer:set xname is nil]\n")
	end
	
	self.values[xname] = xduration
end

function timer:get(xname)
	if self.values[xname] == nil then
		return(nil)
	end

	return (self.values[xname])
end

function timer:script()
	-- decrement all timers
	for k, v in pairs(timer.values) do
		timer.values[k] = timer.values[k]-1

		-- is this timer for a meleePower?
		
		local meleeTimer = meleePowers:getCharData(k)

		-- is this timer for a melee SPELL power

		local meleeSpellTimer = not powerAliases:isCasterSpell(k)


		-- Timer has reached 0 (expired)
		if timer.values[k] &lt; 1 and k ~= "" then
			timer.values[k] = nil	

			if meleeSpellTimer and 1 == 2 then -- todo: set to not be used
				meleeSpellButton(k, 0)
			elseif meleeTimer then
				meleePowersUpdate(k, 0)
			else
				if _G[k] ~= nil then
					-- call timer with 0 (expired)
					_G[k](k, 0)
				end
			end
		else
			-- have timer called every second with "fname, time" as argument
			
			if meleeTimer then
				meleePowersUpdate(k, timer.values[k])
			else
				if _G[k] ~= nil then
					_G[k](k, timer.values[k])
				end
			end
		end
	end

	if timer.custom ~= nil then
		timer:custom()
	end
end

-- melee spell button : charData is wrong : TODO

function meleeSpellButton(fname, xcommand)
	-- if xcommand &gt; 0, function being called re: timer
	
	display("meleeSpellButton: error")
	
	if xcommand &gt;= 0 then
		PopulateButtonCooldown(fname, xcommand)
	end
	
	if xcommand == buttons.INIT then
		if charData:get("blksos") then
			setLabelImage(fname, fname .. "-on.png")
		else
			setLabelImage(fname, fname .. "-off.png")
		end
		return
	end

	if xcommand == buttons.CLICK then
		shiftSkillButton(fname, "blksos", xcommand)
	end
end

function timer:custom()
	NyyLIB.ticktimer= NyyLIB.ticktimer-1

	local x, y = getMousePosition()
	local movement=false
	
	if x ~= mousex or y ~= mousey then
		-- mouse movement has occured
		movement=true
		
		mousex=x
		mousey=y
	end
	
	-- a tooltip is visible and mouse movement has occured
	if toolTipActive and movement then
			toolTip:hide()
	end

	-- if no mouse movement, inside icon, and no tooltip currently displayed: display tooltip
	
	-- call button function with value passed: buttons.HOVER
	if not movement and currentIcon and not toolTipActive then
		showToolTip()
	end
	
	if NyyLIB == nil or Geyser.Label:getWindow("gIconBarWindow") == nil then
		return
	end

	if NyyLIB.ticktimer &lt; 1 then
		NyyLIB.ticktimer = 60
	end

	local label=findbutton("0.2")

	-- this displays the number in the bottom left corner
	if label ~= nil then
		-- clear current value
		setBackgroundColor(label.name, 0, 0, 0, 0)
		label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt; &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])	

		-- display assassinate timer

		local value=timer:get("assassinatetimer")

		if value ~= nil then
			label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;]] .. bufftimedisplay(value) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])	
		end

		-- TODO: global cooldown
	
		--local value=timer:get("cooldown")

		--if value ~= nil then
		--	label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;]] .. value .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])	
		--end

		-- display stun count
		local value=buff:get("stun")

		if value ~= nil then
			label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;]] .. value .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])	
		end
	end

	if NyyLIB.songtimer ~= nil and NyyLIB.songtimer ~= "" then
		if NyyLIB.songtimer &gt; 0 then
			NyyLIB.songtimer = NyyLIB.songtimer - 1

			label=findlabel("StopMusic")
				
			if label ~= nil then
				clearWindow("StopMusic")
				label:echo([[&lt;p style="font-size:25px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;]] .. NyyLIB.songtimer .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
			end
		end
	end

	if checkMask("enc") then
		if buff:get("time_stop") then
			PopulateTimestop()
		end
	end

	decreasebuffs()

	RedrawGroupStatus()
end

function timedisplay(seconds)

	local sec
	local min

	min=math.floor(seconds/60)

	sec=seconds-(min*60)

	return ( string.format("%d:%02d", min, sec))
end

function bufftimedisplay(seconds)

	local sec
	local min

	if seconds == nil then
		return("X")
	end

	min=math.floor(seconds/60)

	sec=seconds-(min*60)

	if min &gt; 0 then
		return( string.format("%2d", min) )
	end

	if sec &lt; 10 then
		return( string.format("%02d", sec) ) 
	end

	return ( string.format("%02d", sec) )
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PromptScripts</name>
					<packageName></packageName>
					<script>prompt = prompt or {}

function prompt:set(xkey, xvalue)
	self[xkey]=xvalue
end

function prompt:get(xkey)
	return(self[xkey])
end

function prompt:isStringPrompt(teststring)
	if string.find(teststring, "^&lt; .* &gt;") then
		return(true)
	end

	return(false)
end

-- melee powers + spell powers
-- overlap from yuanti?
-- class powers with identical names ss=sandstorm, sweeping strike

function prompt:decodePowers(xstring)
	-- initial prompt on login
	if whoclass() == nil then
		return
	end
	
	local powersTable = string.split(xstring, "|")
	
	for nx=1,#powersTable,1 do
		local testItem = powersTable[nx]
		
		if testItem ~= "" then
			local powersAlias = string.match(testItem, "^([a-z]+) .*")
			local powersName=meleePowers:getName(powersAlias)
			
			local powersCooldown = string.match(testItem, "^[a-z]+ (.*)")
			local powersRound = tonumber(powersCooldown) or 0
			
			-- if timer exists set it to powersRound * 4 (seconds)
			if powersName ~= nil then
				if timer:get(powersName) then
					timer:set(powersName, powersRound*4)
				end
			end
		end
	end
end

function prompt:decodeSpellSlots(xstring)
	local powersTable = string.split(xstring, "|")

	for nx=1,#powersTable-1,1 do
		spell:setSlot(nx, tonumber(powersTable[nx]) )
	end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellQueue</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

spell = spell or {}
spell.spellcastqueue = spell.spellcastqueue or {}		-- queued spells
--spell.varsendqueue = spell.varsendqueue or {}  -- queued non-spell cmds

failedSpell = failedSpell or {}

mud = mud or {}

mud.varsendqueue = mud.varsendqueue or {}

function mud:sendCommands()
	local nx

	if mud.sending ~= nil then
		return
	end

	mud.sending = true

	if mud.varsendqueue ~= nil and mud.varsendqueue ~= {} then

		while #self.varsendqueue ~= 0 do
			local sendcommand = self.varsendqueue[1]

			table.remove(self.varsendqueue, 1)

			local assistcheck = string.match(sendcommand, "^assist (.*)")

			-- screen echo if command is order
			if string.match(sendcommand, "^ORDER (.*)") then
					cecho("\n&lt;yellow&gt;[ " .. sendcommand .. " ]\n")
			end 


			if assistcheck == nil then
				if sendcommand ~= "\n" then
					-- echoDebug("&lt;green&gt;[ Send: " .. sendcommand .. " ] ")
				end
				lastsent = sendcommand
				expandAlias(sendcommand, charData:get("condensed", true)["debug"])
			else
				if prompt:get("tank") == "" then
					echoDebug("&lt;green&gt;[Sending: " .. sendcommand .. "] ")
					lastsent = sendcommand
					expandAlias(sendcommand, charData:get("condensed", true)["debug"])
				else
					echoDebug("&lt;blue&gt;[Not sending assist]\n")
				end
			end
		end
	end

	mud.sending = nil
end

function mud:send(xcmd)
	mud.varsendqueue = mud.varsendqueue or {}

	-- don't queue duplicates commands?

	if table.contains(mud.varsendqueue, xcmd) == false then
		if xcmd ~= "\n" and table.size( mud.varsendqueue ) ~= 0 then
			echoDebug("\n&lt;red&gt;[ mud:send queue : " .. xcmd .. " ]")
		end

		table.insert(mud.varsendqueue, xcmd)
	else
		echoDebug("\n&lt;red&gt;[NOT Queuing: " .. xcmd .. "]")
	end

	-- send all queued commands if not casting or in fugue 

	if 	spell:getCurrent() == nil or map:getRoom() == 93848 then
		-- send queue contents
		mud:sendCommands() 
	end
end

function spell:setCast(xspell)
	if xspell ~= nil then
		self.spellsCast[xspell] = true
	else
		self.spellsCast = {}
	end
end

function spell:getCast()
	self.spellsCast = self.spellsCast or {}

	return ( self.spellsCast )
end


-- spell:attempt(tank, "dragonscales", "ds") then

function spell:attempt(xchar, xspell, xcommand) -- if xchar doesn't have xspell and spells available/memorized, cast it

	-- if failedSpell matches then return false

	--if xcommand .. " " .. xchar == failedSpell then
	--	echoDebug("&lt;red&gt;[failedSpell: " .. failedSpell .. "]\n")
	--	return(false)
	--end

	-- trim to 25 chars

	-- no target set for spell
	if not xchar then
		if getSpellCount(xspell) &gt; 0 then
			spell:cast(xcommand)
			return(true)
		end
		return(false)
	end

	
	-- don't cast spells on people outside room, dead
	-- TODO: may need to check for death pact
	
	if groupList:getHP(xchar) == 0 or table.contains(NyyLIB.deadpeople, xchar) then
		return
	end

	if not buff:get(string.sub(xspell, 1, 25), xchar) then

		-- dragonscales/stoneskin are exclusive
		if xspell == "dragonscales" and buff:get("stoneskin", xchar) then
			return(false)
		end

		if xspell == "stoneskin" and buff:get("dragonscales", xchar) then
			return(false)
		end

		if getSpellCount(xspell) &gt; 0 then
			if groupList:getHP(xchar) ~= 0 then
				spell:cast(xcommand .. " " .. xchar)
				return(true)	
			end
		end
	end

	return(false)
end

function spell:getMoving()
	self.moving = self.moving or false

	return ( self.moving )
end

function spell:setMoving(xstatus)

	if self.moving ~= xstatus and charData:get("autocast") then
		if xstatus then
			cecho("&lt;red&gt;\n\n[Currently moving. Spellcasting is temporarily paused.]\n\n")
		else
			cecho("&lt;red&gt;\n\n[No longer moving. Spellcasting has resumed]\n\n")
		end
		
		--cecho("&lt;red&gt;\n[spell:setMoving(xstatus) : " .. tostring(xstatus) .. "]\n")
	end

	if xstatus then
		automem = 0
		setEnemy("")
		assistSent=nil
	end

	self.moving = xstatus
end

function spell:getMem()
	self.memorize = self.memorize or false

	return ( self.memorize )
end

function spell:setMem(xstatus)

	if xstatus ~= self.memorize then
		echoDebug("&lt;green&gt;\n[spell:setMem(xstatus) : " .. tostring(xstatus) .. "]\n")
	end

	memsent = false

	self.memorize = xstatus
end

-- return who cast the spell that just completed

function spell:whocast()
	--Mizes completes his spell... (his|her|its)
	--You complete your spell...
	--You are surrounded in a brilliant aura of holy power.
	
	--TODO: If echosend enabled need to check back further then 1 line
	
	local castline = getLines(getLineNumber()-1, getLineNumber())[1]
	local charname

	if string.find(castline, "You complete your spell...") ~= nil then
		return(whoami())
	end

	charname = string.match(castline, "([A-Za-z]+) completes ")

	return(charname)
end

function spell:setCurrent(xspell)
	self.casting=xspell
end

function spell:getCurrent()
	return(self.casting)
end

-- no spell is currently being cast
function spell:stop()
	spell:setCurrent(nil)
	echoDebug("\n&lt;blue&gt;[Setting spell.casting to nil]")
end


function spell:count()
	return( #self.spellcastqueue )
end


function spell:eraseQueue()
	self.spellcastqueue = {}
end


-- remove all queued spells matching pattern xspell - if xspell not set, clear entire spellqueue

function spell:clear(xspell, noAbort)
	
	-- this should be checked on function calls	
	if checkMask("psi") then
		return
	end
	
	if xspell == nil then

		-- abort spell if casting - need to fix for stun (don't send abort)
		if spell:getCurrent() ~= nil and not nomagic then
			-- The abort command is sent direct to mud, not queued

			if not noAbort then
				send("abort")
			end

			--if pet:status("ghost") then
			--	mud:send("ORDER ghost abort")
			--end			
		end

		spell:eraseQueue()

		spell:stop()

		cecho("\n&lt;blue&gt;[Spellqueue cleared.]\n")

		memsent = false

		mud:sendCommands()

		return
	end

	local ix=0

	if spell:count() ~= 0 then
		for ix=spell:count(), 1, -1 do
			if self.spellcastqueue[ix] == nil then
				cecho("\n&lt;red&gt;[Error: clear spell " .. xspell .. "]\n")
				display(ix)
			end

			if string.find(self.spellcastqueue[ix], "^" .. xspell) then
				table.remove(self.spellcastqueue, ix)
			end
		end
	end

	if string.find(spell:getCurrent() or "", "^" .. xspell) then
		echoDebug("&lt;red&gt;[Sending abort: " .. spell:getCurrent() or "" .. " : " .. xspell .. "]\n")

		-- The abort command is sent direct to mud, not queued

		if not noAbort then
			send("abort")
		end
	end
end


-- will char be able to cast or use power?

function spell:castOK()
	-- if escapedir set don't cast
	if NyyLIB.escapedir ~= nil then
		return(false)
	end

	-- can't cast if bashed/sitting
	if prompt:get("position") ~= "std" then
		return(false)
	end

	-- can't cast in fugue

	if map:getRoom() == 93848 then
		return(false)
	end

	-- stunned, can't cast

	if buff:get("stun") then
		return(false)
	end

	-- paralyzed, can't cast

	if buff:get("minor_paralysis") or buff:get("major_paralysis") then
		return(false)
	end

	-- if melee power used/no response, can't cast
	
	if meleePowerUsed then
		return(false)
	end
	
	-- if bash was sent, 10 second cooldown
	
	if timer:get("bash") then
		return
	end
	
	return(true)
end

function spell:cast(xspell)
	if xspell ~= nil then
		echoDebug("&lt;red&gt;[spell:cast : " .. tostring(xspell) .. "]\n")
	end

	if not spell:castOK() then
		return
	end

	if spell:getCurrent() == "group" or spell:getCurrent() == "look" then
		spell:eraseQueue()
	end

	if not spell:getCurrent() then
		mud:sendCommands()
	end

	-- don't cast spells when sending status or waiting on look

	if sendingStatus then
		return
	end
	
	-- don't cast spells when mem'ing or moving

	if spell:getMem() or memsent or spell:getMoving() then
		return
	end

	-- don't cast if trying to mem or look sent/not received
	if spell:getMem() or memsent or look:get() then
		return
	end

	-- don't queue spells if already casting
	if self.casting then
		if xspell == nil then
			echoDebug("&lt;red&gt;[Currently casting: " .. self.casting .. "]\n")
			return
		end

		return
	end

	if xspell ~= nil then
		-- remove spell from queue if already present
		for ix=spell:count(), 1, -1 do
			if string.find(self.spellcastqueue[ix], "^" .. xspell) then
				--echoDebug("&lt;red&gt;[Removing from spellcastqueue: " .. xspell .. "]\n")
				table.remove(self.spellcastqueue, ix)
			end
		end

		-- do not queue spell if casting that spell
		if spell:getCurrent() ~= xspell then
			self.spellcastqueue[spell:count()+1] = xspell
		end
	end

	if spell:getCurrent() == nil then
		mud:sendCommands()

		if spell:count() &gt; 0 then
			local tocast = self.spellcastqueue[1]

			-- if fh spell and &gt; 80% hp, remove from queue

			local fhchar = string.match(tocast, "^fh (.*)")

			if groupList:ingroup(fhchar) then
				local hp=tonumber(groupList:getHP(fhchar))
				local maxhp= tonumber(groupList:getMaxHP(fhchar))

				if hp &gt; .8 * maxhp then
					-- remove spell from queue, try casting next spell
					table.remove(self.spellcastqueue, 1)
					spell:cast()
					return
				end
			end

			spell:setCurrent(tocast)
			table.remove(self.spellcastqueue, 1)

			-- command is sent here. If first letter is capital, don't display send?
			
			local displayname = to_english(powerAliases:toSpell(self.casting:lower()))

			cecho("\n&lt;red&gt;[&lt;cyan&gt;SPELL: &lt;red&gt;" .. displayname .. "] &lt;yellow&gt;" .. self.casting )

			if self.casting == string.title(tostring(self.casting)) then
				-- this send is not queued
				send(self.casting, false)
			else
				-- this send is not queued
				send(self.casting, true)
			end
		end
	end
end

function spell:setNext(xcommand)
	-- move to top of queue, or add if non-existant

	-- don't cast spells when sending status

	if sendingStatus then
		return
	end

	-- if currently casting this spell return
	if self.casting ~= nil then
		if self.casting == xcommand then
			echoDebug("\n&lt;red&gt;[Not queuing, already casting: " .. self.casting .. "]\n")
			return
		end
	end

	-- this is supposed to remove from queue if already present

	if table.contains (self.spellcastqueue, xcommand) then
		table.remove(self.spellcastqueue, table.index_of(self.spellcastqueue, xcommand) )
	end

	-- only queue spells if not in fugue

	if map:getRoom() ~= 93848 then
		table.insert(self.spellcastqueue, 1, xcommand)
	else
		self.casting=nil
	end

	spell:cast()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>WhoScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- NyyLIB.WhoClass.wholist xname={xclass,xrace,xprofilename}

function fixwholist()
	-- internal, not called
	local removed=0
	local total=0

	for k,v in pairs(NyyLIB.WhoClass.wholist) do
		if #(sqlclist(k)) &gt; 0 then
			removed=removed+1
			NyyLIB.WhoClass.wholist[k]=nil
		end

		total=total+1
	end

	echo("Total " .. total .. "\n")
	echo("Removed " .. removed .. "\n")
end

function savewholist()
	table.save( homepath("wholist_v3"), NyyLIB.WhoClass.wholist)
end

function loadwholist()
	NyyLIB.WhoClass = NyyLIB.WhoClass or {}
	NyyLIB.WhoClass.wholist = NyyLIB.WhoClass.wholist or {}

	local is_file = io.open( homepath("wholist_v3") )
	
	if is_file == nil then
		echo("[Creating wholist]\n")

		table.load( mainpath("wholist_v3"), NyyLIB.WhoClass.wholist )
		savewholist()
	end

	table.load( homepath("wholist_v3"), NyyLIB.WhoClass.wholist)
end

-- inwho(xname) - returns false or profilename

function inwho(xname)
	local profilename


	if string.findPattern(xname, " ") ~= nil then
		return(false)
	end

	if xname == "Someone" then
		return(false)
	end

	if NyyLIB.WhoClass.wholist[xname] ~= nil then
		return(NyyLIB.WhoClass.wholist[xname][3])
	end

	profilename = sqlinwho(xname)

	if profilename ~= false then
		return(profilename)
	end

	return(false)
end

-- k charname, v {x,x,x}
function whoclist(xname)
	for k,v in pairs(NyyLIB.WhoClass.wholist) do
		if k == xname or v[3] == xname then
			if sqlprofilename(k) == false then
				cecho(string.format("&lt;green&gt;[-- %15s] %20s %-15s (@%s)\n", v[1], k, 
					string.format("(%s)", v[2]), v[3]))
			end
		end
	end
end

function whoadd(xname, xclass, xrace, xprofile)
	NyyLIB.WhoClass.wholist = NyyLIB.WhoClass.wholist or {}

	-- find correct class name 
	for k, v in pairs(NyyLIB.fullclasslist) do
		if v[1] == xclass then
			xclass=v[2]
		end
	end

	if NyyLIB.WhoClass.wholist[xname] == nil then
		if xprofile == nil then
			NyyLIB.WhoClass.wholist[xname] = {xclass, xrace, "unknown"}
		else
			NyyLIB.WhoClass.wholist[xname] = {xclass, xrace, xprofile}
		end
	else

		-- correct wrong class
		if NyyLIB.WhoClass.wholist[xname][1] ~= xclass then
			NyyLIB.WhoClass.wholist[xname][1]=xclass
		end
		-- use setProfile?
		--if xprofile ~= nil and xprofile ~= "unknown" then
		--	NyyLIB.WhoClass.wholist[xname][3] = xprofile
		--end
	end
end

function setProfile(xname, xprofile)
	NyyLIB.WhoClass.wholist[xname][3] = xprofile 
end

function getProfile(xname)
	if NyyLIB.WhoClass.wholist[xname] ~= nil then
		return ( NyyLIB.WhoClass.wholist[xname][3] )
	end

	return(nil)
end

function whoaccount(xname)
	for k,v in pairs(NyyLIB.WhoClass.wholist) do
		if v[3] == xname then
			return(k)	
		end
	end

	if NyyLIB.WhoClass.wholist[xname] ~= nil then
		return ( NyyLIB.WhoClass.wholist[xname][3] )
	end

	return(nil)
end

function whoclass(xname)
	-- if xname = nil then replace it with whoami()

	if xname == nil then
		xname = whoami()
	end

	if xname == "a gray slaad" then
		return("UNK")
	end

	local retval

	if xname ~= nil then
		if NyyLIB.WhoClass.wholist[xname] ~= nil then
			retval=NyyLIB.WhoClass.wholist[xname][1]
		end
	end
	
	if retval == "A-P" then
		retval = "Blk"
	end

	if NyyLIB.WhoClass.wholist[xname] ~= nil then
		return (retval)
	end

	return(nil)	
end


function whorace(xname)
	if xname == nil then
		xname=whoami()
	end


	if xname == "a gray slaad" then
		return("UNK")
	end

	if NyyLIB.WhoClass.wholist[xname] ~= nil then
		return ( NyyLIB.WhoClass.wholist[xname][2] )
	end

	return(nil)	
end

function whoami()
	return(whoamiv)
end

function setwhoami(xchar)
	whoamiv = xchar
end

function whosize(xname)
	local nx

	if xname == nil then
		xname=whoami()
	end

	local race=whorace(xname)

	for nx=1, #NyyLIB.fullracelist, 1 do
		if NyyLIB.fullracelist[nx][1] == race then
			return(NyyLIB.fullracelist[nx][2])
		end
	end

	return(nil)	
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ConsentScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
consent = consent or {}

consent.chars = consent.chars or {}

function consent:get(xchar)
	xchar=xchar:upper()
	
	if self.chars[xchar] == nil then
		self.chars[xchar] = false
	end

	return ( self.chars[xchar] )
end

function consent:set(xchar, xval)
	xchar=xchar:upper()

	self.chars[xchar]=xval
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PowerAliases</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

powerAliases= powerAliases or {}
-- { "banshee_wail", "bw", 46, "", ""}

powerAliases = powerAliases or {}

-- TODO: check on powers table should be moved to function


-- return power name for supplied alias (if it exists), or nil

function powerAliases:getName()
	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end


	-- need to check by class
end

-- return power alias for supplied name (if it exists), or nil

function powerAliases:getAlias(xname)
	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end

	for nx=#powerAliases[charclass], 1, -1 do
		if powerAliases[charclass][nx][1]:lower() == xname:lower() then
			return( powerAliases[charclass][nx][2] )
		end
	end

	return(nil)
end

-- return text for label

function powerAliases:getLabelText(xname)
	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end

	for nx=#powerAliases[charclass], 1, -1 do
		if powerAliases[charclass][nx][1]:lower() == xname:lower() then
			return( powerAliases[charclass][nx][6] )
		end
	end

	return(nil)
end


-- is this a caster-type spell = display spell count?

function powerAliases:isCasterSpell(xspellname)
	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end

	-- return true if a caster-type spell
	for nx=#powerAliases[charclass], 1, -1 do
		if powerAliases[charclass][nx][1] == xspellname then
			return( powerAliases[charclass][nx][5] )
		end
	end

	return(false)
end

-- return the charData entry associated with this spell

function powerAliases:getChardata(xspellname)
	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end

	for nx=#powerAliases[charclass], 1, -1 do
		if powerAliases[charclass][nx][1] == xspellname then
			return( powerAliases[charclass][nx][4] )
		end
	end

	return("")
end

-- { "needle_swarm", "ns", 26, "automissile", ""},

function powerAliases:addButtons()
--	addbutton("beltyns_burning_blood", 6, 31) -- hlmissile
--	addbutton("rain_of_blood", 3, 46)
--	addbutton("magic_missile", 5, 1)
--	addbutton("ward_undead", 12, 26)

	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return
	end

	-- loop through all spells, and add button if it matches

	for nx=1, #powerAliases[charclass], 1 do
		local name=powerAliases[charclass][nx][1]
		local level=powerAliases[charclass][nx][3]
		local spellkey=powerAliases[charclass][nx][4]

		if spellkey == "autohlmissile" then
			addbutton(name, 0, 3, level)
		end

		if spellkey == "autoarea" then
			addbutton(name, 0, 4, level)
		end

		if spellkey == "autovit" then
			addbutton(name, 0, 7, level)
		end

		if spellkey == "automissile" then
			addbutton(name, 0, 5, level)
		end

		if spellkey == "autohlarea" then
			addbutton(name, 0, 6, level)
		end

		if spellkey == "autostorm" then
			addbutton(name, 0, 7, level)
		end

		if spellkey == "autoheal" then
			addbutton(name, 0, 8, level)
		end

		if spellkey == "autoharm" then
			addbutton(name, 0, 9, level)
		end

		if spellkey == "turnundead" then
			addbutton(name, 0, 12, level)
		end

		if spellkey == "autoquake" then
			addbutton(name, 0, 13, level)
		end
	end
end


function powerAliases:castDamage()
	local charclass = whoclass()

	local charDataEntries= {}

	-- abort if not in combat or other spells currently queued
	if not inCombat() or spell:count() &gt; 0 then
		return(false)
	end

	--display(spell:getCurrent())

	-- faerie fire
	if charData:get("autoffire") then
		if not (spell:getCast())["ff"] then
			if getSpellCount("faerie_fire") &gt; 0 then
				if table.size( spell:getCast() ) == 0 then
					spell:cast("c 'faerie fire'")
					return
				end
			end
		end
	end

	if charData:get("turnundead") then
		charDataEntries[#charDataEntries+1] = "turnundead"
	end

	if charData:get("autohlarea") then
		charDataEntries[#charDataEntries+1] = "autohlarea"
	end

	if charData:get("autohlmissile") then
		charDataEntries[#charDataEntries+1] = "autohlmissile"
	end

	if charData:get("autoarea") then
		charDataEntries[#charDataEntries+1] = "autoarea"
	end

	if charData:get("automissile") then
		charDataEntries[#charDataEntries+1] = "automissile"
	end

	if charData:get("autoharm") then
		charDataEntries[#charDataEntries+1] = "autoharm"
	end

	if charData:get("autowail") then
		charDataEntries[#charDataEntries+1] = "autowail"
	end


	-- loop through all spells, and cast the first spell that matches

	for nx=#powerAliases[charclass], 1, -1 do
		if table.contains(charDataEntries, powerAliases[charclass][nx][4]) then
			if getSpellCount(powerAliases[charclass][nx][1]) &gt; 0 then
				-- don't cast spells limited to 1/fight
				if not (spell:getCast())[powerAliases[charclass][nx][2]] then
					-- uppercase means gagging screen echo of the command being sent
					cecho("&lt;green&gt;\n[ powerAliases:castDamage() - " .. powerAliases[charclass][nx][2] .. " ]\n")
					spell:cast( string.upper(powerAliases[charclass][nx][2]) )
					return(true)
				end
			end
		end
	end

	return(false)
end

function powerAliases:findChardataButton(xchardata)
	local charclass = whoclass()

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return
	end

	-- loop through table
	for nx=#powerAliases[charclass], 1, -1 do
		if powerAliases[charclass][nx][4] == xchardata then
			local spellname= powerAliases[charclass][nx][1]
			local buttonBar, buttonid = buttons:id(spellname)

			if buttonid ~= nil then
				return(buttonid)
			end
		end
	end

	-- no existing button
	return(nil)
end

-- display correct button for highest level memd spell

function powerAliases:updateButton(xchardata)
	local charclass = whoclass()

	if xchardata == "" then
		return
	end

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return
	end

	for nx=#powerAliases[charclass], 1, -1 do
		if powerAliases[charclass][nx][4] == xchardata then
			local spellname= powerAliases[charclass][nx][1]
			local spelllevel= tonumber(powerAliases[charclass][nx][3])

			if getSpellCount(spellname) &gt; 0 then
				if not isIconActive(spellname) then
					-- TODO need to identify correct button number
					addbutton(spellname, 0, powerAliases:findChardataButton(xchardata), spelllevel)
				end

				return
			end
		end
	end				
end

-- return the power (without target)

function powerAliases:toPower(xcommand)
	local charclass = whoclass()

	-- non-powers spells
	if string.match(xcommand, "c[ast]* +'") ~= nil then
		return(nil)
	end

	-- check if powers table exists for current class
	if powerAliases[charclass] == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end

	-- extract power if string includes a target
	local powername = string.match(xcommand, "^([a-z]+) .*")

	if powername == nil then
		powername = xcommand
	end

	return(powername)
end

-- return the (fixed) spellname associated with a power

-- TODO: This should be changed to return name, target

function powerAliases:toSpell(xcommand)
	local charclass = whoclass()

	-- non-powers spells
	if string.match(xcommand, "c[ast]* +'") ~= nil then
		local _, _, spellname = string.find(xcommand, "c[ast]* +' *(.*) *'.*")
		return( to_snake(spellname) )
	end

	local powername = powerAliases:toPower(xcommand)

	if powername == nil then
		echoDebug("&lt;red&gt;[Power aliases not assigned for this class]\n")
		return(nil)
	end

	local spell=nil

	for nx=1, #powerAliases[charclass], 1 do
		if powerAliases[charclass][nx][2] == powername then
			return( powerAliases[charclass][nx][1] )
		end
	end

	echoDebug("&lt;red&gt;[Missing spell: " .. tostring(powername) .. "]\n")

	return(nil)	
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>PetScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The wraith of a human noble is busy, but will execute your order as soon as possible.
-- The wraith of a human noble starts casting an offensive spell called 'abi dalzims horrid wilting'.

-- The wraith of a human noble starts casting an offensive spell.
-- The wraith of a human noble completes its spell...


pet = pet or {}
pet.followers = pet.followers or {}
pet.oldfollowers = pet.oldfollowers or {}
pet.used = pet.used or {}

-- pet:add(petname, fullname, xhp, xmaxhp, inroom) - add pet to table
-- pet:delete(petname) - remove pet from table
-- pet:status() - return true if currently have any tracked pets
-- pet:status(type) - return true if currently have any tracked pets of 'type'



function pet:setRoom(xpet, xroom)
	if xpet == nil then
		return
	end

	if self.followers[xpet] == nil then
		return
	end

	echoDebug("&lt;red&gt;[Setting " .. xpet .. " to " .. tostring(xroom) .. "]\n")
	self.followers[xpet][6] = xroom
end

function pet:getRoom(xpet)
	if self.followers[xpet] ~= nil then
		return( self.followers[xpet][6] )
	end

	return(nil)
end

function pet:getOldRoom(xpet)
	if self.oldfollowers[xpet] ~= nil then
		return( self.oldfollowers[xpet][6] )
	end

	return(nil)
end

function pet:size()
	return( #pet:getTable() )
end

-- return true if that pet is undead
function pet:isUndead(xpetname)
	if self.followers[xpetname] ~= nil then
		if table.contains(self.followers[xpetname][5], "undead") then
			return(true)
		end
	end

	return(false)
end

function pet:getHP(xpetname)
	if self.followers[xpetname] ~= nil then
		return( self.followers[xpetname][2] )
	end

	return(nil)
end

function pet:setHP(xpetname, xvalue)
	if self.followers[xpetname] ~= nil then
		self.followers[xpetname][2]= xvalue
	end

	return(nil)
end


function pet:getMaxHP(xpetname)
	if self.followers[xpetname] ~= nil then
		return( self.followers[xpetname][3] )
	end

	return(nil)
end


function pet:orderAllCast(xspell)
	mud:send("ORDER followers cast '" .. xspell .. "'")

	return
end


-- pet:setInRoom(petname, xvalue) - xvalue true/false, is the pet in the current room or not

function pet:setInRoom(petname, xvalue)
	if self.followers[petname] ~= nil then
		if xvalue then
			self.followers[petname][4] = true
		else
			self.followers[petname][4] = false
		end
	else
		echoDebug("&lt;red&gt;[pet:setInRoom - " .. petname .. " is not in table]\n")
	end
end

-- pet:getInRoom(petname) - returns true if petname is in the current room

function pet:getInRoom(petname)
	if self.followers[petname] ~= nil then
		if map:getRoom() ~= nil then
			if map:getRoom() == pet:getRoom(petname) then
				return(true)
			end
		end

		if self.followers[petname][4] == "+" then
			return(true)
		else
			return(false)
		end
	else
		if petname == nil or petname == false then
			return(false)
		end

		--display(petname)

		echoDebug("&lt;red&gt;[pet:getInRoom - " .. petname .. " is not in table]\n")
		return(false)
	end
end

-- return a table of all followers of type ghost, wraith, or shadow

function pet:getCasterTable()
	local petlist = {}

	petlist = table.n_union(pet:getTable("ghost"), pet:getTable("wraith"), pet:getTable("shadow") )

	-- remove any from list not in current room
	for nx=1, #petlist, 1 do
		if not pet:getInRoom( petlist[nx] ) then
			table.remove(petlist, nx)
		end
	end

	return(petlist)
end

-- pet:getTable(xname) return a table of followers of type xname or all pets if nil passed

function pet:getTable(xname)
	local petlist = {}
	local testname
	

	if xname ~= nil then
		testname=pet:generateName(xname)
	end

	for k,v in pairs(pet.used) do
		if testname ~= nil then
			if string.findPattern(k, testname) then
				petlist[#petlist+1]=k
			end
		else
			petlist[#petlist+1]=k
		end
	end

	return(petlist)
end

-- pet:isNamed(xnamelist) - passed a mud formatted name list, and determines if any of the names match script renamed format

function pet:isNamed(xnamelist)
	-- passed list of possible names

	local keywords= string.split(xnamelist, " ")

	-- return existing formatted petname
	for k,v in pairs(keywords) do
		if string.match(v, "(.*[0-9]+)") then
			return(v)
		end
	end

	-- no name matches found
	return(nil)
end

-- pet:getShortName(xname) - return the 8 letter petname segment

function pet:getShortName(xname)
	local prefix= string.sub(whoami():lower(), 1, 3)

	local capture

	-- return existing formatted petname

	capture = string.match(xname, prefix .. "([a-z]+)[0-9]+")

	return(capture) 
end


-- pet:generateName(xname) return first 3 letters of whoami, first 8 letters of petname passed

function pet:generateName(xname)
	if xname == "gray" then
		xname= "slaad"
	end

	return(string.sub(whoami():lower(), 1, 3) .. string.sub(xname,1,8))
end


-- pet:generateNumberName(xname) - generates a name based on 'xname', and assigns an unused number to it

function pet:generateNumberName(xname)
	-- find first available numbered pet to use

	local nx

	for nx=1,15,1 do
		local testname= pet:generateName(xname) .. tostring(nx)

		if not pet.used[testname] then
			return(testname)
		end
	end

	cecho("&lt;red&gt;[pet:generateNumber - All possible pet numbers used]\n")
	return(pet:generateName(xname) .. "16")
end


-- pet:rescue(xchar) - order 1.spectre (or all followers) to rescue xchar

function pet:rescue(xchar)
	if checkMask("fighter") then
		return
	end

	if charData:get("petrescue") == "NONE" or getHide() then
		return
	end

	if spell["casting"] ~= nil or NyyLIB.escapedir ~= nil then
		return
	end

	-- paralyzed, can't send orders

	if buff:get("minor_paralysis") or buff:get("major_paralysis") then
		return
	end

	if xchar ~= "" and pet:status() then
		local spectrename=pet:getTable("spectre")[1]

		if spectrename ~= nil then
			if not pet:getInRoom(spectrename) then
				spectrename=nil
			end
		end

		if spectrename ~= nil then
			mud:send("ORDER " .. spectrename .. " rescue " .. xchar)
		elseif #pet:getTable() == #pet:getTable("ghost") then
			-- can't rescue if only pets are ghost, wraith, shadow
		elseif #pet:getTable() == #pet:getTable("wraith") then
			-- can't rescue if only pets are ghost, wraith, shadow
		elseif #pet:getTable() == #pet:getTable("shadow") then
			-- can't rescue if only pets are ghost, wraith, shadow
		else
			mud:send("ORDER followers rescue " .. xchar)
		end
	end
end

-- returns pet name if fullname passed matches the name of a pet

function pet:member(xfullname)
	if xfullname == nil then
		cecho("\n&lt;red&gt;[pet:member - xfullname is nil]\n")
	end

	for k,v in pairs(self.followers) do
		if v[1]:lower() == xfullname:lower() then
			return(k)
		end
	end

	return(false)
end

function pet:add(petname, fullname, xhp, xmaxhp, inroom, xfullkeywords)
	self.followers[petname] = {fullname, xhp, xmaxhp, inroom, xfullkeywords}
end

function pet:delete(petname)
	if self.followers[petname] ~= nil then
		self.followers[petname] = nil
	end
end

-- return true/false if a pet of type petname exists

function pet:status(petname)
	if petname == nil then
		if table.size(self.followers) &gt; 0 then
			return(true)
		else
			return(false)
		end
	else
		if #(pet:getTable(petname)) ~= 0 then
			return(true)
		else
			return(false)
		end
	end
end

-- usename marks a name as state:1 (believed to be used, not confirmed)

function pet:useName(petname)
	self.used[petname] = 1
end

-- confirmname marks a name as state:2 (has been confirmed to be in use)

function pet:confirmName(petname)
	self.used[petname] = 2
end

-- cleannames clears all unused names after having tested/confirmed them 

function pet:cleanNames()
	for k,v in pairs(self.used) do
		if v == 1 then
			self.used[k]=nil
		end
	end
end

-- pet:reset - sets all used entries to 1 in preperation to be confirmed

function pet:reset()
	self.oldfollowers = self.followers
	self.followers = {}

	for k,v in pairs(self.used) do
		self.used[k]=1
	end
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SoundScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

noSound = noSound or false

function sound(xname, xvolume, xlimited)
	local soundmode=charData:get("sound", false)

	if soundmode == "off" or (soundmode == "limited" and not xlimited) then
		return
	end
	
	if xvolume == nil then
		xvolume=100
	end

	-- if noSound has been set, this sound is one-time silenced
	if not noSound then
		echoDebug("\n&lt;red&gt;[sound: " .. xname .. "]\n")
		playSoundFile( soundpath(xname), xvolume )
	end

	noSound=false
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>RescueScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
rescuelist = rescuelist or {}

function rescuelist:generate()
	self.list= {}

	for k,char in pairs(groupList:pc("petRescue")) do
		table.insert(self.list, char)
	end
end	

function rescuelist:get()
	return(self.list)
end

function rescue(fname, xcommand)
	shiftSkillButton("rescue", "rescuetype", xcommand)
end

-- send rescue will send a single rescue command to the mud

rescueSent=false

function sendRescue(xchar)
	if rescueSent == false then

		-- can't rescue if blind
		
		if buff:get("blind") or buff:get("blindness") then
			return
		end

		if xchar == "someone" or xchar == "Someone" then
			return
		end

		-- stand first if sitting
		if spell:getMem() == true then
			mud:send("ST")
		end


		cecho("\n&lt;red&gt;[ Rescue: " .. xchar .. " ]\n")
		mud:send("RESCUE " .. xchar)

		if xchar == "ghost" then
			send("RESCUE 2.ghost")
		end

		if xchar == "guard" then
			send("RESCUE 2.guard")
			send("RESCUE 3.guard")
			send("RESCUE 4.guard")
		end

		rescueSent = true
	end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EnemyScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The ghoul of an opulent merchant

-- a minion of Moander 

function idMob(xname)
	local mobnames=
				{ "zombie", "ghoul", "skeleton", "wight", "shadow", "spectre", "ghast", "ghost", "spirit"}

	local enemytable = string.split(xname, " ")

	if string.find(xname, "shadow of") then
		return("shadow")
	end

	if string.find(xname, "elderly priest of Mielikki") then
		return("priest")
	end

	if string.find(xname, "Rhangaun, Leader of the Rune Council") then
		return("rhangaun")
	end

	if string.find(xname, "minion") then
		return("minion")
	end

	if string.find(xname, "doppelganger") then
		return("doppelganger")
	end

	if string.find(xname, "runelord") then
		return("runelord")
	end

	if string.find(xname, "tyrant") then
		return("beholder")
	end


	-- check for containing a matching name
	for nx=1, #mobnames, 1 do

		--if string.find("hell hound", mobnames[nx]) then
		--	return("wolf")
		--end

		if string.find(xname, mobnames[nx]) then
			return(mobnames[nx])
		end
	end

if xname == "a great Molydeus tanar'ri" then
	return( "molydeus" )
end

if enemytable[#enemytable] == "para-elemental" then
	return( "elemental" )
end

if enemytable[#enemytable] == "batle-mage" then
		return( enemytable[2] )
	end

	if enemytable[#enemytable] == "member" then
		return( enemytable[2] )
	end

	if enemytable[#enemytable] == "patrolman" then
		return( enemytable[3] )
	end

	-- return the final word in the string
	return( enemytable[#enemytable] )
end

function getEnemy()
	enemy = enemy or ""

	return(enemy)
end

function setEnemy(xval)
	if xval == nil then
		cecho("&lt;red&gt;[Error: setEnemy(nil)]\n")
		return
	end
	
	if getEnemy():lower() ~= xval:lower() then
		echoDebug("&lt;red&gt;\n[Setting enemy to: &lt;blue&gt;" .. tostring(xval) .. "&lt;red&gt;]\n")
	end

	enemy = xval
end

function sendCon(xname)
	--if conSent == nil then
	--	conSent=true

	--	mud:send("CON " .. xname )
	--end
	
	return
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellAlerts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function getQuake()
	bcastQuake = bcastQuake or false

	return(bcastQuake)
end

function setQuake(xval)
	bcastQuake = xval
end

function castQuake()
	if getQuake() then
		if getSpellCount("earthquake") &gt; 0 then
			spell:setNext("c 'earthquake'")
			setQuake(false)
			return(true)
		end
	end

	return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MountScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

mount = mount or {}

-- addbutton("SummonMount", 10, 15)

function mount:set(xname)
	self.mountname = xname

	if xname ~= nil and NyyLIB.initgui then
		if checkMask("summonmount") then
			addbutton("MountDismount", 0, 11, 15)
		end
	else
		if checkMask("summonmount") then
			addbutton("SummonMount", 0, 11, 15)
		end
	end
end

function mount:get()
	return( self.mountname )
end

function mount:setMounted(xval)
	self.mounted=xval

	dismounted=false

	if checkMask("dir") then
		if xval then
			addbutton("mounted_charge", 0, 3, 1)
		else
			initDir()
		end
	end
end

function mount:getMounted()
	if self.mounted == nil then
		self.mounted=false
	end

	return(self.mounted)
end

function mount:charge(xtarget)
	if not timer:get("mountedcharge") then
		if xtarget ~= nil then
			if checkMask("dir") then
				mud:send("mc " .. xtarget)
			else
				mud:send("charge " .. xtarget)
			end
		else
			if checkMask("dir") then
				mud:send("mc")
			else
				mud:send("charge")
			end
		end

		timer:set("mountedcharge", 8)

		return(true)
	end

	return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>singleSendScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- The look:send() command will send a single look command to the mud.

look = look or {}

function look:send()
	if not look:get() then
		toGagLook=true
		--gaglook=true
		mud:send("LOOK")
		look:set("LOOKSENT")
	end
end

function look:set(xstatus)
	self.status=xstatus
end

function look:get()
	if self.status == nil then
		return(false)
	end

	return(self.status)
end

-- The group:send() command will send a single group command to the mud.
-- All group responses from using this command are gagged

group = group or {}

-- gagGroup = true -&gt; gag group
-- gagGroup = nil  -&gt; don't gag

function group:send(xval)
	if xval == false then
		gagGroup=nil
		return
	end

	if gagGroup == nil then
		gagGroup=true
		mud:send("GROUP")
		group:set("GROUPSENT")

		--send the followers command after sending group if NOT rogue
		
		if not checkMask("rog") then
			sendFollowers()
		end
	end
end

function group:set(xstatus)
	-- cecho("&lt;cyan&gt;[group:set " .. tostring(xstatus) .. "]\n")
	self.status=xstatus
end

function group:get()
	if self.status == nil then
		return(false)
	end

	return(self.status)
end

-- The sendFollowers() command will send a single (gagged) followers command to the mud
-- Multiple calls to the command will not complete.

function sendFollowers(xval)
	-- don't send followers if hidden
	if xval == false or getHide() then
		followersSent=nil
		return
	end

	-- don't send followers if nil
	--if followers == nil then
	--	return
	--end

	-- don't send followers if rogue
	
	if checkMask("rog") then
		followersSent=nil
		return
	end

	-- don't send followers if meditating (psi)
	if checkMask("psi") and spell:getMem() then
		followersSent=nil
		return
	end

	if followersSent then
		echoDebug("\n&lt;blue&gt;[followers command already sent]")
	end

	if followersSent == nil then
		followersSent = true
		mud:send("FOLLOWERS")
	end
end

-- The sendStatus(xcharname) command requests status for that char

function sendStatus(xcharname)

	sendingStatus = true

	if xcharname == nil then
		mud:send("STATUS")
	else
		echoDebug("&lt;red&gt;\n[Sending status: " .. xcharname .. "]\n")
		mud:send("STATUS " .. xcharname )
	end
end

function sendAssist(xchar)
	--if xchar ~= nil then
	--	cecho("&lt;green&gt;[sendASsist: " .. xchar .. "]\n")
	--end

	if NyyLIB.castertrain then
		return
	end

	-- paralyzed, can't assist

	if buff:get("minor_paralysis") or buff:get("major_paralysis") then
		return
	end
	
	-- can't assist if blind
		
	if buff:get("blind") or buff:get("blindness") then
		return
	end
	
	-- if hp not listed send group
	if groupList:getHP(xchar) == 0 then
		group:send()
	end

	if charData:get("autoassist") == false then
		return
	end

	-- already in combat: why assist again?
	if inCombat() then
		return
	end

	-- sm caster train is active : flee to mem?
	if isActive("SMTrainCaster", "trigger") ~= 0 then
		if not fightreturn then
			if prompt:get("position") == "sit" then
				mud:send("ST")
			end

			-- send flee
			fleeMem()
			return
		end
	end

	echoDebug("&lt;red&gt;[assist]")

	if checkMask("rog") then
		local enemytarget = getEnemy()

		-- invis target, don't have di
		if enemytarget == "Someone" or enemytarget == "someone" then
			return
		end

		if enemytarget == "nightmare" then
			return
		end

		if enemytarget ~= "" then
			if enemytarget == "mage" or enemytarget == "wight" then
				if not buff:get("globe_of_invulnerability") then
					return
				end
			end
		end
	end

	if assistSent == nil then
		assistSent = true

		-- currently sitting: send stand first TODO is this sending multiple times?

		if prompt:get("position") == "sit" then
			mud:send("ST")
		end

		sendPoison()

		if checkMask("rog") then
			local enemytarget = getEnemy()

			if enemytarget ~= "" then
				-- if wraith kill, not backstab

				if timer:get("wraithform") then
					mud:send("KILL " .. enemytarget)
					return
				end

				if sendAssassinate(enemytarget) then
					return
				end

				-- nonpowers backstab for practice
				local backstab


				if prompt:get("hp") &gt; 1000 then
					backstab = "backstab " .. enemytarget
				else
					backstab = "bs " .. enemytarget
				end

				cecho("\n&lt;red&gt;[" .. backstab .. "]\n")
				mud:send(backstab)
			end

			look:send()

			return
		end

		-- mount before assisting
		if mount:get() ~= nil and not mount:getMounted() then
			--send("mount " .. mount:get() )
			mud:send("mount")
		end

		-- if memorizing stand before sending assist
		if spell:getMem() or memsent then
			mud:send("ST")
		end

		if checkMask("ran") then
			local enemytarget = getEnemy()

			if enemytarget ~= "" then
					cecho("\n&lt;red&gt;[&lt;cyan&gt;KILL " .. enemytarget .. "&lt;red&gt;]\n")
					mud:send("KILL " .. enemytarget)
					look:send()
					return
			end
		end

		echoDebug("&lt;red&gt;[assist " .. xchar .. "]\n")

		mud:send("assist " .. xchar)
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellTrackerScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- incSpellCount(xname)
-- decSpellCount(xname)
-- setSpellCount(xname, xvalue)
-- getSpellCount(xname)
-- resetSpellCount()

function resetSpellCount()
	cecho("&lt;red&gt;[Clearing memorized spells]\n")
	charData:set("spells", {})
end

function incSpellCount(xname)
	local count=charData:get("spells") or {}

	count[xname] = count[xname] or 0
	count[xname] = count[xname] + 1

	echoDebug("\n&lt;red&gt;[ incSpellCount: " .. xname .. " value: " .. getSpellCount(xname) .. " ]" )

	charData:set("spells", count)

	-- call script associated with memorized spell to update spellcount in gui

	updateSpellCount(xname)

	return
end

function decSpellCount(xname)
	local count=charData:get("spells") or {}

	count[xname] = count[xname] or 1
	count[xname] = count[xname] - 1

	echoDebug("\n&lt;red&gt;[ decSpellCount: " .. xname .. " value: " .. getSpellCount(xname) .. " ]" )

	charData:set("spells", count)

	-- call script associated with memorized spell to update spellcount in gui

	updateSpellCount(xname)

	return
end

function getSpellCount(xname)
	local count=charData:get("spells") or {}

	count[xname] = count[xname] or 0

	return( count[xname] )
end

function setSpellCount(xname, xvalue)
	local count=charData:get("spells") or {}

	count[xname] = xvalue

	charData:set("spells", count)

	-- call script associated with memorized spell to update spellcount in gui

	updateSpellCount(xname)

	return
end

function iCast()
	if string.find(getLines(getLineNumber()-1, getLineNumber())[1], "You complete your spell...") ~= nil then
		return true
	end

	return false
end

function initButton(xname)
	
	
	local meleeCharData = meleePowers:getCharData(xname)
	
	if meleeCharData then
		shiftButton(xname, meleeCharData, buttons.INIT)
		return
	else
		if _G[xname] == nil then
			if powerAliases:getChardata(xname) == "" then
				-- cecho("&lt;red&gt;[initButton: " .. xname .. " not set in powerAliases]\n")
				return
			end

			shiftButton(xname, powerAliases:getChardata(xname), buttons.INIT)
			return
		end
	end

	_G[xname](xname, buttons.INIT)
end

function updateSpellCount(xname, xcommand)
	local chardata= powerAliases:getChardata(xname)

	-- is this a melee powers spell?
	if not powerAliases:isCasterSpell(xname) then
		return
	end

	-- normal caster spell
	
	if chardata == "" then
		if _G[xname] == nil then
			echoDebug("&lt;red&gt;[updateSpellCount: xname " .. xname .. " has a nil function]\n")
		end

		if _G[xname] ~= nil then
			_G[xname](xname, buttons.UPDATE)
		end

		return
	else
		if xcommand ~= nil then
			shiftButton(xname, chardata, xname)
		else
			shiftButton(xname, chardata, buttons.UPDATE )
		end
	end

	powerAliases:updateButton(chardata)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIRoomWindow</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
roomWindow = roomWindow or {}
roomWindow.oldCount = roomWindow.oldCount or 0

-- Resize and reposition the room window

function roomWindow:resize()
	if self:exists() then
		local var=getLastLineNumber("gRoomWindow")

		if var == roomWindow.oldCount then
			return
		end
		
		roomWindow.oldCount = var

		if var ~= nil and var ~= -1 then
			local WindowWidth, WindowHeight = getMainWindowSize()
			local wwidth,wheight = calcFontSize(9)

			-- TODO: font size will need to be related to screensize.

			local ys = wheight * var

			roomLabel:resize(nil, ys+ 2*wheight)
			roomLabel:move("60%", "8%")
		
			self.windowid:resize(nil, var .. "c")
			self.windowid:move(nil, wheight)
		end
	end
end

-- Update the room window from the buffer

function roomWindow:update()
	if getLastLineNumber("roomBuffer") &gt; 0 then
		clearWindow("gRoomWindow")
		copyBuffer("roomBuffer", "gRoomWindow")
		clearWindow("roomBuffer")
	end
end

function roomWindow:test()
	roomLabel:setClickCallback("testfunction", "zzz", buttons.CLICK)
end

function testfunction()
	display("click")
end

-- Create the room window

function roomWindow:create()
	if not self:exists() then
		  roomLabel = Geyser.Label:new({name="gRoomWindowLabel", x="60%", y="8%", width="34%", height="15c",}) -- -92c, -80c
			roomLabel:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])

			self.windowid = Geyser.MiniConsole:new({name="gRoomWindow", x="5%", y="5%", width="90%", height="90%",}, roomLabel) -- -92c, -80c
	end

	self.windowid:setFontSize(9)

	if charData:get("roomwindow") == false then
		--self.windowid:hide()
		roomLabel:hide()
	end
end

-- Toggle the room window on/off

function roomWindow:toggle()
	if charData:get("roomwindow") then
		charData:set("roomwindow", false)
		cecho("&lt;red&gt;[Room capture display is OFF.]\n")
		roomLabel:hide()
		self.windowid:hide()
	else
		charData:set("roomwindow", true)
		cecho("&lt;red&gt;[Room capture display is ON.]\n")
		roomLabel:show()
		self.windowid:show()
	end
end

-- Return true if the room window has been created

function roomWindow:exists()
	if self.windowid ~= nil then
		return(true)
	else
		return(false)
	end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>SpellSlots</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
spell = spell or {}

spell.slots = spell.slots or {}


function spell:setSlot(xslot, xvalue)
	spell.slots[xslot] = xvalue
end

function spell:getSlot(xslot)
	return ( spell.slots[xslot] or 0)
end

function spell:resetSlot()
	self.slots = {}
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>EquipScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

equip = equip or {}

equip.weapontype = equip.weapontype or "none"

-- Shield, Dual, TwoHand, Bow, None

function equip:setWeapon(xweapon)

	-- If type (not weapon) passed, set to type
	if table.contains( {"Bow", "TwoHand", "Shield", "Dual", "None"}, xweapon ) then
		self.weapontype = xweapon
	else
		local checkBow = sqlIsBow(xweapon)
		local check2H = sqlIs2H(xweapon)
		local checkWeapon = sqlIsWeapon(xweapon)

		if #checkBow &gt; 0 then
			self.weapontype = "Bow"
		elseif #check2H &gt; 0 then
			self.weapontype = "TwoHand"
		elseif #checkWeapon &gt; 0 then
			if checkMask("ran") then
				self.weapontype = "Dual"
			else
				self.weapontype = "Shield"
			end
		else
			self.weapontype = "None"
		end
	end

	initClass()
end

function equip:getWeapon()
	return ( self.weapontype )
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>MeleePowers</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
meleePowers = meleePowers or {}

-- alias={ full name, level, weapontype, buttonnumber, chardata}

-- TODO: change charData entry to be generated / Class+Alias example: 'blksp'
-- Eventually entry could be automatic
-- generation should work button 20-&gt;1, first valid hit starting from end - pairs list=random?

meleePowers["War"] = 
		{ fa={ "furious_assault", 1, nil, nil},
			
			bds={"bodyslam",1,nil,nil,"warbds"},

			wu={"warriors_ultimatum",30, nil, nil, "warwu"},
			cc={"combat_challenge",1, nil, 12, "warcc"},

			cs={"comeback_strike", 1, "Shield",14, "warcs"},
			sb={"shield_bash", 5, "Shield",3, "warsb"},
			ds={"defensive_strike",15, "Shield",9,"wards"},
			bs={"brutal_strike",25, "Shield",10, "warbs"},
			ra={"relentless_assault",30,"Shield",15, "warra"},
			
			cv={"cleave", 1, "TwoHand",14, "warcv"},
			ss={"spinning_sweep",5, "TwoHand",3, "warss"},
			sk={"skullcrusher",15, "TwoHand",9, "warsk"},
			ua={"unyielding_avalanche", 25, "TwoHand",10, "warua"},
			ros={"rain_of_steel", 30, "TwoHand",15, "warros"},

			-- spells : fullname, level, weapontype, buttonnumber, chardata

			nop={"no_opening", 1, nil, nil, "warnop"},
			ut={"unstoppable",  10, nil, 1, "warut"},
			ub={"unbreakable", 5, nil, 2, "warub"},
			hd={"heroic_defense",  20, nil, nil, "warhd"},
			sod={"storm_of_destruction", 35, nil, 6, "warsod"},
			dsd={"diamond_shield_defense", 30, nil, 7, "wardsd"},
			iw={"iron_warrior", 40, nil, 8, "wariw"},
		}

meleePowers["Dir"] = 
		{ fa={ "furious_assault", 1, nil, nil},
			bh={"bash", 1, nil, 3, "dirbh"}
		}

meleePowers["Ran"] = 
		{	fa={ "furious_assault", 1, nil, nil},
		
			tr={"triple_shot", 1, "Bow", 12, "rantr"}, 
			ks={"knockdown_shot", 5, "Bow", 3, "ranks"},			
			sp={"splintering_shot", 15, "Bow", 14, "ransp"},
			cn={"concussive_shot", 25, "Bow", 13, "rancn"},
			ha={"hail_of_arrows", 30, "Bow", 15, "ranha"},
			
			ts={"twin_strike", 1, "Dual", 12, "rants"},
			ss={"sweeping_strike", 5, "Dual", 3, "ranss" },
			ap={"armor_splinter", 15, "Dual", 14, "ranap"},
			ev={"eviscerate", 25, "Dual", 13, "ranev"},
			bs={"bladestorm", 30, "Dual", 15, "ranbs"},

			-- spells : fullname, level, weapontype, buttonnumber, chardata
			
			lst={"longstrider", 1, nil, nil},
			hm={ "hunters_mark", 1, nil, 5, "ranhm"},
			clv={ "cloak_of_vigor", 1, nil, nil},
			dr={ "dawns_renewal", 10, nil, nil},
			clw={ "cloak_of_the_winds", 10, nil, 7, "ranclw"},
			bse={ "beast_sense", 10, nil, nil},
			lita={ "lightning_arrow", 20, "Bow", 11, "ranlita"},
			clp={ "cloak_of_protection", 20, nil, 6, "ranclp"},
			bof={ "blades_of_fire", 20, "Dual", 9, "ranbof"},
			trs={ "tree_stride", 30, nil, nil},
			hot={ "hail_of_thorns", 30, "Bow", 9, "ranhot"},
			eld={ "electric_discharge", 30, "Dual", 11, "raneld"},
			clr={ "cloak_of_resilience", 30, nil, 8, "ranclr"},
			msp={ "misty_path", 40, nil, 4, "ranmsp"},
			grf={ "greenfire", 40, "Dual", 10, "rangrf"},
			cll={ "cloak_of_life", 40, nil, nil},
			ab={ "arctic_barrage", 40, "Bow", 10, "ranab"}
		}

meleePowers["Pal"] = 						 
		{	fa={ "furious_assault", 1, nil, nil},
		
			lh={"lay_on_hands", 1, nil, 1, "pallh"},
			ds={"divine_smite", 1, "All", 2, "palds"},
			tn={"true_nemesis", 30, nil, nil, "paltn"},
			dc={"divine_challenge", 1, nil, 12, "paldc"},

			bs={"bolstering_strike", 1, "Shield", 14, "palbs"},
			rc={"radiant_charge", 5, "Shield", 3, "palrc"},
			ss={"shielding_smite", 15, "Shield", 9, "palss" },
			es={"enervating_smite", 25, "Shield", 10, "pales"},
			ws={"wrathful_smite", 30, "Shield", 15, "palws"},

			vs={"valiant_strike", 1, "TwoHand", 14, "palvs"},
			ts={"thunderous_smite", 5, "TwoHand", 3, "palts"},
			brs={"brilliant_smite", 15, "TwoHand", 9, "palbrs"},
			trs={"terrifying_smite", 25, "TwoHand", 10, "paltrs"},
			wws={"whirlwind_smite", 30, "TwoHand", 15, "palwws"},

			-- spells
			
			sf={ "shield_of_faith", 1, "", 8, "palsf"},
			hr={ "heroism", 1, nil, nil},
			hl={ "healing_light", 10, nil, nil},
			ag={ "aura_of_glory", 10, nil, nil},
			boj={ "brand_of_judgement", 20, nil, 5, "palboj"},
			hs={ "holy_sword", 20, "All", nil},
			cs={ "cleansing_spirit", 20, nil, nil},
			db={ "divine_bolt", 30, nil, nil},
			ns={ "noble_shield", 30, nil, nil},
			sw={ "shield_of_warding", 30, nil, 8, "palsw"},
			sb={ "sunburst", 40, nil, nil},
			al={ "aura_of_life", 40, nil, 7, "palal"},
		}			

meleePowers["Blk"] = 
		{ fa={ "furious_assault", 1, nil, nil},
		
			bc={"baleful_challenge", 45, nil, 12, "blkbc" },
			sot={"soul_touch", 1, nil, 1, "blksot"},
			drs={"dread_smite", 1, "All", 2, "blkdrs"},
			
			ps={"plundering_smite", 1, "Shield", 14, "blkps"},
			ds={"dominating_smite", 5, "Shield", 3, "blkds"},
			dm={"dark_majesty", 15, "Shield", 9, "blkdm"},
			rs={"ruinous_smite", 25, "Shield", 10, "blkrs"},
			fs={"frenzying_smite", 30, "Shield", 15, "blkfs"},
			
			vs={"vengeance_strike", 1, "TwoHand", 14, "blkvs"},
			ss={"shattering_smite", 5, "TwoHand", 3, "blkss"},
			md={"mortal_dread", 15, "TwoHand", 9, "blkmd"},
			sph={"spirit_harrow", 25, "TwoHand", 10, "blksph"},
			uf={"uncontrolled_fury", 30, "TwoHand", 15, "blkuf"},

			-- spells : fullname, level, weapontype, buttonnumber, chardata

			ua={"umbral_armor", 1, nil, nil},
			db={"dark_blessing", 1, nil, nil},
			sh={"shadow_healing", 10, nil, nil},
			aod={"aspect_of_domination", 10, nil, nil},
			sp={"sigil_of_pain", 20, nil, 5, "blksp"},
			cw={"corrupt_weapon", 20, "All", nil},
			cs={"consumption", 20, nil, nil},
			soa={"scourge_of_agony", 30, nil, nil},
			dg={"dark_grace", 30, nil, nil},
			sos={"shroud_of_shadow", 30, nil, 8, "blksos"},
			rav={"ravenous_shadows", 40, nil, nil},
			ad={"aura_of_death", 40, nil, 7, "blkad"}
		}

function PopulateButtonCooldown(fname, xvalue)
	local label=findlabel(fname)

	local color=charData:get("numcolor")

	-- if buff then use numcolor
	-- if in cooldown use numcolcool

	if timer:get(fname) and not buff:get(fname) then
		color=charData:get("numcolcool")
	else
		-- if buff for button is currently up, use buff timer value, not cooldown
		local buffVal= buff:get(fname)
		
		if buffVal then
			xvalue=buffVal
		end
	end

	-- Make sure button is still active
	if label ~= nil then
		if xvalue  &gt; 0 then
			-- label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. charData:get("numcolor", true) .. [["&gt;]] .. timedisplay(xvalue) .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])		
			label:echo([[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="]] .. color .. [["&gt;]] .. xvalue .. [[&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])		
		else
			label:echo([[&lt;p style="font-size:14px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="white"&gt;   &lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
		end
	end
end

function meleePowers:use(xalias)
	local charDataName = string.lower(whoclass() .. xalias)
	local fullName = meleePowers:getName(xalias:lower())

	if xalias == "fa" then
		fullName = "furious_assault"
	end

	if fullName == nil then
		cecho("&lt;red&gt;[Error: meleePowers:use : fullName nil for xalias " .. tostring(xalias) .. "]\n")
		return(false)
	end

	if charData:get(charDataName) then
			if timer:get(fullName) == nil and not timer:get("cooldown") then
				useMeleePower(xalias)

				-- furious assault doesn't return a failed message on usage
				if xalias == "fa" or xalias == "FA" then
					setMeleeCooldown()
				end

				return(true)
			end
	end

	return(false)
end


function meleePowers:addButtons()
	if meleePowers[whoclass()] ~= nil then
		local weapon=equip:getWeapon()
		local nx
		
		for k,v in pairs(meleePowers[whoclass()]) do
			local fullName=v[1]
			local buttonNumber=v[4]
			local minLevel=v[2]
			local weaponType=v[3]	
			
			if weaponType == weapon or weaponType == nil or weaponType == "All" then
				if buttonNumber ~= nil then
					addbutton(fullName, 0, buttonNumber, minLevel)
				end
			end
		end
	end
end

function meleePowersUpdate(fname, xcommand)
	-- if xcommand &gt; 0, function being called re: timer
	local charDataEntry = meleePowers:getCharData(fname)
	
	
	if xcommand &gt;= 0 then
		PopulateButtonCooldown(fname, xcommand)
	end
	
	if xcommand == buttons.INIT then
		if charData:get(charDataEntry) then
			setLabelImage(fname, fname .. "-on.png")
		else
			setLabelImage(fname, fname .. "-off.png")
		end
		return
	end

	if xcommand == buttons.CLICK then
		shiftSkillButton(fname, charDataEntry, xcommand)
	end
end

-- alias to full name
function meleePowers:getName(xstring)
	if meleePowers[whoclass()] ~= nil then
			if meleePowers[whoclass()][xstring] ~= nil then
				return( meleePowers[whoclass()][xstring][1] )
			end
	end

	return(nil)
end

function meleePowers:getCharData(xstring)
	if meleePowers[whoclass()] ~= nil then
		for k,v in pairs(meleePowers[whoclass()]) do
			local fullName=v[1]
			local buttonNumber=v[4]
			local minLevel=v[2]
			local weaponType=v[3]	
			local charDataEntry=v[5]
			
			if v[1] == xstring then
				return(v[5])
			end
		end
	end
	
	return(nil)
end


function setMeleeCooldown()
	timer:set("cooldown", 4)
end

-- useMeleePower: xpower, noCooldown
-- xpower is power name
-- if noCooldown is true none is used (warrior special skills)

function useMeleePower(xpower, noCooldown)
	
	xpower = string.lower(xpower)
	
	-- melee powers don't work on parad mobs
	--if prompt:get("tank") == "" then
	--	return
	--end

	-- cecho("\n&lt;red&gt;[useMeleePower(xpower): " .. xpower .. " meleePowerUsed: " .. tostring(meleePowerUsed) .. "\n")

	if meleePowerUsed then
		return
	end
	
	-- all melee powers have a 1 second cooldown unless noCooldown is set
	if not noCooldown then
		if timer:get("cooldown") then
			return
		end
		
		meleePowerUsed=true

		setMeleeCooldown()
	end
	
	local powername = string.split( string.lower(xpower), " ")[1]

	local fullName = meleePowers[whoclass()][powername][1]

	if not noCooldown then
		cecho("&lt;red&gt;\n\n[&lt;cyan&gt;MELEE: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() )
	
		if not charData:get("condensed", true)["echosend"] and not charData:get("condensed", true)["debug"] then
			echo("\n")
		end
	else
		cecho("&lt;red&gt;\n\n[&lt;cyan&gt;WARRIOR SKILL: &lt;red&gt;" .. to_english(fullName) .. "] " .. "&lt;yellow&gt;" .. xpower:upper() )
	
		if not charData:get("condensed", true)["echosend"] and not charData:get("condensed", true)["debug"] then
			echo("\n")
		end
	end

	timer:set(fullName, 8)

	mud:send( xpower:upper() )

	return(true)
end

-- call class specific procPrompt function on cooldown expiry if one exists and not casting
function cooldown(fname, xcommand)
	if xcommand &gt; buttons.TIMEREXPIRE then
		return
	end

	--cecho("&lt;green&gt;[meleePowerUsed = false]\n")
	--meleePowerUsed=false
	
	--if whoclass() ~= nil and not spell:getCurrent() and spell:castOK() and inCombat() then
	--	local cname="procPrompt" .. whoclass()

	--	if _G[cname] ~= nil then
	--		_G[cname]()
	--	end
	--end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GagScript</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function isGagged(xline)
	local gag = charData:get("gags", true)

	if gag ~= nil and xline ~= nil then
		for key,val in pairs(gag) do
			if string.find(xline:lower(), val, 1, true) then
				return(true)
			end
		end
	end
	
	return(false)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>TextScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- return the current line in a table with hex encoded colours (in decimal)

-- formating: string, fg table {position, colour}

hextable = hextable or 
	 {
	textLine = nil,
	colourTable = {}
		}

function nilFunction()
	return
end



-- colourString
-- this function should colour a string as it appeared in current line then return a hex encoded string or table? 

function getColourString(xstring)
	local table=getColourLine()
	local pos=string.find(table.textLine, xstring, 1, true) -- string.find is base 1

	local cr=0
	local cg=0
	local cb=0

	local retstring = ""
	
	if table==nil then
		return(false)
	end
	
	if pos==nil then
		return(false)
	end
	
	for nx=pos, pos+#xstring-1, 1 do
		if table.colourTable[nx][1] ~= cr or table.colourTable[nx][2] ~= cg or table.colourTable[nx][3] ~= cb then
			cr= table.colourTable[nx][1]
			cg= table.colourTable[nx][2]
			cb= table.colourTable[nx][3]

			retstring = retstring .. string.format("|c%02x%02x%02x", cr, cg, cb)
		end
	
		retstring = retstring .. string.sub(table.textLine, nx, nx)
	end

	return(retstring)
end


function getColourLine()
	local nx

	local r,g,b
	local lineCapture = {}
	
	local currentLine

	-- selectSection(from, how long) 0 based (0,1) = first character of line

	moveCursorEnd("main")
	hextable.textLine = getLines(getLineCount(), getLineCount()-1)[1]

	hextable.colourTable = {}

	for nx=0, #hextable.textLine-1, 1 do
		selectSection(nx, 1) -- selectSection is base 0
	
		r,g,b = getFgColor()
	
		hextable.colourTable[nx+1] = { r, g, b }
	end

	return(hextable)
end

function tableToHexColour(xtable)
	local retstring = ""
	
	local cr=0
	local cg=0
	local cb=0
	
	for nx=1,#xtable.textLine, 1 do
		if xtable.colourTable[nx][1] ~= cr or xtable.colourTable[nx][2] ~= cg or xtable.colourTable[nx][3] ~= cb then
			cr= xtable.colourTable[nx][1]
			cg= xtable.colourTable[nx][2]
			cb= xtable.colourTable[nx][3]

			retstring = retstring .. string.format("|c%02x%02x%02x", cr, cg, cb)
		end
	
		retstring = retstring .. string.sub(xtable.textLine, nx, nx)
	end

	--display(xtable)

	return(retstring)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>BackupScripts</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function copyFile(ifile, ofile)
	local inp = assert(io.open(ifile, "rb"))
   local out = assert(io.open(ofile, "wb"))
    
   local data = inp:read("*all")
   out:write(data)
    
   assert(out:close())
	assert(inp:close())
end

function backupFile(filename)
	local is_file = io.open(homepath(filename))

	if is_file ~= nil then
		copyFile(homepath(filename), backupPath(filename))
		cecho("&lt;red&gt;[File: " .. homepath(filename) .. " copied to \n          " .. backupPath(filename) .. "]\n")
		io.close(is_file)
	else
		cecho("&lt;red&gt;[File: " .. homepath(filename) .. " does not exist]\n")
	end
end

function restoreFile(filename)
	local srcfile = backupPath(filename)

	local is_file = io.open(srcfile)

	if is_file ~= nil then
		copyFile(srcfile, homepath(filename))
		cecho("&lt;red&gt;[File: " .. srcfile .. " copied to \n          " .. homepath(filename) .. "]\n")
		io.close(is_file)
	else
		cecho("&lt;red&gt;[File: " .. srcfile .. " does not exist]\n")
	end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Bash</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- this script has all the bash functions

function setBashing(xval)
	if xval ~= vbashing then
		echoDebug("&lt;red&gt;[setBashing : " .. tostring(xval) .. "]\n")
		vbashing = xval
	end
end

function getBashing()
	if vbashing == nil then
		vbashing=false
	end

	return(vbashing)
end

function canBash()
	-- Does the character have the bash button specific to their class/weapon enabled?
	-- "Bow", "TwoHand", "Shield", "Dual", "None"
	
	local weapon=equip:getWeapon()
	
	if charData:get("blkss") and weapon == "TwoHand" then return(true) end
	if charData:get("blkds") and weapon == "Shield" then return(true) end

	if charData:get("palts") and weapon == "TwoHand" then return(true) end
	if charData:get("palrc") and weapon == "Shield" then return(true) end

	if charData:get("ranks") and weapon == "Bow" then return(true) end
	if charData:get("ranss") and weapon == "Dual" then return(true) end

	if charData:get("warss") and weapon == "TwoHand" then return(true) end
	if charData:get("warsb") and weapon == "Shield" then return(true) end

	if charData:get("dirbh") then return(true) end
	
	return(false)
end

function sendBash(xtarget)
	if xtarget == nil then
		xtarget = ""
	else
		xtarget = " " .. xtarget
	end
		
	-- can't bash if stunned

	if buff:get("stun") then
		return(false)
	end

	if not getBashing() then

		-- mounted charge instead of bash when mounted
		if mount:getMounted() then
			if not mount:charge() then
				return(false)
			end
		else
			if dismounted == true then
				return(false)
			end

			if checkMask("war") then
				if not timer:get("cooldown") then
					-- use powers attack depending on wielded weapon

					if isIconActive("shield_bash") then
						if not timer:get("shield_bash") then
							useMeleePower("SB" .. xtarget)
							setBashing(true)
							return(true)
						else
							return(false)
						end
					end
				
					if isIconActive("spinning_sweep") then
						useMeleePower("SS" .. xtarget)
						setBashing(true)
					end
				else
					return
				end
			end


			if checkMask("blk") then
				if not timer:get("cooldown") then
					-- use powers attack depending on wielded weapon

					if isIconActive("dominating_smite") then
						if not timer:get("dominating_smite") then
							useMeleePower("DS" .. xtarget)
							setBashing(true)
							return
						else
							return
						end
					end
				
					if isIconActive("shattering_smite") then
						useMeleePower("SS" .. xtarget)
						setBashing(true)
					end
				else
					return
				end
			end

			if checkMask("pal") then
				if charData:get("palrc") then
					if timer:get("radiant_charge") == nil and not timer:get("cooldown") and isIconActive("bolstering_strike") then
						useMeleePower("rc")
						setBashing(true)
						return
					end
				end
								
				if isIconActive("valiant_strike") then
					if charData:get("palts") then
						if timer:get("thunderous_smite") == nil and not timer:get("cooldown") then
							useMeleePower("ts")
							setBashing(true)
							return
						end
					end
				end
			end

			if checkMask("ran") then
				if not timer:get("cooldown") then
					-- use powers attack depending on wielded weapon

					if isIconActive("sweeping_strike") then
						if not timer:get("sweeping_strike") then
							useMeleePower("SS" .. xtarget)
							return
						else
							return
						end
					end
				
					if isIconActive("knockdown_shot") then
						useMeleePower("KS" .. xtarget)
					end
				else
					return
				end
			end
		end
	end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GUIMiniMap</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
miniMap = miniMap or {}
miniMap.oldCount = miniMap.oldCount or 0

-- Update the room window from the buffer

function miniMap:update()
	clearWindow("miniMap")
		
	copyBuffer("minimapBuffer", "miniMap")
	clearWindow("minimapBuffer")
end

function miniMap:test()
	minimapLabel:setClickCallback("testfunction", "zzz", buttons.CLICK)
end

function testfunction()
	display("click")
end


-- resize the minimap font

function miniMap:resizeFont()
	local WindowWidth, WindowHeight = getMainWindowSize()
	local fontsize= maxfont(33, math.floor(.9 * .2 * WindowWidth) )	
	
	if self:exists() then
		minimapLabel:setFontSize(fontsize)
		self.windowid:setFontSize(fontsize)
	end
end

-- Create the minimap window

function miniMap:create()
	local WindowWidth, WindowHeight = getMainWindowSize()
	local fontsize= maxfont(33, math.floor(.9 * .2 * WindowWidth) )	
	
	if not self:exists() then
			-- NyyLIB.mapwindow = Geyser.Mapper:new({name="mapper",x="66%",y=0,width="33%",height="50%"})

			--NyyLIB.mapwindow:move("46%", nil)
			--NyyLIB.mapwindow:resize("20%", "33%")

		  --minimapLabel = Geyser.Label:new({name="miniMapLabel", x="44%", y=0, width=250, height="13c",}) -- -92c, -80c
			minimapLabel = Geyser.Label:new({name="miniMapLabel", x="46%", y=0, width="20%", height="33%",}) -- -92c, -80c
			minimapLabel:setStyleSheet([[border-image: url(]] .. mainpath("roomborder.png") .. [[)]])
			minimapLabel:setFontSize(fontsize)

			self.windowid = Geyser.MiniConsole:new({name="miniMap", x="5%", y="5%", width="90%", height="90%",}, minimapLabel) -- -92c, -80c
	end
	
	self.windowid:setFontSize(fontsize)

	if charData:get("minimap") == false then
		--self.windowid:hide()
		minimapLabel:hide()
	end
end

-- Toggle the minimap window on/off

function miniMap:toggle()
	if charData:get("minimap") then
		charData:set("minimap", false)
		cecho("&lt;red&gt;[Minimap display is OFF.]\n")
		minimapLabel:hide()
		self.windowid:hide()
	else
		charData:set("minimap", true)
		cecho("&lt;red&gt;[Minimap display is ON.]\n")
		minimapLabel:show()
		self.windowid:show()
	end
end

-- Return true if the room window has been created

function miniMap:exists()
	if self.windowid ~= nil then
		return(true)
	else
		return(false)
	end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Events</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>promptEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- This event will be called whenever the mud prompt has been received

mobs = mobs or {}

function promptEvent(event)
	-- testing: hp gauge

	--if not hpBar then
	--	hpBar = Geyser.Gauge:new({  name="hpBar", x="54%", y="50%", width="10%", height="20px",})

	--	hpBar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #98f041, stop: 0.1 #8cf029, stop: 0.49 #66cc00, stop: 0.5 #52a300, stop: 1 #66cc00);
  -- 	border-top: 1px black solid;
  --  	border-left: 1px black solid;
  --  	border-bottom: 1px black solid;
  --  	border-radius: 7;
  --    font-size:18px;
  --  	padding: 3px;
	--	]])

	--	hpBar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #cc3300, stop: 0.1 #cc6600, stop: 0.49 #ff0000, stop: 0.5 #993300, stop: 1 #993300);
  --  	border-width: 1px;
  --		border-color: black;
  --  	border-style: solid;
  --  	border-radius: 7;
  --    font-size:18px;
  --  	padding: 3px;
	--	]])
	--end

	--if hpBar then
	--	hpBar:setValue( prompt:get("hp"), prompt:get("maxhp") )
	--end
	
	-- if no-one is known tanking, and the prompt shows combat look at the room

	if groupList:whoTanking() == false and prompt:get("tank") ~= "" then
		groupList:incTanking(prompt:get("tank"))
		look:send()
	end

	-- send all queued commands if not casting or in fugue 

	if 	spell:getCurrent() == nil or map:getRoom() == 93848 then
		mud:sendCommands() 
	end

	-- if in fugue remove buffs on self, return

	if map:getRoom() == 93848 then
		buff:del(whoami())
		return
	end

	-- nyylib.torescue should only be set after looking at room
	if NyyLIB.torescue ~= "" then
		pet:rescue(NyyLIB.torescue)
		NyyLIB.torescue=""
	end

	if inCombat() then
		assistSent = nil

		-- can't be hidden if in combat
		setHide(false)

		-- send con to update database if needed
		local roomid = map:getRoom()

		if roomid ~= nil then
			if mobs[roomid] == nil then
				sendCon(prompt:get("enemy"))
			end
		end

		-- if tank=me, slaad, ghost, wraith, wight order rescue
		if not petcommand then
			local tank=prompt:get("tank")
			if not (#pet:getTable() == 1) then
				if table.contains( {whoami(), "gray", "ghost", "wraith", "wight", "ghoul" }, tank ) then
					pet:rescue( tank )
					petcommand=true
				end
			end
		end
	end

	-- If engaged in combat AND a look command was not sent/unreceived, set not moving
	
	if inCombat() or type(groupList:whoTanking()) == "table" and not look:get() then
		automem=0

		if spell:getMoving() then
			echoDebug("&lt;red&gt;[Currently in combat]\n")
		end

		spell:setMem(false)
		spell:setMoving(false)
	end

	-- Disengage from nightmares (tiamat zone only)
	if prompt:get("enemy") == "nightmare" then
		if map:getCurrentZone() == "Tiamat - The Pillar of Skulls" then
			if prompt:get("position") ~= "std" then
				mud:send("STAND")
			end

			mud:send("disengage")
			return
		end
	end

	-- No further processing if currently moving
	if spell:getMoving() then
		return
	end

	-- send furious assault
	if whorace() == "Half-Orc" then
			if whoclass() ~= nil and not spell:getCurrent() and spell:castOK() and inCombat() then
			if meleePowers:use("fa") then
				timer:set("furious_assault", 90)
			 	meleePowerUsed=false
				return
			end
		end
	end


	-- call class specific prompt script if one exists and not currently casting, must be in combat

	if whoclass() ~= nil and not spell:getCurrent() and spell:castOK() and inCombat() then
		local cname="procPrompt" .. whoclass()

		-- display(cname)

		if _G[cname] ~= nil then
			_G[cname]()
		end
	end

	-- proc equipment if needed 
	procEquipment()

	-- Call class self heal function if not casting and it exists
	if whoclass() ~= nil and not spell:getCurrent() then
		local cname="proc" .. whoclass() .. "Heal"

		if _G[cname] ~= nil then
			_G[cname]()
		end
	end

	-- Process cast/send queue 

	spell:cast()

	-- undead pet casting (shadow/wraith/ghost)
	-- don't order to cast if i'm bashed (sit/rcl)

	if charData:get("autocast") and not nomagic then
		if checkMask("necros") then
			if not (inCombat() and (prompt:get("position") == "rcl" or prompt:get("position") == "sit")) then
				undeadPetCast()
			end
		end
	end

	-- don't cast if trying to mem or look sent/not received or nomagic is set
	if spell:getMem() or memsent or look:get() or nomagic then
		return
	end

	-- call class specific spell script if autocast enabled and no spell currently being cast, standing, not stunned

	if charData:get("autocast") and not spell:getCurrent() and not buff:get("stun") then
		if prompt:get("position") == "std" then
			local cname="Spells" .. whoclass()

			if _G[cname] ~= nil then
				_G[cname]()
			end
		end
	end
	-- automem segment

	memsent = memsent or false

	if automem &gt; 1 and not roomCombat then
		if spell:count() ~= 0 or spell:getCurrent() ~= nil then
			return
		end
		if checkMask("casterPsi") or checkMask("nonPriestCaster") then
			if charData:get("autocast") then
				if charData:get("memcount") ~= 0 and not spell:getMem() and spell:getCurrent() == nil and not memsent and prompt:get("position") ~= "sit" then
					if not inCombat() then
						echoDebug("&lt;red&gt;[Initiating automem]\n")
						mud:send("mem")
						memsent = true
					end
				end
			end
		end
	end
end

function procRanHeal()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp

	-- exit if not in combat (no tank in prompt), or map has current room as fugue
	-- this should prevent (some) proc commands from being issued in fugue

	if prompt:get("tank") == "" or map:getRoom() == 93848 then
		return
	end

	-- ranger heal procs are used if auto_heal is enabled
	if charData:get("auto_heal") then
		-- cast cloak of life (cll) on &lt; 50% hp if not already

		if not buff:get("cloak_of_life") and spell:getSlot(5) &gt; 0 then
			if percent &lt; .50 and prompt:get("position") == "std" then
				spell:cast("CLL")
			end
		end

		-- cast dawns renewl (dr) on &lt; 70% hp

		if spell:getSlot(2) &gt; 0 then
			if percent &lt; .70 and prompt:get("position") == "std" then
				spell:cast("DR")
			end
		end
	end
end

function procBlkHeal()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp

	-- exit if not in combat (no tank in prompt), or map has current room as fugue
	-- this should prevent (some) proc commands from being issued in fugue

	if prompt:get("tank") == "" or map:getRoom() == 93848 then
		return
	end

	-- blackguard heal procs are used if blksot is enabled
	if charData:get("blksot") then
			
			-- soul touch on &lt; 30% hp
			if percent &lt; .3 then
				if timer:get("soul_touch") == nil and not timer:get("cooldown") then
					useMeleePower("SOT")
					return
				end
			end

		-- cast aura of death (al) on &lt; 50% hp if not already

		if not buff:get("aura_of_death") and spell:getSlot(5) &gt; 0 then
			if percent &lt; .50 and prompt:get("position") == "std" then
				spell:cast("AD")
			end
		end

		-- cast shadow healing (sh) on &lt; 70% hp

		if spell:getSlot(2) &gt; 0 then
			if percent &lt; .70 and prompt:get("position") == "std" then
				if (maxhp - hp) &gt; 125 then
					spell:cast("SH")
				end
			end
		end
	end
end


function procPalHeal()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp

	-- exit if not in combat (no tank in prompt), or map has current room as fugue
	-- this should prevent (some) proc commands from being issued in fugue

	if prompt:get("tank") == "" or map:getRoom() == 93848 then
		return
	end

	-- paladin heal procs are used if pallh is enabled
	if charData:get("pallh") then
			
			-- lay hands on &lt; 30% hp
			if percent &lt; .3 then
				if timer:get("lay_on_hands") == nil and not timer:get("cooldown") then
					useMeleePower("lh")
					return
				end
			end

		-- cast aura of life (al) on &lt; 50% hp if not already

		if not buff:get("aura_of_life") and spell:getSlot(5) &gt; 0 then
			if percent &lt; .50 and prompt:get("position") == "std" then
				spell:cast("AL")
			end
		end

		-- cast healing light (hl) on &lt; 70% hp

		if spell:getSlot(2) &gt; 0 then
			if percent &lt; .70 and prompt:get("position") == "std" then
				spell:cast("HL")
			end
		end
	end
end


function procEquipment()
	local hp=prompt:get("hp")
	local maxhp=prompt:get("maxhp")
	local percent=hp/maxhp

	-- exit if not in combat (no tank in prompt), or map has current room as fugue
	-- this should prevent (some) proc commands from being issued in fugue

	if prompt:get("tank") == "" or map:getRoom() == 93848 then
		return
	end

	-- proc manacle on &lt; 70% hp if not already blurred

	if not buff:get("blur") then
		if percent &lt; .70 then
			if isIconActive("TiaManacle") and timer:get("TiaManacle") == nil then
				TiaManacle("TiaManacle", buttons.CLICK)
			end
		end
	end

	-- proc volance on &lt; 60% hp

	if percent &lt; .60 then
		if isIconActive("TiaVolance") and timer:get("TiaVolance") == nil then
			TiaVolance("TiaVolance", buttons.CLICK)
		end
	end

	-- proc warder on &lt; 30% hp

	if percent &lt; .30 then
		if isIconActive("TiaWarder") and timer:get("TiaWarder") == nil then
			TiaWarder("TiaWarder", buttons.CLICK)
		end
	end

	-- proc items on &lt; 25% hp

	if percent &lt; .25 then
		-- proc supple girdle
		if isIconActive("SuppleGirdle") and not mount:getMounted() and timer:get("SuppleGirdle") == nil then
			SuppleGirdle("SuppleGirdle", buttons.CLICK)
			return
		end

		--if checkMask("anti") then
		--	if not timer:get("lifetap") then
		--		mud:send("lifetap")
		--		timer:set("lifetap", 24*60)
		--	end
		--end

		-- proc tiamat sleeves
		if isIconActive("TiaSleeves") and timer:get("TiaSleeves") == nil then
			TiaSleeves("TiaSleeves", buttons.CLICK)
		end
	end
end
</script>
					<eventHandlerList>
						<string>promptEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>statusEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function statusEvent(event, xcharname)

end</script>
					<eventHandlerList>
						<string>statusEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sysManualLocationSetEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function sysManualLocationSetEvent(xtmp)
	--display("X")
end</script>
					<eventHandlerList>
						<string>sysManualLocationSetEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>installEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
-- sysInstallPackage

-- this function will be called with mudlet 3.1+ on package installation

function installEvent()
	cecho("&lt;red&gt;[\n[New package install event called]\n")

	-- mudlet 3.1+ in use, restart not required
	disableAlias("restart")

	initNyyLIB()
end</script>
					<eventHandlerList>
						<string>sysInstall</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>newRoomEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function newRoomEvent(event, xroom)
	-- this event is called from map:update after every new room is entered

	--Example: snap after entering a particular room
	--if xroom == 79574 then
	--	send("snap")
	--end

	alreadyEnteredPortal=nil

	if xroom ~= nil then
		spell:setMoving(true)
		spell:setMem(false)
		memsent = false

		meleePowerUsed=false

		-- pet command couldn't have been sent
		petcommand = nil

		-- nomagic is a variable to stop casting (beholder, etc)
		nomagic=nil

	end

	spell:setCast() -- reset

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>onNetworkOutput</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

-- This event is called immediatly prior to sending anything to the mud


function onNetworkOutput(__, xcommand)
	if commandSent ~= nil then
		command2 = commandSent
	end
	
	commandSent=xcommand
	
	-- afk flag at 6min, timeout at 10min
	timer:set("timeout", 9.5*60)
	
	-- Screen echo of sent command (for debugging purposes)
	if charData:get("condensed", true)["echosend"] or charData:get("condensed", true)["debug"] then
		if getCmdLine() == "" then
			cecho("\n")
		end
		
		cecho("&lt;yellow&gt;[onNetworkOutput: " .. tostring(xcommand) .. "]\n")
	end
end</script>
					<eventHandlerList>
						<string>sysDataSendRequest</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>initNyyLIB</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

NyyLIB = NyyLIB or {}

automem = automem or 0
	
function initNyyLIB()

	echo("\n\n\n")

	cecho([[&lt;green&gt;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO]])
	cecho("&lt;green&gt;THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE")
	cecho("&lt;green&gt;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,")
	cecho("&lt;green&gt;TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN")
	cecho("&lt;green&gt;THE SOFTWARE.")

	echo("\n\n\n")

	cecho("&lt;red&gt;[Initializing NyyLIB...]\n")

	-- disable autoroller if active
	disableTrigger("RollerTrigger")

	expandAlias("@version", false)

	NyyLIB.homedir = getMudletHomeDir() .. "\\" .. NyyLIB.version .. "\\"


	-- copy fontfile
	-- The new fontfile doesn't work until mudlet has been restarted
	
	local srcPath=mainpath("AvQest.ttf")
	local dstPath= getMudletHomeDir() .. "\\..\\..\\fonts\\AvQest.ttf"

	--display( srcPath )
	--display( dstPath )

	local is_file = io.open( dstPath )
	--display( is_file )

	if not is_file then
		copyFile(srcPath, dstPath)
	end

	--local is_file = io.open( dstPath )
	--display( is_file )

	buttons:init()

	-- create buffers
	minimapBuffer = createBuffer("minimapBuffer")

	local WindowWidth, WindowHeight = getMainWindowSize()

	splashwindow = Geyser.Label:new({name="splash", x="10%", y="10%", width="50%", height="75%"})
	splashwindow:setStyleSheet([[border-image: url(]] .. mainpath("splash.png") .. [[)]])
	tempTimer(6, [[splashwindow:hide()]] )

	NyyLIB.areaTable = {}

	-- load list of all area names on the mud
	for line in io.lines(mainpath("arealist.txt")) do
		local areainfo = string.split(line, "   ")

		local areaid = areainfo[1]:trim()
		local areaname = areainfo[2]

		NyyLIB.areaTable[tonumber(areaid)] = areaname
	end

	-- loading charData table
	charData:load()

	NyyLIB.leftbuttonarray = {}

	NyyLIB.deadpeople = NyyLIB.deadpeople or {}

	NyyLIB.initgui = false
	NyyLIB.ticktimer = 60

	if charData:get("style", true) then
		setStyle()
	end

	NyyLIB.classes = { "War", "UNK", "Blk", "Pal", "Cle", "Dru", "Sha", "Ctr", 
 	 "Bar", "Enc", "Psi", "Inv", "Lic", "Ill", "Ele", "Nec", "Rog", "Dir", "Ran" }

	NyyLIB.fullclasslist = { {"Rogue", "Rog"},
								{"Cleric", "Cle"},
								{"Paladin", "Pal"},
								{"Shaman", "Sha"},
								{"Illusionist", "Ill"},
								{"Ranger", "Ran"},
								{"Lich", "Lic"},
								{"Blackguard", "Blk"},
								{"Necromancer", "Nec"},
								{"Battlechanter", "Ctr"},
								{"Invoker", "Inv"},
								{"Enchanter", "Enc"},
								{"Druid", "Dru"},
								{"Warrior", "War"},
								{"Elementalist", "Ele"},
								{"Dire Raider", "Dir"},
								{"Bard", "Bar"},
								{"Psionicist", "Psi"}
							}

	NyyLIB.fullracelist = { {"Human", "M"},
									{"Barbarian", "M"},
									{"Drow Elf", "M"},
									{"Moon Elf", "M"},
									{"Half-Elf", "M"},
									{"Shield Dwarf", "M"},
									{"Half-Orc", "M"},
									{"Duergar", "M"},
									{"Duergar Dwarf", "M"},
									{"Gnome", "S"},
									{"Halfling", "S"},
									{"Ogre", "L"},
									{"Troll", "M"},
									{"Illithid", "M"},
									{"Orc", "M"},
									{"Yuan-Ti", "M"}
								}

	NyyLIB.reversedirs   =   {
                     n   = "s",
                     e   = "w",
                     s   = "n",
                     w   = "e",
                     u   = "d",
                     d   = "u",
						  north = "south",
						  east = "west",
						  south = "north",
						  west = "east",
						  up = "down",
						  down = "up"
                     }

	NyyLIB.fulldirs = {
									n = "north",
									e = "east",
									s = "south",
									w = "west",
									u = "up",
									d = "down"
								}


	NyyLIB.statuschar=""


	NyyLIB.damagelevels = { "Excellent", "Few Scratches", "Small Wounds", "Few Wounds", "nasty wounds", "Pretty Hurt", "Awful" }

	NyyLIB.torescue=""

	NyyLIB.psilag="none"

	loadwholist()

	opendb()

	createconsumabledb()
	
	demonnicOnStart()

	setBorder()

	-- enable mapper

	mudlet = mudlet or {}; mudlet.mapper_script = true
	expandAlias("@map init", false)

	-- only load mapfile if loaded map is &lt; 35000 rooms i.e. not mudlet loaded mapfile

	if map:countRooms() &lt; 35000 then
		map:loadMap()
	end

	NyyLIB.initcompleted = true

	registerAnonymousEventHandler("sysWindowResizeEvent", "GUIScripts")
	registerAnonymousEventHandler("newRoomEvent", "newRoomEvent")

	expandAlias("@stats reset", false)

	cecho ("&lt;red&gt;[NyyLIB initialized.]\n")
	echo("Account name: ")
end

function initFullData()
	echoDebug("&lt;red&gt;[initFullData called]\n")

	disableTrigger("scribenext")
	
	charData:init(whoami(), {}, true)

	charData:init("memcount", 0)
	charData:init("groupwindow", "split")
	charData:init("iconbar", "bottom")

	charData:init("statname", "unset")

	if NyyLIB.initgui == false then
		if NyyLIB.mapwindow == nil then
			cecho("&lt;red&gt;[error: mapwindow is nil]\n")
		else
			map:hide()
		end

		if whoami() == nil then
			cecho("&lt;red&gt;[error: whoami() is nil]\n")
		end

		if whoclass(whoami()) == nil then
			cecho("&lt;red&gt;[error: whoclass(whoami) is nil]\n")
		end

		initgui()

		-- call class initialization script (buttons)

		initClass()

		-- call custom initaliziation script 'initCustom()' if it exists

		if _G["initCustom"] ~= nil then
			_G["initCustom"]()
		else
			echoDebug("\n&lt;red&gt;[Custom script initCustom() does not exist]\n")
		end

		NyyLIB.initgui = true
	end
end

-- class initialization script (buttons)

function initClass()
	buttons:hide()
	
	baseButtons()
	
	local fnInit="init" .. whoclass()

	if _G[fnInit] ~= nil then
		_G[fnInit]()
	else
		echoDebug("\n&lt;red&gt;[Class script " .. fnInit .. " does not exist]\n")
	end
end</script>
					<eventHandlerList>
						<string>sysLoadEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>saveNyyLIB</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function saveNyyLIB()
	local ver=getMudletVersion()

	if ver["major"] == 3 then
		if ver["build"] == "" or ver["build"] == "-dev" then
			disableAlias("restart")
		end
	end

	charData:save()

	-- save to map folder
	saveMap( "" )

	expandAlias("@map save", false)

	savewholist()
end</script>
					<eventHandlerList>
						<string>sysExitEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>sysWindowMouseMoveEvent</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

function sysWindowMouseMoveEvent(var)
	display(var)
end</script>
					<eventHandlerList>
						<string>sysWindowMouseMoveEvent</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Utilities</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>cMud Map Importer</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>CreateMapFromCmud</name>
						<packageName></packageName>
						<script> -------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
require "luasql.sqlite3"
cmi = {}
--kept as reminders
--[[dirnums = {[1]="north", [2]="northeast", [3]="northwest",[4]="east",
[5]="west",[6]="south",[7]="southeast",[8]="southwest",[9]="up",[10]="down"}
dir_list=["north","n","northeast","ne","east","e","se","southeast",
          "south","s","sw","southwest","west","w","nw","northwest",
          "up","u","down","d", "special", "special"]
dirtype_list=[0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9, 10, 10]]

cmi.cmudToMudletExit = {[0]=1,[1]=2,[2]=4,[3]=7,[4]=6,[5]=8, [6]=5, [7]=3, [8]=9, [9]=10}


function cmi:passwordLabel(xroomid, xpw)
 -- "10749 1 red black Northern Waterdeep Main City"

	local tmp=xroomid .. " 7 green black " .. xpw

	cmi:roomLabel(tmp)
end


-- room label the room I'm in
-- room label 342 this is a label in room 342
-- room label green this is a green label where I'm at
-- room label green black this is a green to black label where I'm at
-- room label 34 green black this is a green to black label at room 34
-- how it works: split input string into tokens by space, then determine
-- what to do by checking first few tokens, and finally call the local
-- function with the proper arguments
--taken from Vadi
--input is room number, fgcolor, bgcolor, message

function cmi:roomLabel(input)
  local tk = input:split(" ")
  local room, direction, fg, bg, message

  -- input always have to be something, so tk[1] at least always exists
  if tonumber(tk[1]) then
    room = tonumber(table.remove(tk, 1)) -- remove the number, so we're left with the direction, colors or msg
  end

  if tonumber(tk[1]) then
    direction = tonumber(table.remove(tk, 1)) -- remove the number, so we're left with the colors or msg
  end

  -- next: is this a foreground color?
  if tk[1] and color_table[tk[1]] then
    fg = table.remove(tk, 1)
  end

  -- next: is this a backround color?
  if tk[1] and color_table[tk[1]] then
    bg = table.remove(tk, 1)
  end

  -- the rest would be our message
  if tk[1] then
    message = table.concat(tk, " ")
  end

  -- if we haven't provided a room ID and we don't know where we are yet, we can't make a label
  if not room then
    echo("We don't know where we are to make a label here.") return
  end

  local x,y,z = getRoomCoordinates(room)
  local f1,f2,f3 = unpack(color_table[fg])
  local b1,b2,b3 = unpack(color_table[bg])

--  [1] = "north",
--  [2] = "northeast",
--  [3] = "northwest",
--  [4] = "east",
--  [5] = "west",
--  [6] = "south",
--  [7] = "southeast",
--  [8] = "southwest",
--  [9] = "up",
--  [10] = "down",
--  [11] = "in",
--  [12] = "out",

	local length = string.len(message)

	if direction == 1 then -- north
		y=y+1.5+1
		x=x-length/3.5
	end

	if direction == 4 then -- east
		y=y+.5
		x=x+.5+1
	end

	if direction == 5 then -- west
		y=y+.5
		x=x-(length/1.5)-.5-1
	end

	if direction == 6 then -- south
		y=y-.5-1
		x=x-length/3.5
	end

	if direction == 7 then -- se password
		x=x+.25
		y=y+.25
	end

  -- finally: do it :)
  if (z) then
  -- labelID = createMapLabel(areaID, text, posx, posy, posz, fgRed, fgGreen, fgBlue, bgRed, bgGreen, bgBlue, zoom, fontSize, showOnTop, noScaling)
  	local lid = createMapLabel(getRoomArea(room), message, x, y, z, f1,f2,f3, b1,b2,b3, 15, 15, false, false)
  --echo(string.format("Created new label #%d '%s' in %s.", lid, message, getRoomAreaName(getRoomArea(room))))
	end
end

function cmi:decimalToRGB(num)

		-- download luabit from http://files.luaforge.net/releases/bit/bit/luabitv0.4
		-- copy bit.lua to mudlet install directory

        -- require("bit")
        local r,g,b
        r = bit.band(num,0x0000ff)
        g = bit.band(num, 0x00ff00)
        g = bit.brshift(g,8)
        b = bit.band(num, 0xff0000)
        b = bit.brshift(b,16)
        return {['r']=r,['g']=g,['b']=b}
end



function cmi:colorRooms(con)
        local recs, row, roomID, colors, r,g, b, cTable
        local envsUsed = {}
        local envIndex = 500

		  echo("[Setting room colours]\n")

        recs = assert(con:execute([[SELECT ObjId, Color FROM ObjectTbl]]))
        row = recs:fetch({})
        while row do
                roomID = tonumber(row[1])
                colors = cmi:decimalToRGB(tonumber(row[2]))
                r = colors['r']
                b = colors['b']
                g = colors['g']
                if envsUsed[row[10]] then
                        cTable = envsUsed[row[2]]
                else
                        envsUsed[row[2]] = envIndex
                        cTable = envIndex
                        setCustomEnvColor(cTable, r,g,b,255)
                        envIndex=envIndex+1
                end
					
					if roomExists(roomID) then
	            		setRoomEnv(roomID, cTable)
						--echo("Setting room color for " .. roomID .. "\n")
					end
                row = recs:fetch({})
        end
        recs:close()

		echo("[Room colouring completed]\n")
end

function cmi:addRooms(con, xcmudid, xtorilid)
        local recs, row, roomID, roomname, roomdesc, x, y, z, cost, zone, script


		if xcmudid ~= nil then
      		recs = assert(con:execute([[SELECT ObjId, Name, Desc, X,Y,Z, Cost, ZoneID, Script FROM ObjectTbl where ZoneID=]] .. xcmudid))
		else
      		recs = assert(con:execute([[SELECT ObjId, Name, Desc, X,Y,Z, Cost, ZoneID, Script FROM ObjectTbl]]))
		end

		  -- recs = assert(con:execute([[SELECT ObjId, Name, Desc, X,Y,Z, Cost, ZoneID, Script FROM ObjectTbl]]))
        row = recs:fetch({})
        while row do
                roomID = tonumber(row[1])
                roomname = row[2]
                roomdesc = row[3]
                x = tonumber(row[4])
                y = tonumber(row[5])*-1 --need to reflect on y axis
                z = tonumber(row[6])

                x = math.floor(x/240) -- was 120
                y = math.floor(y/240) -- was 120

                cost = tonumber(row[7])
                zone = tonumber(row[8])
					--  zone=5
                script = row[9]
                if script then
                        script = string.gsub(script, "All[=]?", "", 1)
                end
                addRoom( roomID )
                if roomname then
                        setRoomName( roomID, roomname )
                else
                        echo("null roomname:"..roomID .. "\n")
                end
                if roomdesc then
                        setRoomUserData(roomID, "description", roomdesc)
                else
                        echo("null roomdesc:"..roomID .. "\n")
                end
                if script and script ~= "" then
                        setRoomUserData(roomID, "script", script)
                end
                setRoomCoordinates(roomID, x,y,z)
                setRoomWeight(roomID, cost)

					if cost == 2147483647 then
						-- do not enter room
						echo("[Set room " .. roomID .. " do not enter]\n")
						map:setDoNotEnter(roomID)
					end

                if zone == -1 or not zone then
                        zone = 0
                end

					if xtorilid ~= nil then
						setRoomUserData(roomID, "zoneid", xtorilid)
						resetRoomArea(roomID)	 -- set room area to -1
						lockRoom(roomID, true) -- lock room
                else
						setRoomUserData(roomID, "zoneid", zone)
						setRoomArea( roomID, zone )
					end

                row = recs:fetch({})
        end
		 -- centerview(roomID)
        recs:close()
end

function cmi:addAreas(con)
	local recs, row, zoneId, Name, row
	recs = assert(con:execute([[SELECT ZoneId, Name FROM ZoneTbl]]))
	row = recs:fetch({})
	while row do
		ZoneId = tonumber(row[1])
		Name = row[2]
			setAreaName(ZoneId, Name)
		row = recs:fetch({})
	end
	recs:close()
end

function cmi:listAreas()
	local recs, row, zoneId, Name, row

	cmi:checkConnection()
	echo("Selected map: " .. cmi.file .. "\n")

	recs = assert(cmi.con:execute([[SELECT ZoneId, Name FROM ZoneTbl]]))
	row = recs:fetch({})
	while row do
		ZoneId = tonumber(row[1])
		Name = row[2]

		echo("ID: " .. ZoneId .. " " .. Name .. "\n")

		row = recs:fetch({})
	end
	recs:close()
end


function cmi:addExits(con)
	local recs, row, FromID, ToID, dirtype, param, ExitKindID, name
	recs = assert(con:execute([[SELECT FromID, ToID, DirType, Param, ExitKindID, Name FROM ExitTbl]]))

-- NOTE - this adds all exits from mapfile, whether room has been added or not


--setDoor(roomID, exitCommand, doorStatus)
--Creates or deletes a door in a room. Doors are purely visual - they don't affect pathfinding. You can use the information to change to adjust your speedwalking path based on the door information in a room, though.

--roomID:
--Room ID to to create the door in.
--exitCommand:
--The cardinal direction for the door is in - it can be one of the following: e,s,w,n,ne,se,sw,ne. {Plans are afoot to add support for doors on the other normal exits: up,down,in,out and also on special exits though more work will be needed for them to be shown in the mapper.}
--doorStatus:
--The door status as a number - 0 means remove door, 1 means open door (will draw a green square on exit), 2 means closed door (yellow square) and 3 means locked door (red square).
--See also: getDoors()

-- make a door on the east exit of room 4234 that is currently open
--setDoor(4234, 'e', 1)
 
-- remove a door from room 923 that points north
--setDoor(923, 'n', 0)

	-- ExitKindID 0-normal exit 1-door 2-locked door


-- addSpecialExit(roomIDFrom, roomIDTo, command)
-- Creates a one-way from one room to another, that will use the given command for going through them.




	row = recs:fetch({})
	while row do
		FromID = tonumber(row[1])
		ToID = tonumber(row[2])
		dirtype = cmi.cmudToMudletExit[tonumber(row[3])]
		param = row[4]
		ExitKindID = row[5]
		name = row[6]

		-- if name has value then non-standard exit

		if roomExists(FromID) then
			if dirtype and dirtype ~= -1 then
				setExit(FromID, ToID, dirtype)
			else
				echo("dirtype failed room id " .. FromID .. "\n")
			end

			if name ~= "" and name ~= nil then
				addSpecialExit(FromID, ToID, name)
			end

			if param ~= "" and param ~= nil then
				map:setDoorName(FromID, dirtype, param)
			end

			if exitMap[dirtype] ~= nil then
				if ExitKindID == 1 then -- door
					echo("Door in " .. FromID .. " facing " .. exitMap[dirtype] .. "\n")
					setDoor(FromID, doorMap[dirtype], 2)
				elseif ExitKindID == 2 then -- locked door
					--echo("Locked door in " .. FromID .. " facing " .. exitMap[dirtype] .. "\n")
					setDoor(FromID, doorMap[dirtype], 3)
				end
			else
				echo("nil exit match\n")
				display(FromID)
			end

		end

		row = recs:fetch({})
	end
	recs:close()
end

function cmi:labelCmudZones(con)
	local recs, row, exitrecs, toID, DirType, zonerecs, toZone, fromZone, fromID, zonerec, zoneFetch, zoneName, input
	recs = assert(con:execute([[SELECT ObjId, X,Y,Z, ZoneID, Script FROM ObjectTbl]]))
	row = recs:fetch({})
	while row do
		fromID = tonumber(row[1])
		fromZone = tonumber(row[5])
		exitrecs = assert(con:execute([[SELECT ToID, DirType FROM ExitTbl WHERE FromID = ]]..fromID))
		toID = exitrecs:fetch({})
	
		while toID do
			toZone=nil
			
			zonerecs = assert(con:execute([[SELECT ZoneID FROM ObjectTbl WHERE ObjId = ]]..tonumber(toID[1])))
			
			local zonerecord = zonerecs:fetch({})
			
			if zonerecord ~= nil then
				toZone = tonumber(zonerecord[1])
			end
			
			if toZone ~= fromZone and toZone ~= nil then
				zonerec = assert(con:execute([[SELECT ZoneId, Name FROM ZoneTbl WHERE ZoneId = ]]..toZone))
				zoneFetch = zonerec:fetch({})
				zoneName = zoneFetch[2]

				DirType = cmi.cmudToMudletExit[toID[2]]

				if DirType == nil then
					DirType=4
				end

	 			input = fromID.." " .. DirType .. " red black "..zoneName -- numeric direction to place label
				--display(input)
				setRoomUserData(fromID, "edge", input)
				-- cmi:roomLabel(input)
			end
			toID = exitrecs:fetch({})
		end
		row = recs:fetch({})
	end
    if zonerec then
        zonerec:close()
    end
	zonerecs:close()
	exitrecs:close()
	recs:close()
end

function cmi:addFavorites(con)
	local recs, row, objId, Name
	recs = assert(con:execute([[SELECT Name, ObjID FROM FavTbl]]))
	row = recs:fetch({})
	while row do
		Name = row[1]
		objId = tonumber(row[2])
		setRoomUserData(objId, "favorite", Name)
		row = recs:fetch({})
	end
	recs:close()
end

function cmi:getConnection()
	if cmi.con then
		cmi.con:close()
	end
	if cmi.env then
		cmi.env:close()
	end
	cmi.env = assert (luasql.sqlite3())
	
	-- connect to data source
	--cmi.file = invokeFileDialog(true, "Select your cMud Map")

	--cmi.file = "/tmp/TorilMud.dbm"
	cmi.file = "/users/cleac/Google Drive/Toril/TorilMud.dbm"

	cmi.con = assert (cmi.env:connect(cmi.file))
end

function cmi:checkConnection()
	if not cmi.env or not cmi.file or not cmi.con then
		cmi:getConnection()
	end
end

function cmi:onlyExits()
	cmi:checkConnection()
	-- create environment object
	echo("Selected map: " .. cmi.file .. "\n")

	echo("[Adding exits]\n")
	cmi:addExits(cmi.con)
end

function cmi:importArea(xcmudid, xtorilid)
	cmi:checkConnection()
	-- create environment object
	echo("Selected map: " .. cmi.file .. "\n")
	
	echo("[Adding rooms]\n")
	cmi:addRooms(cmi.con, xcmudid, xtorilid)

	--cmi:colorRooms(cmi.con)
--	echo("[Adding exits]\n")
--	cmi:addExits(cmi.con)
	--set area names
	--cmi:addAreas(cmi.con)

   --cmi:addFavorites(cmi.con)
	--cmi:labelCmudZones(cmi.con)
end

function cmi:colorAreas()
	cmi:checkConnection()
	-- create environment object
	echo("Selected map: " .. cmi.file .. "\n")
	
	cmi:colorRooms(cmi.con)
end

function cmi:importAll()
	cmi:checkConnection()
	-- create environment object
	echo("Selected map: " .. cmi.file .. "\n")
	
	-- x cmi:addRooms(cmi.con)
	cmi:colorRooms(cmi.con)
	-- x cmi:addExits(cmi.con)


	--set area names
	--cmi:addAreas(cmi.con)

   --cmi:addFavorites(cmi.con)
	--cmi:labelCmudZones(cmi.con)
end</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>NyyLIB</name>
			<packageName>NyyLIB011dev</packageName>
			<script></script>
			<command></command>
			<keyCode>103</keyCode>
			<keyModifier>2949176</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>north</name>
				<packageName></packageName>
				<script>mud:send("n")</script>
				<command></command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>south</name>
				<packageName></packageName>
				<script>mud:send("s")</script>
				<command></command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>east</name>
				<packageName></packageName>
				<script>mud:send("e")</script>
				<command></command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>west</name>
				<packageName></packageName>
				<script>mud:send("w")</script>
				<command></command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>down</name>
				<packageName></packageName>
				<script>mud:send("d")</script>
				<command></command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>up</name>
				<packageName></packageName>
				<script>mud:send("u")</script>
				<command></command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>test</name>
				<packageName></packageName>
				<script>display("X")</script>
				<command></command>
				<keyCode>16777235</keyCode>
				<keyModifier>0</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
